はい、承知いたしました。
与えられた Markdown テキストに含まれる C 言語のコードブロックを、Google clang-format スタイルガイドに準拠し、インデントをスペース 4 つに設定して整形します。Markdown の構造は維持します。

--- START OF FILE output_formatted.md ---

μITRON 仕様準拠リアルタイムOS

カーネル編
ユーザーズガイド

μITRON4.0 仕様準拠リアルタイムOS

NORTi Version 4 ユーザーズガイド・カーネル編はじめに
株式会社ミスポが自信を持ってお届けする「 Version 4」は、社団法人トロン協会が策定し公開している「μITRON4.0仕様」に準拠したリアルタイムOSです。本製品には、CPU 例外ハンドラ定義を除くほぼ全てのμITRON4.0仕様のシステムコールが実装されています。
さらに、μITRON3.0仕様準拠「NORTi3」と互換のシステムコールも含めることにより、従来のソフトウェア資源をそのまま活用できる配慮をしてあります。
NORTiは、手軽に組込むことのできるコンパクトな組込み専用のOSです。コンパイラの標準ライブラリと同様に、ユーザーの作成したプログラムと、NORTiのライブラリとをリンクすることで、OSの機能が利用できるようになります。
NORTiは、省メモリを特長とし組込み機器に適した「ITRON TCP/IP API仕様」準拠のTCP/IP プロトコルスタックを搭載しています。不可欠な技術となったネットワーク接続の組込み機器開発に、NORTiを使用することで、いち早く対応できます。
豊富な機能と優れた性能と共に、全ソースコード標準添付、組込みロイヤリティ無料という特長を持つNORTiを、皆様方のシステム開発に、どうぞお役立てください。

本書について
本書「カーネル編」は、NORTi Version 4シリーズのリアルタイム・マルチタスク機能の共通マニュアルです。前半部で概要を説明し、後半部で各システムコールの解説をおこなっています。プロセッサ固有の記事については、インストールされたドキュメントを参照してください。TCP/IPプロトコルスタック機能については、「ネットワーク編」のユーザーズガイドを参照してください。

（余白）
第1章 基本事項

1.1 特長

高速な応答性
NORTiはプリエンプティブなマルチタスクOSです。イベントの発生によって優先度を元にしたスケジューリングが行われ、即座にタスクが切り替わります。十分に吟味されたコードでカーネルは構成されています。システムコール内部でスキャンすることなく1発で操作対象を選択でき、また、割込み禁止時間も旧来より半減されていて、CPUの能力を 大限に引き出すことができます。さらに、OSより高優先の割込みルーチンを導入することができ、この場合の割込み禁止時間は、限りなくゼロです。

コンパクトなサイズ
TCB等のカーネル内部の管理ブロック変数は、徹底的にサイズの 適化が行われています。貴重なRAM領域を1バイトたりとも無駄にしません。

Cで設計されたカーネル
NORTiの大部分は、理解しやすいC言語で記述されています。Cで設計されたOSが、全てアセンブラで記述されたOSより性能が劣ると考えるなら、それは誤解です。レジスタ割り付けをコンパイラに任せた方が、内部でのレジスタ待避/復元が 小で済み、返って高速となります。さらに、実績のあるソースコードを複数種のCPUで共有できますので、新規CPU対応版のリリース直後から信頼性を確保できます。

μITRON4.0とμITRON3.0の両仕様に準拠
トロン協会のμITRON4.0仕様は、3.0仕様との互換性を犠牲にしてしまいました。そこで、NORTi では、μITRON4.0仕様だけでなく、μITRON3.0仕様のインターフェースも実装することにより、前バージョン用に開発されたソフトウェアを、変更することなく共存して利用できるよう工夫してあります。

フルセットのμITRON
μITRON仕様を謳いながら、面倒な部分の実装を省いたり、日本向けとして他アーキテクチャへ無理にμITRON APIを被せたようなOSがある中、NORTiではμITRON4.0/3.0仕様でフルセットと位置づけられる機能を丁寧に実装し、豊富な同期通信手段を提供しています(CPU例外ハンドラの定義を除く)。

複数種のプロセッサ／コンパイラ／デバッガに対応
多くの16～32ビットのプロセッサに対応済みですので、ターゲットが変わっても、同じ作法でNORTiが使えます。また、開発環境の選択の幅が広がるよう、複数の開発ツールメーカーと協力して、積極的な対応を行っています。

1.2 タスクの状態
並列処理するプログラムの単位をタスクと呼びます。タスクは、NON-EXISTENT, DORMANT, READY, RUNNING, WAITING, SUSPENDED, WAITING-SUSPENDEDの7つの状態のいずれかをとります。
タスクの状態遷移を図に示します。

実行可能状態(READY)
より優先度の高いタスクが実行中のため、実行を待たされている状態です。あるいは、同じ優先度のタスクが先に実行状態となっているため、実行を待たされている状態です。

実行状態(RUNNING)
プロセッサを割り当てられて動作している状態です。RUNNING状態のタスクは、同時にはひとつしか存在しません。タスクにとっては、READY状態とRUNNING状態には大差がなく、 優先
READYタスクの別名がRUNNINGタスクともいえます。

待ち状態(WAITING)
自ら発行したシステムコールにより、実行が止まっている状態です。事象駆動(イベントドリブン)方式のマルチタスクでは、起動されたタスクは、ほどんどの期間をWAITING状態で過ごすはずです。そうでないと、タスクの待ちの間を利用して、別のタスクを実行できません。
WAITING状態は、その要因によって次の様に分類されます。
起床待ち(slp_tsk, tslp_tsk) 時間待ち(dly_tsk)
イベントフラグ成立待ち(wai_flg, twai_flg) セマフォ獲得待ち(wai_sem, twai_sem)
ミューテックス獲得待ち(loc_mtx, tloc_mtx)
メールボックスでのメッセージ受信待ち(rcv_mbx, trcv_mbx)
メッセージバッファでのメッセージ送信待ち(snd_mbf, tsnd_mbf) メッセージバッファでのメッセージ受信待ち(rcv_mbf, trcv_mbf) データキューでのメッセージ送信待ち(snd_dtq, tsnd_dtq) データキューでのメッセージ受信待ち(rcv_dtq, trcv_dtq) ランデブ呼出待ち(cal_por, tcal_por) ランデブ受付待ち(acp_por, tacp_por) ランデブ終了待ち(cal_por, tcal_por)
可変長メモリブロック獲得待ち(get_mpl, tget_mpl) 固定長メモリブロック獲得待ち(get_mpf, tget_mpf)

強制待ち状態(SUSPENDED)
他タスクによって、実行を止められた状態です。このSUSPENDED状態を利用する機会は多くありません。デバッグのために、タスクの実行を一時的に停止させる用途が考えられます。

二重待ち状態(WAITING-SUSPENDED)
管理の都合上、分けてありますが、SUSPENDED状態と同じと考えて差し支えありません。他タスクから実行を止めにいったらREADYでなくWAITING状態だったという違いだけです。待つこ
とまで止められている訳ではありません。待ち条件が満たされれば、WAITINGのみ外れて
SUSPENDED状態へ移ります。

休止状態(DORMANT)
DORMANT状態は、タスクが起動されていない状態、あるいはタスクが終了した状態です。実行中のタスクが、自ら発行したシステムコールにより、DORMAT状態になることもできますし、他タスクから強制的にDORMANT状態にさせられることもできます。

未登録状態(NON-EXISTENT)
NON-EXISTENT状態は、タスクが生成されていない状態、あるいはタスクが削除された状態です。

タスク切り替えの起きるタイミング
NORTiは、プリエンプティブなマルチタスクOSですので、あるタスクの実行中に、それより優先度の高いタスクの実行が割込みます。タスク切り替えの起きるタイミングとしては、次の4 通りがあります。

(1) 実行中のタスクが、自分より高優先のタスクを起動、あるいは、待ち解除するようなシステムコールを発行した。

(2) 非タスクコンテキスト（割込みハンドラ/割込みサービスルーチン/タイムイベントハンドラ）から、実行中タスクより高優先のタスクを起動、あるいは、待ち解除するようなシステムコールが発行された。

(3) 実行中タスクより高優先のタスクの待ち状態が、タイムアウトで解除された。

(4) 実行中のタスクが、自ら待ち状態に入った、優先度を下げた、あるいは、終了した。
逆に言えば、全てのシステムコールでタスク切り替えが起きるわけではありません。実行中タスクより優先度が低いタスクに対して起動や待ち解除の操作を行っても、即座にはタスク切り替えは起きません。上記の(4)で、操作されたタスクが 優先となるまで、タスク切り替えは待たされます。
優先度が同じ場合も低い場合と同様ですが、rot_rdqとchg_priでは、実行中のタスクが、実行待ち行列の末尾に回ることで、同一優先度間でのタスク切り替えが起きます。

NORTi3との差異
RUN → RUNNING, WAIT → WAITINGと、呼び名が変わりました。

1.3 用語

オブジェクトとID
システムコールの操作対象となるものを総称してオブジェクトと呼びます。オブジェクトを識別するための番号でユーザーが指定できるものをID番号と呼び、カーネルやソフトウェア部品の内部に閉じていてユーザが直接指定できないものをオブジェクト番号と呼びます。
ID番号を持ったオブジェクトには、タスク、セマフォ、イベントフラグ、メールボックス、メッセージバッファ、ランデブ用ポート、可変長／固定長メモリプール、データキュー、ミューテックス、周期ハンドラ、アラームハンドラ、割込みサービスルーチンがあります。オブジェクト番号で識別されるオブジェクトには、割込みハンドラ、ランデブ、静的に生成された割込みサービスルーチンがあります。

コンテキスト
直訳は「文脈」となりますが、システム内でのある時点のタスクの実行環境全体をそのタスクのコンテキストと言います。コンテキストとは、タスクが切り替えられる時に、保存／復元される物の総称ですが、具体的にはCPUのレジスタと読み代えても構いません。
DSPや浮動小数点演算ユニットをマルチタスクで使用する場合、そのレジスタ類もコンテキスト切り替えしなければなりません。NORTiでそれをサポートしていない場合、浮動小数点演算等は、排他制御する必要があります。

非タスクコンテキスト
割込みハンドラと、タイムイベントハンドラとを合わせて、非タスクコンテキストと呼びます。タイムイベントハンドラには、周期起動ハンドラとアラームハンドラ、オーバーランハンドラの3種類があります(μITRON3.0仕様では、非タスクコンテキストはタスク独立部、タイムイベントハンドラはタイマハンドラと呼称)。
非タスクコンテキストの各ハンドラはタスクでは無いため、自タスクを対象とするシステムコールを発行すことはできません。
なお、μITRON仕様では、非タスクコンテキスト専用システムコールの先頭文字をiとして区別してよいことになっています。NORTiの場合、システムコール内部でコンテキストを自動判別していますので区別は無く、i付きのシステムコールは、i無しのシステムコールに同じと、 kernel.hで定義してあります。

ディスパッチ
実行タスクを選択して切り替えることを、ディスパッチと呼びます。システムコールにはディスパッチの発生するものとそうでないものがあります。ディスパッチを発生させるシステム
コールでも、新しくREADYとなったタスクの優先度が、現在のRUNNINGタスクの優先度より低ければ、タスクは切り替わりません。また、非タスクコンテキストで発行されたシステムコールによるディスパッチは、タスクコンテキストへ復帰する時にまとめて行われます。これを、遅延ディスパッチと呼びます。

同期・通信機能
同期機能は、タスク間で待ち合わせを行うために使われます。通信機能は、タスク間でデータを渡すために使われます。通信では同期も伴うため、同期・通信機能とまとめて表現しています。
同期・通信機能を使わなくても、プログラマが慎重に設計すれば、共通変数を介して、タスク間の待ち合わせやデータの受け渡しが可能です。しかし、OSの機能を使う方が、楽でかつ安全です。
セマフォ、イベントフラグ、メールボックス、メッセージバッファ、ランデブ用ポート、データキュー、ミューテックスという7種類の、それぞれ特徴のある同期・通信の機構が設けられています。

待ち行列
1つのオブジェクトに対して、複数のタスクが要求を出した場合は、待ちタスクの行列ができます。セマフォ獲得待ち、イベントフラグ成立待ち、メールボックスのメッセージ受信待ち、メッセージバッファのメッセージ送信／受信待ち、ポートでのランデブ呼出／受付待ち、可変長／固定長メモリプールのメモリブロック獲得待ち、データキュー送信／受信待ち、ミューテックス獲得待ちで待ち行列がつくられます。
待ち行列の並びは先着順(FIFO:First In First Out)が基本ですが、セマフォ、メールボックス、メッセージバッファ受信側、可変長／固定長メモリプール、ミューテックスでは、タスクの優先度順あるいはメッセージ優先度順で並ぶことも可能です。

キューイング
相手のタスクが受け取れなくともエラーとせずに、要求をとっておくことをキューイングと言います。
タスクの起床要求とメールボックス／メッセージバッファ／データキューのメッセージは
キューイングされます。起床要求のキューイングは、要求回数のカウントで実現されます。メールボックスでのメッセージのキューイングは、ポインタでつないだ線形リストで実現されます。
メッセージバッファ／データキューでのメッセージのキューイングはリングバッファで実現されます。
イベントフラグおよびタスク例外では、キューイングではなく、OR演算によるイベントおよび要因の保留が行われます。この場合は、事象の有無のみ記録され回数は記録されない点がキューイングと異なります。

ポーリングとタイムアウト
待ちの生じるシステムコールには、待ちなし(ポーリング)の機能と、指定時間の経過で中断(タイムアウト)する機能とが用意されています。ポーリングの場合、待ちが必要ならば、エラーとなります。

パラメータとリターンパラメータ
μITRON仕様では、ユーザー側から渡すデータをパラメータと呼び、システムコール側から返るデータをリターンパラメータと呼びますが、本書ではCで一般的な引き数と表現しています。
システムコールの戻り値は原則としてエラーコードであるため、それ以外の値が返る場合は、これを格納する場所へのポインタを、引き数として指定します。

システムコールとサービスコール
アプリケーションからカーネルやソフトウェア部品を呼び出すインタフェース(API)をサービスコールと呼びます。カーネルのサービスコールを、特にシステムコールと呼びます。

排他制御
マルチタスクでは、同時にアクセスしてはいけないものに、複数のタスクがアクセスできてしまいます。リエントラントでない関数や、共有データなど、同時利用不可なものはたくさんあります。これらの資源が同時に利用されないよう管理することを排他制御といい、一般的にはセマフォあるいはミューテックスが使われます。
ただし、タスクの優先度が同一で、資源アクセス中に競合するタスクへの切り換えが行われないならば、排他制御の必要はありません(優先度の統一は、排他制御を不要にする有効な手段です)。実は、セマフォには、高優先度のタスクが、低優先度のタスクのセマフォ返却を待たなければならない優先度逆転というやっかいな問題がありますから、競合する区間の優先度を一時的に上げる方が良い場合があります。ミューテックスには必要に応じて優先度を上げるオプションがあります。しかし、排他制御するべき区間が短いなら一時的なディスパッチ禁止や割込み禁止により排他制御するのが簡単です。

アイドルタスク
アイドルタスクは、他の全てのタスクが止まっている時に実行されます。カーネル内部にもアイドルタスク部がありますが、ユーザーが、 低優先度で無限ループするタスクを作成すれば、それが、アイドルタスクとなります。
アイドルタスクは何も実行しないタスクですが、重要な意味を持っています。事象駆動(イベントドリブン)方式のマルチタスクで、アイドルタスクに実行順序が回らないということは、 CPUのパフォーマンス不足、あるいは、無駄にCPUパワーを消費しているタスクの存在を示唆しています。

静的なエラーと動的なエラー
システムコールから返るエラーは、静的なエラーと動的なエラーとに分類できます。静的なエラーとは、範囲外のID番号使用等のパラメータの異常で、システムの状態に関わらず必ず起こり、デバッグが終われば無くなる種類のものです。動的なエラーとは、待ち解除しようとしたタスクがまだ、待ちに入っていなかったとかのように、システムの状態やタイミングに依存する種類のものです。ポーリング失敗のように、動的エラーを積極的に利用するプログラミングもおこなわれます。
NORTiでは、高速化のために、静的なパラメータエラーをチェックしないライブラリも用意されています。

コンテキストエラー
システムコールには、非タスクコンテキスト(割込みハンドラやタイムイベントハンドラ)から発行できないものがあります。これに違反した場合は、システムコールからコンテキストエラーが返ります。これは静的なエラーですので、静的なパラメータをチェックしないライブラリでは、コンテキストエラーを検出しません。

静的APIと動的API
μITRON仕様では、大文字で記述される生成系のシステムコールを静的APIと呼びますが、これをOSで直接サポートする訳ではありません。静的APIの仕組みは、コンパイル時にTCB等の管理ブロックが確保され、それがシステム起動時に初期化されていることを前提としていま
す。つまり、コンパイル前に静的なAPIに合わせたコード生成が必要となり、そのためにμ
ITRON4.0仕様から導入されたのがコンフィグレータです。
NORTiの基本は動的なオブジェクトの生成ですので、NORTiのコンフィグレータは、コンフィグレーションファイルに記述された静的APIを、初期化時に実行される通常の動的APIのコードに置き換えることで、静的API対応を実現しています。

1.4 共通原則

システムコールの名称
ITRONのシステムコール名は、基本的にxxx_yyy型をしています。xxxが操作方法の省略名で、 yyyが操作対象の省略名です。xxx_yyyから派生したシステムコールは、先頭に1文字追加して、 zxxx_yyy型になります。ポーリングするシステムコールの先頭文字は\"p\"、タイムアウト有りのシステムコールの先頭文字は\"t\"、独自システムコールは\"v\"です。

データタイプの名称
ITRONのデータタイプ(型)の名称としては、すべて大文字を使用します。ポインタ型は、～Pの名称とします。構造体の型は、原則として、T\_～の名称とします。

引き数の名称
システムコールの説明で、引き数の名称には次のような原則を設けています。
p\_～ データを格納する場所へのポインタ pk\_～ パケット(構造体)へのポインタ
ppk\_～ パケット(構造体)へのポインタを格納する場所へのポインタ

| ～id | ID |
+=========================+============================================+
| ～no | 番号 |

| ～atr | 属性 |

| ～cd | コード |

| ～sz | サイズ(バイト数) |

| ～cnt | 個数 |

| ～ptn | ビットパターン |

| i～ | > 初期値 |

ゼロと負数の扱い
システムコールの入出力で、多くの場合、0は特別な意味を持ちます。タスクID を例に挙げると、0で「自タスク」を指定します。自タスクとは、そのシステムコールを発行したタスクのことです。0に特別な意味を持たせるため、ID 番号や優先度等は1 から始まっています。また、ITRON仕様で負の値は「システム」を意味します。システムコールのエラーコードは負の値となっています。
なお、μITRON3.0仕様以前では、システム用として負のID 番号(-1)～(-4)が予約されていましたが、μITRON4.0仕様で廃止され、NORTi でも使用していません。

1.5 データタイプ(32ビットCPUの場合)
ITRONでは、このように再定義した型でシステムコールを規定しています。INT, UINTは32ビットです。

汎用的なデータタイプ

```c
typedef signed char B;     /* 符号付き8ビット整数 */
typedef unsigned char UB;  /* 符号なし8ビット整数 */
typedef short H;           /* 符号付き16ビット整数 */
typedef unsigned short UH; /* 符号なし16ビット整数 */
typedef long W;            /* 符号付き32ビット整数 */
typedef unsigned long UW;  /* 符号なし32ビット整数 */
typedef char VB;           /* タイプ不定データ(8ビットサイズ) */
typedef int VH;            /* タイプ不定データ(16ビットサイズ) */
typedef long VW;           /* タイプ不定データ(32ビットサイズ) */
typedef void* VP;          /* タイプ不定データへのポインタ */
typedef void (*FP)();      /* プログラムのスタートアドレス一般 */
```

ITRONに依存した意味を持つデータタイプ

```c
typedef int INT;                   /* 符号付き整数 */
typedef unsigned int UINT;         /* 符号なし整数 */
typedef int BOOL;                  /* ブール値(FALSE(0)またはTRUE(1)) */
typedef INT FN;                    /* 関数コード */
typedef int ID;                    /* オブジェクトのID番号 */
typedef int RDVNO;                 /* ランデブ番号 */
typedef unsigned int ATR;          /* オブジェクト属性 */
typedef int ER;                    /* エラーコード */
typedef int PRI;                   /* タスク優先度 */
typedef long TMO;                  /* タイムアウト */
typedef int ER_ID;                 /* エラーコードまたはオブジェクトID番号 */
typedef long DLYTIME;              /* 遅延時間 */
typedef unsigned int STAT;         /* オブジェクトの状態 */
typedef unsigned int MODE;         /* サービスコールの動作モード */
typedef unsigned int ER_UINT;      /* エラーコードまたは符号なし整数 */
typedef unsigned int TEXPTN;       /* タスク例外パターン */
typedef unsigned int FLGPTN;       /* イベントフラグビットパターン */
typedef unsigned int RDVPTN;       /* ランデブパターン */
typedef unsigned int INHNO;        /* 割込みハンドラ番号 */
typedef unsigned int INTNO;        /* 割込み番号 */
typedef VP VP_INT;                 /* タスクパラメータおよび拡張情報 */
typedef unsigned long SIZE;        /* メモリ領域のサイズ */
```

時間に関するデータタイプ

```c
typedef struct t_systim { /* > システムクロックおよびシステム時刻 */
    H utime;              /* 上位16bit                            */
    UW ltime;             /* 下位32bit                            */
                          /*                                      */
} SYSTIM;                 /*                                      */
typedef long RELTIM;      /* 相対時間                             */
typedef long OVRTIM;      /* > オーバーラン時間                   */
```

NORTi3との差異

構造体だったCYCTIME,ALMTIMEは、整数型のRELTIMに統合されました。
SYSTIME → SYSTIM,RNO → RDVNO,HNO → INHNOに改名しました。
BOOL_IDは廃止されました。
VP_INT, ER_ID, ER_UINT, SIZE, MODE, STAT, FLGPTN, RDVPTN, TEXPTN, OVRTIM等が新設されました。
新設のSIZEやMODEという型は、ユーザープログラムではマクロとして使いがちでが、名前が衝突してコンパイルエラーとなる場合には、ユーザープログラム側を修正してください。
1.6 データタイプ(16ビットCPUの場合)
INT, UINTは16ビットです。intとshortが同じなので、HとUHをshortでなくintとしています。

汎用的なデータタイプ

```c
typedef signed char B;     /*  符号付き8ビット整数             */
typedef unsigned char UB;  /*  符号なし8ビット整数             */
typedef int H;             /*  符号付き16ビット整数            */
typedef unsigned int UH;   /*  符号なし16ビット整数            */
typedef long W;            /*  符号付き32ビット整数            */
typedef unsigned long UW;  /*  符号なし32ビット整数            */
typedef char VB;           /*  タイプ不定データ(8ビットサイズ) */
typedef int VH;            /* タイプ不定データ(16ビットサイズ) */
typedef long VW;           /* タイプ不定データ(32ビットサイズ) */
typedef void* VP;          /*  タイプ不定データへのポインタ    */
typedef void (*FP)();      /*  プログラムのスタートアドレス一般*/
```

ITRONに依存した意味を持つデータタイプ

```c
typedef int INT;                 /*  符号付き整数                         */
typedef unsigned int UINT;       /*  符号なし整数                         */
typedef int BOOL;                /*  ブール値(FALSE(0)またはTRUE(1))      */
typedef int ID;                  /* オブジェクトのID 番号                 */
typedef int RDVNO;               /*  ランデブ番号                         */
typedef unsigned int ATR;        /*  オブジェクト属性                     */
typedef int ER;                  /* エラーコード                          */
typedef int PRI;                 /*  タスク優先度                         */
typedef long TMO;                /*  タイムアウト                         */
typedef long DLYTIME;            /*  遅延時間                             */
typedef int ER_ID;               /* エラーコードまたはオブジェクトID 番号 */
typedef unsigned int STAT;       /*  オブジェクトの状態                   */
typedef unsigned int MODE;       /*  サービスコールの動作モード           */
typedef unsigned int ER_UINT;    /*  エラーコードまたは符号なし整数       */
typedef unsigned int TEXPTN;     /*  タスク例外パターン                   */
typedef unsigned int FLGPTN;     /*  イベントフラグビットパターン         */
typedef unsigned int RDVPTN;     /*  ランデブパターン                     */
typedef unsigned int INHNO;      /*  割込みハンドラ番号                   */
typedef unsigned int INTNO;      /*  割込み番号                           */
typedef VP VP_INT;               /*  タスクパラメータおよび拡張情報       */
typedef unsigned long SIZE;      /*  メモリ領域のサイズ                   */
```

※NORTiカーネル4.05.00以前では、MODEがUINTと誤実装されています。
※ER_BOOLはITRON 仕様書では定義されていますがNORTiでは使用していません。

時間に関するデータタイプ

```c
typedef struct t_systim { /*  システムクロックおよびシステム時刻 */
    H utime;              /* 上位16bit                           */
    UW ltime;             /* 下位32bit                           */
                          /*                                     */
} SYSTIM;                 /*                                     */
typedef long RELTIM;      /* 相対時間                            */
typedef long OVRTIM;      /*  オーバーラン時間                   */
```

NORTi3との差異
32ビットCPUの場合と同じ。

2.1 インストール
インストールされたNORTiの標準的なフォルダ構成は、次の様になっています。XXXはプロセッサシリーズ名(例：SH, H8, ARM, etc.)、BBBは評価ボード名(例：MS7709A, etc.)、YYYは対応コンパイラ略称(例：SHC8, CH386, ADS120, etc.)です。
/NORTi/INC ･･･････････ インクルードファイル
/NORTi/SRC ･･･････････ カーネルのソースファイル
/NORTi/SMP/XXX/BBB ･･･ サンプル
/NORTi/LIB/XXX/YYY ･･･ ライブラリ
/NORTi/DOC ･･･････････ ドキュメント
ここで説明するファイル名のxxxの部分は、プロセッサ／デバイスに依存します。拡張子は代表例で、実際にはコンパイラに依存します。ファイル構成についての 新の情報は、インストールされた補足説明書またはREADMEを参照してください。同じファイル名であっても、異なるバージョンや異なるプロセッサ、あるいはNORTi3 Standard/Extended/Networkのファイルと混在させないでください。

インクルードファイル
INCフォルダには、次のヘッダファイルが収められています。
itron.h ･･････････････ ITRON 標準ヘッダ
kernel.h ･････････････ カーネル標準ヘッダ
nosys4.h ･････････････ システム内部定義ヘッダ
nocfg4.h ･････････････ コンフィグレーションヘッダ
n4rxxx.h ･････････････ CPU差異定義ヘッダ
n4hook.h ････････････ フックルーチン定義ヘッダ
norti3.h ･････････････ NORTi3互換用カーネル標準ヘッダ
nosys3.h ･････････････ NORTi3互換用システム内部定義ヘッダ
nocfg3.h ･････････････ NORTi3互換用コンフィグレーションヘッダ
n3rxxx.h ･････････････ NORTi3互換用CPU 差異定義ヘッダ
n3hook.h ････････････ NORTi3互換用フックルーチン定義ヘッダ
nosio.h ･･････････････ シリアル入出力関数ヘッダ
non????.h ････････････ ネットワーク用のヘッダ(ネットワーク編参照)

kernel.hは、NORTiを利用するすべてのソースファイルで#includeしてください。データタイプ、共通定数、関数プロトタイプ等、NORTiの機能を使用するために必要なすべての定義と宣言が記載されています。itron.hは、このkernel.hからインクルードされているので、ユーザーのソースファイルから#includeする必要はありません。
nocfg4.hには、 大タスク数等のコンフィグレーション用定数の標準値と、カーネル内部で使用する変数の実体が定義されています。コンフィグレータを使用しない場合、ユーザープログラムの1つのファイルでのみ#includeしてください。コンフィグレータを使用する場合は、コンフィグレータが生成するkernel_cfg.cに#includeされるので、ユーザーのソースファイルから#includeする必要はありません。
nosys4.hには、カーネルのすべての内部定義が記載されています。nocfg4.hからインクルードされており、通常は、ユーザープログラムから#includeする必要はありません。n4rxxx.h には、対応プロセッサによって異なる部分が定義されています。nosys4.hからインクルードされており、ユーザープログラムから#includeする必要はありません。

ライブラリ
LIBフォルダには、カーネルのライブラリモジュールファイルと、それを生成するためのメイクファイルが収められています。
n4exxx.lib ････････････････ カーネルライブラリ
n4exxx.mak ････････････････ 同上を生成するメイクファイル
n4fxxx.lib ････････････････ パラメータチェック無しカーネルライブラリ
n4fxxx.mak ････････････････ 同上を生成するメイクファイル
n4nxxx.???,n4dxxx.???････ ネットワーク用のライブラリ(ネットワーク編参照)

コンパイラによっては、ライブラリの拡張子がlib 以外の場合があります。
コンパイラによっては、ライブラリアンのコマンドファイルも納められています。
パラメータチェック無しライブラリとは、高速化のため、パラメータの静的なエラーチェックを省略したライブラリです。NORTiのSYSER変数にエラーコードがセットされなくなったら、パラメータチェック無しライブラリに取り替えても良い目安となります。

ソースファイル
SRCフォルダには、カーネルのソースファイルが収められています。

n4cxxx.asm ･･･････････ CPU インターフェースモジュール
noknl4.c ･････････････ NORTi カーネルソース
non????.c ････････････ ネットワーク用のソース(ネットワーク編参照)

コンパイラによっては、アセンブラソースの拡張子がasm以外の場合があります。

サンプル
周期タイマ割込みハンドラと、ハードウェア依存の割込み管理機能は、基本的にはユーザー側で作成すべきモジュールです。サンプルとして付属しているソースファイルを参考にして作成してください。
n4ixxxx.c ････････････ 割込み管理機能／周期タイマ割込みハンドラソース
nosxxxx.c ････････････ シリアル入出力ドライバソース(付属しない場合もあり)
nosxxxx.h ････････････ シリアル入出力ドライバヘッダ(付属しない場合もあり)

その他に、対応プロセッサの内蔵I/O を定義したヘッダファイル、スタートアップルーチン例、サンプルmainソース、ネットワーク用のサンプルソース、メイクやビルドファイル等が収められています。

2.2 カーネルコンフィグレーション
NORTiでは、他のμITRON仕様OSのような面倒なコンフィグレーション手順はありません。ユーザープログラムのソースファイルの１つ、通常は、main関数が含まれるファイルに、いくつかの
#defineとnocfg4.hの#includeを記述するだけで、コンフィグレーションは完了です。
ネットワーク等のソフトウェア部品を使用する場合には、ユーザプログラムで使用するID番号とソフトウェア部品が使用するID番号とが競合しないようにする必要があります。このような場合、コンフィグレータを使用することでID番号の自動割付等をおこなうことができます。コンフィグレータに付いては、コンフィグレータ編を参照してください。ここではコンフィグレータを使用しない場合のカーネルコンフィグレーションについて説明します。

標準値でのコンフィグレーション
次の様な標準値でよければ、#include "nocfg4.h"を記述するだけです。
タスクID････････････････････････････････ 8
タイムイベントハンドラID 上限････････････ 1
他のオブジェクトの各ID ･･････････････････ 8
タスク優先度上限･････････････････････････ 8
割込みハンドラのスタックサイズ･･･････････
T_CTX型の4倍サイズ^(\*1)^
タイムイベントハンドラのスタックサイズ･･･
T_CTX型の4倍サイズ
システムメモリのサイズ･･･････････････････ 0(スタック用メモリを使用)
メモリプール用メモリのサイズ･････････････ 0(スタック用メモリを使用)
スタック用メモリのサイズ･････････････････ 0(デフォルトのスタックを使用)^(\*2)^

(\*1) T_CTX は、n4rxxx.h に定義されていて、そのサイズは、スタックポインタ(SP)を除くCPU の全レジスタサイズの合計と同じです。
(\*2) デフォルトのスタックとは、通常、リンカで指定されるスタックセクションの先頭アドレスから、リセット時に
SP に設定されるアドレスまでの領域を指します。

標準値以外でのコンフィグレーション
ID や優先度の上下限は、下記の通りです。
タスクID ／タイムイベントハンドラID ･･ 1～253^(\*3)^ 他のオブジェクトのID ･････････････････ 1～999^(\*4)^ タスク優先度 ･･････････････････････････ 1～31
(\*3) このIDは、1バイトで管理されており、255と254は、内部で特別な意味に使われています。
(\*4) その他IDは、intで管理のためメモリ限界まで事実上無制限ですが、保証は3桁までとしています。
タスク優先度の上限については、なるべく小さな値を指定してください。優先度数が大きいと、優先タスクを選ぶのに数命令ずつ余分な時間がかかります。また、優先度順の待ち行列を管理する各内部データのサイズが、優先度１毎に１バイト増加します。
タスク優先度以外の定義では、上限を大きくしたことによる速度的なオーバヘッドはありません。ただし、ID毎に内部でポインタを１個定義しますので、RAM容量の少ないシステムでは、必要 小限にしてください。例を示します。

```c
#define TSKID_MAX 16           /* タスクID上限                         */
#define SEMID_MAX 4            /* セマフォID上限                     */
#define FLGID_MAX 5            /* イベントフラグID上限               */
#define MBXID_MAX 3            /* メールボックスID上限             */
#define MBFID_MAX 2            /* メッセージバッファID上限             */
#define PORID_MAX 2            /* ランデブ用ポートID上限               */
#define MPLID_MAX 3            /* 可変長メモリプールID上限             */
#define MPFID_MAX 3            /* 固定長メモリプールID上限             */
#define DTQID_MAX 1            /* データキューID上限                   */
#define MTXID_MAX 1            /* ミューテックスID上限               */
#define ISRID_MAX 1            /* 割込みサービスルーチンID上限       */
#define SVCFN_MAX 1            /* 拡張サービスコールルーチンID上限   */
#define CYCNO_MAX 2            /* 周期ハンドラID上限                 */
#define ALMNO_MAX 2            /* アラームハンドラID上限               */
#define TPRI_MAX 4             /* タスク優先度上限                   */
#include "nocfg4.h"            /*                                      */
```

タイマキューのサイズ
タイムアウトやタイムイベントハンドラを実現するために、3種類タイマキューがあります。
RAMに余裕がある場合は、各キューのサイズを256に変更してください。タイムアウト機能や時間管理機能の処理速度が大幅に改善されます。設定可能な値は、2の階乗の数値(1, 2, 4, 8,
16, 32, 64, 128, 256)です。例を示します。

```c
#define TMRQSZ 256   /* タスクのタイマキューサイズ           */
#define CYCQSZ 128   /* 周期起動ハンドラのタイマキューサイズ */
#define ALMQSZ 64    /* アラームハンドラのタイマキューサイズ */
:                    /*                                      */
#include "nocfg4.h"  /*                                      */
```

割込みハンドラのスタックサイズ
割込みハンドラのスタックサイズは、標準でコンテキスト型(T_CTX)の4倍サイズと定義されています。RAM容量が不足する場合は、この値を慎重に削ってください。
割込みハンドラのスタックは、システム初期化時に「スタック用メモリ」から動的に確保され、全ての割込みハンドラで、このスタック領域を共有します。多重割込みがあるならば、割込みハンドラのスタックサイズに割込みネストの分の追加が必要なことを考慮してください。例を示します。

```c
#define ISTKSZ 400 /* 割込みハンドラのスタックサイズ */

:

#include "nocfg4.h"
```

タイムイベントハンドラのスタックサイズ
タイムイベントハンドラ（周期起動ハンドラとアラームハンドラ）のスタックサイズは、標準でコンテキスト型（T_CTX ）の4 倍サイズと定義されています。RAM 容量が不足する場合は、この値を慎重に削ってください。
タイムイベントハンドラのスタックには、システム初期化時にmain 関数が動作している「デフォルトのスタック」を使います。全てのタイムイベントハンドラで、このスタック領域を共有しますが、タイムイベントハンドラがネストすることはありません。
定義例を示します。

```c
#define TSTKSZ 300 /* タイムイベントハンドラのスタックサイズ */

:

#include "nocfg4.h"
```

システムメモリと管理ブロックのサイズ
タスクやセマフォやイベントフラグ等の管理ブロックは、全て、OS が用意する「システムメモリ」から動的に割り当てられます。次の表を元に必要なサイズを合計し、その値以上の数値を、システムメモリのサイズSYSMSZ に定義してください。この表は各管理ブロックの 小サイズを示しています。

① ②

+-----------+---------+-----------------------------------------------+
| 40 | > 40 | ×タスク数 |
+===========+=========+===============================================+
| 12 | > 12 | ×セマフォ数 |
+-----------+---------+-----------------------------------------------+
| 16 | > 12 | ×ミューテックス数 |
+-----------+---------+-----------------------------------------------+
| 12 | > 12 | ×イベントフラグ数 |
+-----------+---------+-----------------------------------------------+
| 12 | > 12 | ×メールボックス数 |
+-----------+---------+-----------------------------------------------+
| 24 | > 24 | ×メッセージバッファ数 |
+-----------+---------+-----------------------------------------------+
| 28 | > 28 | ×データキュー数 |
+-----------+---------+-----------------------------------------------+
| 12 | > 12 | ×ランデブ用ポート数 |
+-----------+---------+-----------------------------------------------+
| 20 | > 20 | ×可変長メモリプール数 |
+-----------+---------+-----------------------------------------------+
| 20 | > 20 | ×固定長メモリプール数 |
+-----------+---------+-----------------------------------------------+
| 28 | > 24 | ×周期ハンドラ数 |
+-----------+---------+-----------------------------------------------+
| 20 | > 16 | ×アラームハンドラ数 |
+-----------+---------+-----------------------------------------------+
| 12 | > 12 | ×オーバーランハンドラ数 |
+-----------+---------+-----------------------------------------------+
| 20 | > 20 | ×割込みサービスルーチン数 |
+-----------+---------+-----------------------------------------------+
| 8 | > 8 | > ×拡張サービスコール数 |
+-----------+---------+-----------------------------------------------+
| 16 | > 16 | ×タスク例外処理数 |
+-----------+---------+-----------------------------------------------+

1.  ポインタ32ビット, int型32ビットの場合(SH, 68K, V800, PowerPC, ARM, MIPS等)

2.  ポインタ32ビット, int型16ビットの場合(H8S, H8/300H, 8086 等) タスク優先度順の待ちを指定して生成したオブジェクトの管理ブロックには、(1バイト×タスク優先度上限TPRI_MAX)のサイズが加算されます。加算した結果のサイズ合計がintサイズで割り切れない場合は、端数分が切り上げられます。また、オブジェクト生成情報がROMではなく
    RAMに存在する場合、オブジェクト生成情報がシステムメモリにコピーされます。
    システムメモリ使用量は同時に生成するオブジェクト数で決まります。オブジェクト数の上限値として8を指定しても同時に生成しなければ8個分確保する必要はありません。SYSMSZの標準値は0で、この場合、「スタック用メモリ」からシステムメモリが割り当てられますので、スタック用メモリが十分にある場合、SYSMSZを指定しない方が楽です。
    定義例を示します。

```c

#define SYSMSZ 2352 /* システムメモリのサイズ */

:

#include "nocfg4.h"

```

メモリプール用メモリのサイズ
固定長／可変長メモリプールのメモリブロックとメッセージバッファのリングバッファ領域は、OSが用意する「メモリプール用メモリ」から割り当てられます。アプリケーションに必要なサイズを定義してください。標準値は0で、この場合、「スタック用メモリ」からメモリプールが割り当てられますので、スタック用メモリが十分にある場合、MPLMSZを指定しない方が楽です。

```c

#define MPLMSZ 2048 /* メモリプール用メモリのサイズ */

:

#include "nocfg4.h"

```

スタック用メモリのサイズ
cre_tskでスタック領域を明示しない場合のタスクのスタックや割込みハンドラ/割込みサービスルーチンのスタックは、OSが用意する「スタック用メモリ」から割り当てられます。
さらに、SYSMSZを0とした場合のシステムメモリ、MPLMSZを0とした場合のメモリプール用メモリも、このスタック用メモリから割り当てられます。
スタック用メモリのサイズを定義する STKMSZの標準値は0 で、この場合、main関数が使っている処理系のデフォルトのスタック領域(スタックセクション)を、OSのスタック用メモリとします。この場合の実際のスタックサイズは、リンカでのセクション設定とスタートアップルーチンでの初期スタックポインタ値で決まります。
なお、タイムイベントハンドラは、STKMSZに0以外を定義した場合も、 main関数のスタックを引き継ぐために、処理系のデフォルトのスタック領域の方を使用します。

:

```c

#define STKMSZ 2048 /* スタック用メモリのサイズ */

:

#include "nocfg4.h"

```

動的なメモリ管理について
システムメモリ、メモリプール用メモリ、および、スタック用メモリにおいて、生成と削除とを繰り返すと、メモリが断片化する可能性は避けられません。すなわち、合計サイズでは足りているのに、連続空き領域のサイズが小さくて、要求サイズが確保できなくなる可能性があります。また、動的なメモリ管理の処理時間は、その時のメモリ割当ての状態に依存します。処理時間の上限を押さえることはできません。
従って、システム起動時にまとめてオブジェクトを生成し、その後は削除/生成を繰り返さないプログラミングを推奨します。

カーネルの割込み禁止レベル
カーネル内部のクリティカルな区間では、一時的に割込みを禁止しています。レベル割込み機能のあるプロセッサでは、このカーネルの割込み禁止レベルを選択できます。
NORTiが管理する割込みハンドラの割込みサービスルーチンの割込みレベルは、カーネルの割込み禁止レベル以下でなければなりません。カーネルの割込み禁止レベルより高い優先度の割込みハンドラや割込みサービスルーチンは暴走の原因となりますので注意してください。

:

```c

#define KNL_LEVEL 6 /* カーネルの割込み禁止レベル */

:

#include "nocfg4.h"

```

IDの定義
μITRON仕様では、IDを予め決めておく必要があります。全てのIDを#defineしてあるヘッダファイルを、ユーザープログラムの各ソースファイルから#includeすればよいでしょう。

(例1) －kernel_id.h－ －各ソース－

```c

#define ID_MainTsk 1
#define ID_KeyTsk 2
#define ID_ConSem 1
#define ID_KeyFlg 1
#define ID_ErrMbf 1

```

```c
#include "kernel.h"
#include "kernel_id.h"

:
```

コンフィグレータを使用した場合、kernel_id.hは、コンフィグレーションファイルの静的API を元に自動的に生成されます。
IDをグローバル変数として定義すれば、ID値が変更になった時に、全ファイルを再コンパイルしなくて済みます。

IDの自動割り当て
acre_xxxシステムコールによりオブジェクトを生成すると、空いていたID番号を戻り値として得ることができます。そのため、ID番号を予め定義する必要がありません。この場合は、(例2)の様にグローバル変数として、ID番号を参照すると良いでしょう。
空きID番号の検索は大きい方からですので、自動割り当てするID番号と、小さい方から
#defineしたID番号との衝突が避けられます。

2.3 ユーザープログラムの作成例
2つのタスクを使った簡単な例を挙げます。task1の待ちをtask2が解除します。

```c
#include "kernel.h"
#include "nocfg4.h"

TASK task1(void) /* タスク１ */ {
    FLGPTN ptn;

    for (;;) {
        tslp_tsk(100 / MSEC);
        wai_sem(1);
        wai_sem(1);

        wai_flg(1, 0x01, TWF_ORW, &ptn);
    }
}

TASK task2(void) /* タスク2 */ {
    for (;;) {
        wup_tsk(1);
        sig_sem(1);
        set_flg(1, 0x0001);
    }
}
```

```c
const T_CTSK ctsk1 = {TA_HLNG, NULL, task1, 1, 512, NULL};
const T_CTSK ctsk2 = {TA_HLNG, NULL, task2, 2, 512, NULL};
const T_CSEM csem1 = {TA_TFIFO, 0, 1};
const T_CFLG cflg1 = {TA_CLR, 0};
```

```c
void main(void) /* メイン */ {
    sysini(); /* システム初期化 */

    cre_tsk(1, &ctsk1); /* タスク1を生成 */
    cre_tsk(2, &ctsk2); /* タスク2を生成 */
    cre_sem(1, &csem1); /* セマフォ1を生成 */
    cre_flg(1, &cflg1); /* イベントフラグ１を生成 \*/

    sta_tsk(1, 0); /* タスク1を起動 */
    sta_tsk(2, 0); /* タスク2を起動 */
    intsta();      /* 周期タイマ割込み起動 */
    syssta();      /* システム起動 */
}
```

コンパイル例
前ページのsample.cをコンパイル/リンクする例を示します。vecxxx.asmとinit.cは、割込みベクタの定義とスタートアップルーチンです。スタートアップルーチンは、コンパイラによってファイル名が異なったり、Cの標準ライブラリに含まれていて不要だったりします。
n4ixxx.cとn4exxx.libは、NORTiの周期タイマ割込みハンドラとカーネルライブラリです。 standard.libは、Cの標準ライブラリを示しており、コンパイラによってファイル名が異なります。

```sh
\>asm vecxxx.asm
\>cc init.c
\>cc sample.c
\>cc n4ixxx.c
\>link vecxxx.obj init.obj sample.obj n4ixxx.obj n4exxx.lib standard.lib
```

以上の例題から、マルチタスクプログラムを作成するにあたって、なんら特別な手順が必要ないことが、理解できると思います。
第3章 タスクやハンドラの記述
システムを構成するソフトウェアは、OS部分とユーザプログラム部分に分けることができます。
一般にタスクとタスク例外処理ハンドラはユーザプログラムにハンドラはOS部分に分類されます。
この章では、ユーザが記述しなければならないタスクとハンドラ類の具体的な記述形式を説明します。

3.1 タスクの記述

タスクの記述方法
タスクの記述に関しては次の2点を守るだけで、他は普通のC 関数と変わりません。

- TASK型の関数とすること

- 引数はint型かvoidとすること

タスクの記述例

終了するタイプのタスクは、次のように記述してください。
ext_tsk()は省略可能ですが、明示的にタスク終了を記述することを推奨します。

```c
TASK task1(int stacd) {
    : :

        ext_tsk();
}
```

繰り返すタイプのタスクは、次のように記述してください。
組込みシステムにおいて、ほとんどのタスクは、このタイプとなります。

```c
TASK task1(int stacd) {
    for (;;) {
        :

            :
    }
}
```

割込みマスク状態
起動されたタスクは、割込み許可状態です。

タスク例外処理ルーチン
各タスクにひとつずつタスク例外処理ルーチンを定義することができます。タスク例外処理機能
を使用する場合には、タスク例外処理ルーチンを次のように記述してください。

```c
void texrtn(TEXPTN texptn, VP_INT exinf) {
    :

        :
}
```

TEXPTNは、タスク例外要因型でitron.hで定義されています。

3.2 割込みサービスルーチンの記述と割込みハンドラの記述

概要
μITRON仕様の割込み管理には、割込みが発生すると、直接、ユーザーの作成した「割込みハンドラ」に制御が渡る方式と、一旦カーネル内で処理をおこなってからユーザーの作成した
「割込みサービスルーチン」が呼び出される方式とがあります。
割込みハンドラでは、レジスタの待避と復元(NORTiでは、ent_intとret_int)をユーザーが記述する必要があります。一方、割込みサービスルーチンでは、先に、OS内部の割込みハンドラがその処理を行っているため、レジスタ待避/復元処理をユーザーが記述する必要がありません。つまり普通のC 関数とすることができます。この割込みサービスルーチンは、μITRON4.0 仕様から導入された仕組みです。
割込みハンドラおよび割込みサービスルーチンは、割込み状態で実行されるため 小限の処理だけをおこなうようにし、後は割込みを待っているタスクを起床して、実質的な割込み処理を行わせるのが、一般的です。当然ですが、割込み処理の中では、待ちとなるシステムコールを発行することはできません。また、動的なメモリ管理を伴うシステムコール(オブジェクトの生成／削除や可変長メモリブール)も発行できません。

割込みサービスルーチンの記述方法
割込みサービスルーチン(ISR)は以下の様な一般のC 関数として記述することができます。普通の割込みルーチン同様の配慮をおこなう以外、auto変数の使用制限等はありません。exinf はISR生成時に指定した拡張情報です。

```c
void isr(VP_INT exinf) {
    :

        :
}
```

割込みマスク状態
割込み禁止／許可の2値しかないCPUの場合、起動されたISRは、割込み禁止状態です。レベル割込み機能を持ったCPUの場合、起動されたISRのレベルは、ハードウェアの割込みのレベルと一致しています。より優先度の高い割込みが発生した場合は、多重割込みが受け付けられます。

割込みハンドラの記述方法
割込みハンドラの記述に関しては次の2点を守るとともに、普通の割込みルーチン同様の配慮をおこなってください。

- INTHDR型の関数とすること

- ent_intで始め、ret_intシステムコールで終了すること(カーネルの割込み禁止レベルより高優先度の割込みハンドラは除く)

割込みハンドラの記述例

```c
INTHDR inthdr1(void) {
    ent_int();

    :

        :

        ret_int();
}
```

ent_intシステムコール
割込みハンドラを全てCで記述できるようにするため、NORTiでは独自の仕様として、割込みハンドラの入口で呼ばれるent_intシステムコールを設けています。
ent_intでは、レジスタの退避をおこなうと共に、スタックポインタを割込みハンドラ専用のスタック領域に切り替えています。従って、各タスクのスタックには、割込みハンドラが使う分を加算する必要がありません。
レジスタの多いプロセッサでは、ent_intで全レジスタを待避しません。コンパイラが待避せずに使用するレジスタのみを待避します。残りのレジスタは、割込み出口のret_intシステムコールで、ディスパッチが発生すると判断した時のみ待避されます。この処理により、ディスパッチが無い場合やネストして割り込んだ割込みハンドラの処理時間を短縮しています。

ent_int前の不要命令
ent_intシステムコールの呼び出し前に、レジスタを破壊したりスタックポインタがずれるような命令が絶対に入ってはいけません。第一の対策として、割込みハンドラのコンパイルには、適化オプションを付けてください。デバッグオプションを付けてコンパイルすると、 適化が効かないコンパイラもありますので注意してください。
割込みハンドラ関数の内容やコンパイラのバージョンやコンパイル条件によって、関数入り口で生成される不要な命令は変化するかもしれません。必ずアセンブルリストを出力させて、確認をおこなってください。RISC系のプロセッサでは、ent_intだけでレジスタを待避できない場合があり、コンパイラが提供するinterrupt関数機能を使います。この場合には、ent_int の前にレジスタ待避命令が展開されるのが正常です。

auto変数の禁止
割込みハンドラ入り口でauto変数を定義すると、スタックポインタが、ent_int想定値よりずれてしまいます。static変数とするか、割込みハンドラからさらに関数を呼んで、そこにauto 変数を定義してください。ただし、auto変数がスタック上ではなくレジスタ変数となることが分かっている場合は、auto変数を使うことが可能です。
割込みハンドラ関数で複雑な処理をおこなうと、やはりent_intの前に予期しない命令が展開される場合があります。その場合も、割込みハンドラからさらに関数を呼んで、そこで実際の処理をおこなってください。

インライン展開の抑制
割込みハンドラからさらに関数を呼ぶように記述しても、コンパイラの 適化により、その関数が割込みハンドラ内にインライン展開されてしまう場合があります。この場合は、インライン展開を禁止するオプションを付けてコンパイルしてください。

部分的なアセンブラによる記述
どうしても、ent_int前の不要命令が抑制できない場合は、割込みサービスルーチンを使用するか、割込みハンドラの入口と出口のみをアセンブラで記述し、そこから本体C関数を呼んでください。(アセンブラの展開方法は、個別の補足説明書を参照)インラインアセンブラが使える場合は、それで不要命令をキャンセルする方法も考えられます。例えば生成されてしまった push命令を、インラインアセンブラのpop命令で打ち消す等々。

割込みマスク状態
割込み禁止／許可の2値しかないCPUの場合、起動された割込みハンドラは、割込み禁止状態です。多重割込みを許す場合は、割込みコントローラの操作により処理中の割込みをマスクした上で、直接CPUの割込みマスクを変更して、割込み許可にできます。
レベル割込み機能を持ったCPUの場合、ent_int()から復帰後の割込みハンドラのレベルは、
ハードウェアの割込みのレベルと一致しています。より優先度の高い割込みが発生した場合は、多重割込みが受け付けられます。

3.3 タイムイベントハンドラの記述

概要
μITRON仕様のタイムイベントハンドラには、繰り返し実行される周期ハンドラと、1度だけ実行されるアラームハンドラ、指定タスクが指定した時間を超えて実行された場合に実行されるオーバーランハンドラの3種類があります。
タイムイベントハンドラは、非タスクコンテキストとしてタスクより優先的に実行されます。タイムイベントハンドラを用いると、正確な時間による制御が可能です。また、タスクより管理ブロックやスタックに必要なメモリが少なくて済みます。
ただし、タイムイベントハンドラの中では、待ちとなるシステムコールを発行することはできません。

タイムイベントハンドラの記述方法
周期ハンドラおよびアラームハンドラの記述に関しては普通の割込みルーチン同様の配慮を
おこなってください。タイムイベントハンドラは以下の様なC関数として記述してください。
exinfはタイムイベントハンドラ生成時に指定した拡張情報です。

```c
void tmrhdr(VP_INT exinf) {
    :

        :
}
```

オーバーランハンドラの記述に関しても普通の割込みルーチン同様の配慮をおこなってください。オーバーランハンドラは以下の様なC関数として記述してください。tskidは、持ち時間を使い切ったタスクのタスクID、exinfはそのタスク生成時に指定した拡張情報です。

```c
void ovrhdr(ID tskid, VP_INT exinf) {
    :

        :
}
```

割込みマスク状態
全てのタイムイベントハンドラの処理が終わるまで、システムはディスパッチ禁止状態となっていますが、割込みは許可状態です。タイムイベントハンドラ内で割込み禁止にした場合は、割込み許可状態に戻してからリターンしてください。

補足
タイムイベントハンドラは、割込みハンドラの次に優先的に実行されますので、処理は十分に短くし、なるべく 適化コンパイルをおこなってください。なお、割込みハンドラと異なり、 auto変数は自由に使用できます。

3.4 初期化ハンドラ
ITRON仕様書では、システムの初期化方法については、処理系に依存するということで触れられていません。したがって本節の内容は、NORTi独自のものです。

スタートアップルーチン
他のμITRON仕様OSの中には、専用のスタートアップルーチンを用意して、マルチタスクに必要な初期化をおこなった後、main関数をタスクとして起動するタイプのものがあります。
一方、NORTiでは、特別なスタートアップルーチンを設けず、main関数までは、通常のプログラムと同じように実行されます。

main関数
NORTiでは、main関数をマルチタスクの初期化ハンドラとして位置づけています。main関数では、システム初期化sysini、I/O等の初期化、1個以上のタスク生成cre_tsk 、1個以上のタスク起動sta_tsk、必要ならセマフォやイベントフラグ等のオブジェクトの生成cre_xxx、周期タイマ割込みの起動とシステム起動syssta等をおこないます。
コンフィグレータを使用した場合main関数はkernel_cfg.cファイル内にコンフィグレータによって生成されます。

システム初期化
main関数の先頭でsysini関数を実行して、カーネルを初期化します。sysiniからは、機種依存する割込み関係の初期化をおこなうためintini関数が呼び出されます。標準的なintini関数はn4ixxx.cに収められていますが、ユーザーのシステムに適合しない場合は、独自に作成してください。

I/Oの初期化
マルチタスク動作の前に初期化しておきたいI/O等が有る場合は、main関数でそれらの初期化をおこないます。
コンフィグレータを使用する場合は、ATT_INI静的APIで登録したユーザー関数が呼び出されます。

オブジェクトの生成
タスクやセマフォやイベントフラグ等のオブジェクト生成は、main関数でおこなっても、タスクでおこなっても構いません。
オブジェクト生成や削除には動的なメモリ管理が伴うため、リアルタイム性に劣ります。オブジェクトの生成は、なるべくmain関数で1度だけおこなって、その後の生成や削除は 小限にした方がよいでしょう。
コンフィグレータを使用する場合は、CRE_xxx静的APIで登録したオブジェクト生成がおこなわれます。

タスクの起動
起動すべき全タスクをmain関数で起動しても構いません。1つだけ（いわゆるメインタスク）のみを起動して、そのタスクで残るタスクを起動しても構いません。起動されるタスクは既に生成されている必要があります。
コンフィグレータを使用する場合のタスク起動は、CRE_TSK静的APIのタスク属性にTA_ACTを指定します。

周期タイマ割込み起動
標準的には、intsta関数で、周期タイマ割込みを起動します。
機種依存する周期タイマ割込み、および割込み管理関係のモジュールは、ライブラリに含まれていませんので、付属のn4ixxx.cをコンパイルしてリンクする必要があります。付属の n4ixxx.cでは対応できない場合は、ユーザーご自身でn4ixxx.cを作成してください。
コンフィグレータを使用する場合、周期タイマはソフトウェア部品のひとつとして扱われます。
起動タイミング等はコンフィグレータマニュアルを参照してください。

システム起動
syssta関数を実行すると、いよいよマルチタスク動作がスタートします。そして、syssta関数はmain関数に戻って来ず、内部で無限ループします。(この部分が、NORTiのデフォルトのアイドルタスクになります)
ただし、syssta関数を実行する前の、cre_tskやsta_tskでエラーがあった場合は、マルチタスク動作をスタートせずにmain関数へ戻って来ます。

初期化ハンドラの記述例コンフィグレータを使用しない場合の記述例を以下に示します。

```c
#include "kernel.h"
/* コンフィグレーション \*/

#define TSKID_MAX 2   /* タスクID上限 */
#define SEMID_MAX 1   /* セマフォID上限 */
#define FLGID_MAX 1   /* イベントフラグID上限 */
#define TPRI_MAX 4    /* タスク優先度上限 */
#define TMRQSZ 256    /* タスクのタイマキューサイズ */
#define ISTKSZ 256    /* 割込みハンドラのスタックサイズ */
#define TSTKSZ 256    /* タイムイベントハンドラのスタックサイズ */
#define SYSMSZ 256    /* システムメモリのサイズ */
#define KNL_LEVEL 5   /* カーネルの割込み禁止レベル */

#include "nocfg4.h"

/* ID の定義 */
#define ID_MainTsk 1
#define ID_KeyTsk 2
#define ID_ComSem 1
#define ID_KeyFlg 1

/* オブジェクト生成情報 \*/

extern TASK MainTsk(void);
extern TASK KeyTsk(void);
const T_CTSK ctsk1 = {TA_HLNG, NULL, task1, 1, 512, NULL};
const T_CTSK ctsk2 = {TA_HLNG, NULL, task2, 2, 512, NULL};
const T_CSEM csem1 = {TA_TFIFO, 0, 1};
const T_CFLG cflg1 = {TA_CLR, 0};
/* メイン（初期化ハンドラ） \*/
void main(void) {
    sysini();                     /* システム初期化 \*/
    cre_tsk(ID_MainTsk, &ctsk1);  /* タスク生成 */
    cre_tsk(ID_KeyTsk, &ctsk2);   /* タスク生成 */
    cre_sem(ID_ConSem, &csem1);   /* セマフォ生成 */
    cre_flg(ID_KeyFlg, &cflg1);   /* イベントフラグ生成 */
    sta_tsk(ID_MainTsk, 0);       /* タスク起動 \*/
    intsta();                     /* 周期タイマ割込みを起動 */
    syssta();                     /* マルチタスクへ移行 \*/
}
```

第4章 機能概説

4.1 タスク管理機能

概要
タスク生成は cre_tsk により、タスク起動は sta_tsk または act_tsk によりおこないます。 act_tskを使用した場合、指定タスクが既にready状態であれば起動要求がキューイングされます。タスク終了は、自タスクを終了するext_tsk、他タスクを終了させるter_tskとに分かれています。起動要求がキューイングされているタスクを終了した場合、直ちに再起動されます。キューイングされている起動要求をキャンセルするにはcan_actを使用します。タスク削除は、自タスクを終了削除するexd_tsk、他タスクを削除するdel_tskとに分かれています。
優先度を変更するchg_pri 、優先度を参照するget_pri 、その他、タスクの状態を見るref_tsk とその簡易版のref_tst システムコールが、タスク管理機能に分類されています。

NORTi3との差異
タスクの起動要求act_tsk、起動要求をキャンセルするcan_act、タスク状態を参照するref_tst が追加されました。
スタック領域をユーザ領域に確保できる機能が追加されました。タスク生成後実行可能状態にするオプションが追加されました。
現在優先度の概念が導入されました。
現在優先度を参照するget_priが追加になりました。
タスク名を設定できるようになりました。
タスクのメインルーチンからのリターンでタスクを終了できるようになりました。
dis_dsp, ena_dsp, rot_rdq, get_tid, rel_waiの機能分類が変更されました。
vcre_tskがacre_tskに名称変更されました。
vsta_tskは廃止されました。sta_tskを使用してください。

タスク管理ブロック
タスクの管理は、タスク管理ブロック(TCB)と呼ばれるデータテーブルの情報に基づいておこなわれています。
μITRON仕様では、ユーザーがTCBやその他の管理ブロックに直接アクセスする方法は提供されていません。NORTiでは、nosys4.h を#includeすると、TCB等に直接アクセスすることが可能ですが、TCB等の構造はバージョンアップで変更される可能性があります。

スケジューリングとレディキュー
タスクの実行順序を決めることをスケジューリングと言います。μITRONでは、優先度ベースのスケジューリングがおこなわれます。
実行順序を管理する変数をレディキューと呼びます。レディキューには、優先度順で(同じ優先度なら先にREADYになった順で)タスクがつながれています。
優先のREADY タスクがRUNNING状態のタスクです(下図ではtask-A)。
このタスクがWAITINGやSUSPENDEDやDORMANT状態になると、レディキューから外れ、次に優先度の高いタスク(下図ではtask-B)が、RUNNING状態となります。

優先度
タスク優先度順オブジェクト待ち行列も、レディキューと同様の方法で実現しています。

4.2 タスク付属同期機能

概要
タスク付属同期機能に分類されるのは、sus_tsk, rsm_tsk, frsm_tsk, slp_tsk, tslp_tsk, wup_tsk, can_wup, rel_wai, dly_tskシステムコールです。

NORTi3との差異
dly_tskがタスク付属同期機能に分類されました。
can_wupのリターン値としてキューイングされていた起床要求数を返します。
ディスパッチ可能であればsus_tskで自タスクを指定できるようになりました。
wup_tskで自タスクを指定できるようになりました。
rel_waiがタスク付属同期機能に分類されました。

待ちと解除
タスクが自ら待ち状態WAITINGに移行するシステムコールとして、slp_tskとtslp_tskがあります。tslp_tskではタイムアウト時間を指定できます。すなわち単純な時間待ちにも利用できますが、基本的には単純な時間待ちにはdly_tsk を使うべきです。tslp_tskは、指定時間経過後E_TMOUTを返しますが、dly_tskはE_OKを返します。tslp_tskがE_OKを返すのはwup_tsk された場合です。wup_tskはキューイング機能があるため、tslp_tskを呼び出す前にwup_tsk されていると、タスクはWAITING状態に入らずに直ちにE_OKを返します。したがって、tslp_tsk ではタスクが指定された時間WAITINGするとは限りません。
なお、slp_tsk, tslp_tskの他、wai_flg, wai_sem, rcv_msg等のシステムコールでも、待ち状態WAITINGへ移行します。これらの待ち状態にあるタスクに対しては、wup_tskではなく rel_waiを発行することにより、強制的に待ちを解除することができます。

中断と再開
他のタスクの実行を中断して、強制待ち状態SUSPENDEDへ移行させるシステムコールとして sus_tskがあります。
強制待ち状態にあるタスクは、他からのrsm_tskまたはfrsm_tskシステムコールにより再開されます。rsm_tskとfrsm_tskの違いはキューイングの扱いにあります。frsm_tskでは、キューイングをすべてキャンセルしてタスクの実行を再開しますが、rsm_tskではキューイングされていた場合、キューイング数を-1するだけです。

二重待ち状態

待ち状態WAITINGにあるタスクに対してsus_tskシステムコールを発行すると、二重待ち状態
WAITING-SUSPENDEDへ移行します。
WAITING-SUSPENDED状態でも、WAITING状態と同様に、順番が来れば資源の割り当てがおこなわれます。そして資源が割り当てられると、WAITING-SUSPENDED状態からSUSPENDED状態に移行します。
すなわち、WAITING-SUSPENDED状態のタスクに対する特別措置(資源割り当て遅延等)はおこなわれませんから注意してください。

4.3 タスク例外処理機能

概要
タスク例外処理機能は、指定したタスクに実行中の処理を中断させ、タスク例外処理ルーチンを実行させるための機能です。タスク例外処理ルーチンは中断されたタスクのコンテキストで実行されます。指定したタスクが、WAITING状態などで実行中で無い場合には例外処理ルーチンの実行もおこなわれず、指定タスクがRUNNING状態になるまで待たされます。RUNNING状態になると、タスク本体ではなく例外処理ルーチンが先に実行され、例外処理ルーチンからリターンすることでタスク本体の処理が継続されます。タスク例外処理ルーチンは各タスクにひとつずつ登録することができます。
タスクに対して例外処理ルーチンを定義するためのdef_tex、例外処理を要求するras_tex、例外処理を禁止するdis_tex、許可するena_tex、禁止状態か否かを参照するsns_tex、例外処理状態を参照するref_texシステムコールがあります。

NORTi3との差異
μITRON4.0から導入された機能です。

例外処理ルーチンの起動と終了
タスク例外処理ルーチンを起動する場合には、要求する例外処理の種類を表す例外要因を指定してras_tex を呼びます。実際に例外処理ルーチンが起動されるのは、ena_texにより例外処理が許可され、例外要因が0以外で、指定されたタスクがRUNNING状態になったときです。例外処理ルーチンが起動されると、例外要因は0クリアされ、例外処理は禁止状態になります。例外処理ルーチンからリターンすると、例外処理ルーチンを起動する前に実行していた処理を継続します。この時、例外処理許可状態に戻ります。
タスク例外処理ルーチンからリターンせずにlongjmpを用いて大域脱出した場合は、例外処理を継続している状態であり例外処理許可状態に戻りません。また、例外処理ルーチンを起動する前の情報は失われます。たとえば、rcv_mbfでWAITING していた場合、受信したメッセージの情報は失われます。longjmpした場合は、タスクを終了するようにしてください。

例外要因
例外要因が0以外の時を例外処理要求ありと定義します。例外処理禁止状態のとき例外要求があると、例外要求は例外処理許可になるまで保留されます。例外要因はTEXPTN型の変数で実装されています。要求の保留は論理和を取ることでおこなわれます。したがって同一の要求が複数回上がってもOS機構としてタスク例外処理ルーチンは要求回数を認識できません。

4.4 同期・通信機能(セマフォ)

## 概要

セマフォは、資源の排他制御に使用します。非同期に動作する複数のタスクが、同時利用不可の資源(関数やデータや入出力等々)を共有する場合は、セマフォで資源の獲得と返却をおこなって排他制御する必要があります。セマフォは、排他制御すべき資源ごとに設けます。
セマフォの生成と削除はcre_sem, acre_semとdel_semでおこないます。資源の返却をおこなうsig_semに対し、資源の獲得待ちをおこなうwai_sem、待たずにポーリングをおこなう
pol_sem、タイムアウト付きで待つtwai_semがあります。その他に、セマフォの状態を参照するref_semシステムコールがあります。

## NORTi3との差異

preq_semがpol_semに名称変更されました。
セマフォ生成情報から拡張情報が削除されました。
ref_semで参照できる情報から、拡張情報が削除されました。
ref_semで参照できる情報で待ちタスクが無い場合、FALSEでなくTSK_NONEが返ります。
vcre_semがacre_semに名称変更されました。

セマフォ待ち行列
複数のタスクが同じセマフォを待つことができます。セマフォ生成時にFIFOを指定した場合は、先に要求した順番で、待ち行列をつくります。セマフォ生成時に優先度順を指定した場合
は、タスクの優先度順(同一優先度なら先に要求した順)で、待ち行列をつくります。

## Semaphore

セマフォ待ちタスクの行列

セマフォのカウント値
sig_semを実行した時、セマフォを待っているタスクが有る場合は、待ち行列の先頭のタスクをREADY状態にします。待ちタスクが無い場合は、セマフォのカウント値を+1します。
wai_semを実行した時、セマフォのカウント値が1以上の場合、カウント値を-1して、タスクは実行を継続します。カウント値が0の場合、タスクはWAITING状態になります。
一般的な用途ではセマフォカウントは0と1だけで十分ですから、セマフォ生成時に、セマフォ大値1を指定することを推奨します。

4.5 同期・通信機能(イベントフラグ)

概要
イベントフラグは、事象の有無だけを相手のタスクに知らせたい場合に使用します。
イベントフラグの生成と削除はcre_flg, acre_flgとdel_flgでおこないます。イベントフラグをセットするset_flgに対し、イベントフラグ成立を待つwai_flg、待たずにポーリングするpol_flg、タイムアウト付きで待つtwai_flgがあります。その他に、イベントフラグをクリアするclr_flg、イベントフラグの状態を参照するref_flgシステムコールがあります。

NORTi3との差異
イベントフラグのクリア指定がwai_flgの待ちモードで指定する方法のほかにイベントフラグ生成情報でも指定できるようになりました。
複数タスク待ちイベントフラグでタスク優先度順オプションが使えるようになりました。
イベントフラグ生成情報から拡張情報が削除されました。
ref_flgで参照できる情報から拡張情報が削除されました。
ref_flgで参照できる情報で待ちタスクが無い場合、FALSEでなくTSK_NONEが返ります。
vcre_flgがacre_flgに名称変更されました。

イベントフラグ待ち行列
同じイベントフラグを、同時に複数のタスクが待つことができます。これらのタスクの待ち条件が同じなら、1のset_flgで一斉に待ちを解除できます。ただし、クリア指定がされている時、それより後ろにつながれているタスクの待ちは解除されません。
ただし、同時に複数のタスクの待ちが解除される場合、システムコール処理時間の上限が押さえられませんので、複数タスク待ち機能は、なるべく使わないことを推奨します。複数タスク待ちを許すか否かは、イベントフラグ生成時に指定できます。

EventFlag

待ちモード
イベントフラグでは、複数ビットのフラグ群を用いていますので、待ち条件をビットパターンのAND, ORで指定することができます。AND待ちでは、パラメータで指定したビットのすべてが、イベントフラグ上にセットされるのを待ちます。OR待ちでは、指定したビットのいずれかが、イベントフラグ上にセットされるのを待ちます。

クリア指定
wai_flg, pol_flg, twai_flgシステムコールでは、パラメータの指定により、イベントフラグが成立した時、自動的にイベントフラグをクリアすることができます。生成時にクリア指定をした場合は常にクリアされます。
クリアは全てのビットに対しておこなわれます。

4.6 同期・通信機能(データキュー)

概要
データキューは、リングバッファで実装されたメールボックスです。バッファを使用するため送信時にも待ちが発生します。
データキューの生成と削除はcre_dtq, acre_dtqとdel_dtqでおこないます。データを送信するsnd_dtq、ポーリングで送信を試みるpsnd_dtq、タイムアウト付きで送信をおこなうtsnd_dtq に対し、メッセージの受信待ちをおこなうrcv_dtq、待たずにポーリングをおこなうprcv_dtq、タイムアウト付きで待つtrcv_dtqがあります。また強制的にデータを送信するfsnd_dtqがあります。その他に、データキューの状態を参照するref_dtqシステムコールがあります。

NORTi3との差異
μITRON4.0から導入された機能です。

待ち行列
データキューは、送信待ち行列、受信待ち行列、リングバッファから構成されます。送信時にバッファがフルの場合、送信しようとしたタスクは、データがバッファから取り除かれるまで送信待ち行列につながれます。受信時にバッファが空の場合、受信しようとしたタスクはデータが送信されるまで受信待ち行列につながれます。
リングバッファサイズを0にすることもできます。この場合、送信タスクと受信タスクはお互いに待ちあうことになり同期を取ることができます。
送信待ち行列は、到着順(FIFO)かタスク優先度順を指定することができます。受信待ち行列は常に到着順になります。

データ順
データに優先度を付けることはできません。しかし、fsnd_dtqを使用することでsnd_dtqで送信されたデータより先に受信されることがあります。
fsnd_dtqにより送信した時、バッファフルの場合にはバッファの先頭のデータを抹消してそこにデータを格納します。

4.7 同期・通信機能(メールボックス)

概要
メールボックスはタスク間での比較的大きなデータの受け渡しに使用します。実際に送信されるのは、メッセージと呼ばれるデータパケットへのポインタだけで、メッセージの内容そのものがコピーされる訳ではありません。コピーされないので、メッセージサイズに依存せず高速です。また、ユーザ領域の送信メッセージを線形リスト化し、管理するため送信待ちが発生しません。メールボックスにおける待ち行列は、メッセージ行列と受信待ちタスク行列です。
メールボックスの生成と削除はcre_mbx, acre_mbxとdel_mbxでおこないます。メッセージを送信するsnd_mbxに対し、メッセージの受信待ちをおこなうrcv_mbx、待たずにポーリングをおこなうprcv_mbx、タイムアウト付きで待つtrcv_mbxがあります。その他に、メールボックスの状態を参照するref_mbxシステムコールがあります。

NORTi3との差異
メールボックス生成情報から拡張情報が削除されました。
ref_mbxで参照できる情報から、拡張情報が削除されました。
vcer_mbxがacre_mbxに名称変更されました。
システムコール名称がXXX_msgからXXX_mbxに変わりました。

メッセージ待ち行列
複数のタスクが同じメールボックスで待つことができます。メールボックス生成時にFIFOを指定した場合は、先に要求した順番で待ち行列をつくります。メールボックス生成時に優先度順を指定した場合は、タスクの優先度順(同一優先度なら先に要求した順)で、待ち行列をつくります。
MailBox

受信
この図には両方が描かれていますが、メッセージ待ちタスクとキューイングされたメッセージが同時に存在することはありません。

メッセージキュー
メッセージは、受信タスクの有無にかかわらず、随時送信することができます。メッセージパケットの先頭部分が、次のメッセージを指すポインタとして使われます。したがって、ROM上のデータをメッセージパケットとすることができません。
メールボックス生成時に、メッセージのキューイング方法をFIFOに指定した場合は、先に送信された順番で、メッセージが行列をつくります。
メールボックス生成時に、メッセージのキューイング方法を優先度順に指定した場合は、メッセージが優先度別の行列をつくります(同一優先度内では送信された順に並びます)。したがって、優先度数を多くすると必要メモリ量が増加します。必要メモリ量は、TSZ_MPRIHDマクロによって知ることができます。

```c
mprihdsz = TSZ_MPRIHD(8);
```

メッセージパケット領域
メッセージはいつ受信タスクに引き取られるか分かりません。したがって、メッセージパケットをauto変数にとることは危険です。また、メッセージ領域を静的に定義しても、空いたかのチェックをおこなって再利用するのは面倒です。まだキューイングされているメッセージを再度送信した場合のシステム動作は保証できません。そこで、通常はメモリプールから獲得したメモリブロックをメッセージパケットに用います。
メールボックスは、メッセージパケットのサイズを関知しません。すなわち、メッセージ長に制限はありません。しかし、固定長メモリプールと組み合わせる場合は、必然的にメッセージパケットのサイズが固定されます。

4.8 拡張同期・通信機能(ミューテックス)

概要
ミューテックスは、セマフォと同様に資源の排他制御に使用します。セマフォとの違いは、優先度逆転を防ぐ機構をサポートしていることと、資源をロックしたままタスクが終了すると自動的にロック解除する点です。逆に、セマフォは資源が複数ある場合に使用するカウンタを持っていることと、ロックしたタスク以外のタスクでもロック解除できる特徴があります。
ミューテックスの生成と削除はcre_mtx, acre_mtxとdel_mtxでおこないます。資源の返却を行うunl_mtxに対し、資源の獲得待ちをおこなうloc_mtx、待たずにポーリングをおこなう ploc_mtx、タイムアウト付きで待つtloc_mtxがあります。その他に、ミューテックスの状態を参照するref_mtxシステムコールがあります。

NORTi3との差異
μITRON4.0から導入された機能です。

優先度逆転
優先度の低いタスクが資源をロックしているときに、優先度の高いタスクが既にロックされている資源を使おうとして待ち状態になることがあります。この時、中間の優先度を持つタスクがRUNNING状態になると、間接的に優先度の高いタスクの実行を中間の優先度のタスクがプリエンプトしてしまう結果になります。このことを優先度逆転と呼びます。優先度逆転が起こると優先度ベースのスケジューリングを前提に設計されたシステムの動作を保証できません。
ミューテックスでは、優先度逆転を防ぐために優先度継承プロトコルと優先度上限プロトコルをサポートしています。
優先度継承プロトコルは、ロックしているタスクの優先度をロック待ちしているタスクの中で高の優先度を持っているタスクと一時的に同一にします。こうすることで中間の優先度を持ったタスクの介入を排除します。動的に優先度を変更するためシステムの負荷が大きくなります。特にロック中のタスクが別のミューテックスのロック待ちをしていた場合には優先度変更が遷移的に起こるので注意が必要です。
優先度上限プロトコルは、ロックしたタスクの優先度を、待ちタスクの有無とは無関係にあらかじめ決めた優先度に変更するものです。優先度継承ほど負荷は高くありませんが、待ちタスクが無くとも優先度変更が発生します。
一時的に変更された優先度はロック解除によってもとの優先度に戻ります。

4.9 拡張同期・通信機能(メッセージバッファ)

概要
メッセージバッファはタスク間での比較的小さなデータの受け渡しに使用します。メールボックスと異なるのは、メッセージの内容が内部のリングバッファへコピーされて送受信されることです。したがって、メールボックスのように、メッセージパケット領域をメモリプールから獲得する必要はありません。なお、割込み禁止状態でコピーを実行しているので、大きなデータを渡すと割込み禁止時間が延びますので、注意してください。
メッセージバッファの生成と削除はcre_mbf, acre_mbfとdel_mbfでおこないます。メッセージを送信するsnd_mbf、バッファに空きが無い場合待たずに直ちにリターンするpsnd_mbf、バッファに空きが無い場合タイムアウト付きで待つtsnd_mbf、メッセージの受信待ちをおこなう rcv_mbf、メッセージが無い場合に待たずにポーリングをおこなうprcv_mbf、同様にタイムアウト付きで待つtrcv_mbfがあります。その他に、メッセージバッファの状態を参照するref_mbf システムコールがあります。

NORTi3との差異
送信待ちタスクに対しても優先度待ちを指定できるようになりました。
vcer_tskがacre_tskに名称変更されました。

メッセージキュー
メッセージデータは、メッセージバッファ内部のリング状のバッファにコピーされます。メールボックスのように、メッセージパケット領域をメモリプールから獲得する必要はありません。
また、OSが使用するメッセージヘッダ部分も必要ありません。
メッセージサイズは、メッセージバッファ生成時に指定した 大長を超えない限り、任意です。受信側では、 大長のメッセージを受け取れるバッファを用意する必要があります。キューイングされたメッセージの並びは、FIFOのみです。メッセージに優先度を付ける機能はありません。

メッセージ受信待ち行列
複数のタスクが同じメッセージバッファで待つことができます。メッセージバッファ生成時に FIFOを指定した場合は、先に要求した順番で、待ち行列をつくります。メッセージバッファ生成時に優先度順を指定した場合は、タスクの優先度順(同一優先度なら先に要求した順)で、待ち行列をつくります。

メッセージ送信待ち行列
メールボックス機能との違いは、リングバッファに空きがない場合に、送信側のタスクも
WAITING状態となることです。複数の送信待ちタスクがある場合、メッセージバッファ生成時にFIFOを指定した場合は、先に送信要求した順番で、待ち行列を作ります。メッセージバッファ生成時に優先度順を指定した場合は、タスクの優先度順(同一優先度なら先に要求した順) で、待ち行列をつくります。
MessageBuffer

リングバッファ領域
リングバッファへは、メッセージサイズを示す2バイトのヘッダが付加されてメッセージデータがコピーされます。したがって、リングバッファ領域の全てを、データ用として使うことはできません。ひとつのメッセージサイズがmsgszバイトのメッセージをmsgcnt個格納できるリングバッファサイズは、次のTSZ_MBFマクロによって得ることができます。

```c
TSZ_MBF(msgcnt, msgsz)
```

msgszが1の場合、すなわちメッセージの 大長を1バイトとしてメッセージバッファを生成した場合に限って、メッセージサイズを示すヘッダの付加を省略します。この機能により、1 バイトのメッセージ送受信では、リングバッファ領域の全てをデータ用として利用できます。

サイズ0のリングバッファ
リングバッファの総サイズをゼロとして、メッセージバッファを生成することもできます。この場合、送信メッセージは、受信側のタスクが用意したバッファへ直接コピーされます。そのため、受信側のタスクが現れるまで、送信側のタスクは待ち状態になります。この機能により、メッセージバッファでも、ランデブ機能に似た同期通信を実現することができます。

4.10 拡張同期・通信機能(ランデブ用ポート)

概要
ランデブ機能は、タスク間の密接な同期を行うために使用します。相互にデータの受け渡しを行うことも可能です。ランデブ(直訳:会合する)という言葉から分かるように、2つのタスクが互いに待ち合わせをおこないます。応答を待つ本機能に比べると、他の同期・通信機能は、一方的な待ちや通信と言えます。
ポートの生成と削除はcre_por, acre_porとdel_porでおこないます。ランデブ呼び出し
cal_porに対し、ランデブ受け付けacp_porとランデブ返答rpl_rdv があります。受け付けには待たないでポーリングするpacp_por、および、ランデブ呼び出し/ランデブ受け付けには、タイムアウト付きで待つtcal_por/tacp_porもあります。その他に、受け付けたランデブを別のポートへ回送するfwd_por、ポートの状態を参照するref_por、ランデブの状態を参照する ref_rdvシステムコールがあります。

NORTi3との差異
ランデブ呼出待ちにタスク優先度順が追加されました。
ランデブ生成情報から拡張情報が削除されました。
tcal_porのタイムアウト時間はランデブが「成立するまで」ではなく「終了するまで」の時間になりました。これに伴い、pcal_porは廃止されました。
呼出メッセージサイズはacp_por関数の引数から、返値に変更されました。
ランデブ相手がランデブ待ちか調べるref_rdvが追加されました。
ランデブ受付け条件として0を指定するとエラー(E_PAR)になります。
vcre_porがacre_porに名称変更されました。

ランデブの基本的な流れ
task-Aとtask-Xが、下図のようにランデブを行う例で説明します。点線は、WAITING状態であることを示します。

task-Aがランデブ呼び出しcal_porをおこなった時に、まだtask-Xがランデブ受け付け acp_porをおこなっていなければ、task-Aはランデブ呼出待ち状態①となります。
逆に、task-Xがランデブ受け付けacp_porをおこなった時に、まだtask-Aがランデブ呼び出しcal_porをおこなっていなければ、task-Xはランデブ受付待ち状態②となります。
呼び出しと受け付けが揃うと、task-Aはランデブ終了待ち状態③となります。task-Xは実行を続け、ランデブ返答rpl_rdvをおこなった時点で、task-Aの待ちが解除④され、ランデブ終了となります。

ランデブ回送
受け付けたランデブを、fwd_porによって別のポートへ回送することができます。
下図は、task-Xが別ポート回送したランデブを、task-Pが受け付けて返答をおこなう例です。

ランデブ成立条件
イベントフラグの様なビットパターンで、呼出側選択条件と受付側選択条件を指定することができます。呼出側選択条件のビットパターンと受付側選択条件のビットパターンとの論理積
(AND)が非ゼロの場合に、ランデブ成立となります。

メッセージ
呼出メッセージは、ランデブ成立時に、呼出側タスクから受付側タスクへ渡されます。返答メッセージは、ランデブ終了時に、受付側（返答側）タスクから呼出側タスクへ渡されます。
メッセージは、それぞれのタスクが用意したバッファ間でコピーされます。メッセージバッファ機能と似ていますが、ランデブという同期方法の性質上、メッセージキューは存在しません。なお、割込み禁止状態でコピーを実行しているので、大きなデータを渡すと割込み禁止時間が延びますので、注意してください。

ランデブ受付待ち行列
複数のタスクが同じポートで受け付けを待つことができます。呼出側のタスクがない場合や、ランデブが成立しない場合、先に受け付けを発行した順番で、待ち行列をつくります。タスク優先度順にすることはできません。

ランデブ呼出待ち行列
複数のタスクが同じポートで呼び出しを待つことができます。受付側のタスクがない場合や、ランデブが成立しない場合、先に呼び出しを発行した順番あるいはタスク優先度順で、待ち行列をつくります。
Port ランデブ呼出待ちタスクの行列

4.11 割込み管理機能

概要
割込み管理機能に分類されるのは、chg_ims, get_ims, ent_int, ret_int, cre_isr, acre_isr, del_isr, dis_intシステムコールです。def_inh,ena_intは機種依存(ユーザカスタマイズ)システムコールです。

NORTi3との差異
loc_cpu, unl_cpuはシステム状態管理機能に分類されました。
def_intはdef_inhに名称変更されました。 ref_imsはget_imsに名称変更されました。
ret_wupは廃止されました。
cre_isr, acre_isr, del_isr, ref_isrは新設のシステムコールです。

割込みハンドラおよび割込みサービスルーチンの定義
割込みハンドラを定義するdef_inh、割込みサービスルーチンに関連したcre_isr,acre\_\_isr, del_isrシステムコールでは、割込みベクタの設定をおこないます。しかし、割込みの設定方
法はシステムにより異なりますので、カーネルにはこれらのシステムコールを含めていません。
付属のn4ixxx.cに定義されているこれらのシステムコールが適合しない場合は、ユーザー側で、独自の機能を設計してください。

特定の割込みの禁止／許可
μITRON仕様にある、特定の割込みを禁止／許可するdis_int, ena_intシステムコールは、完全に機種依存しますので、NORTiでは、ほとんどのプロセッサに対してサポートしていません。 (汎用的なdis_int, ena_intが作成可能なプロセッサでは、サンプルに含まれている場合があります。)

割込みハンドラの起動
割込みハンドラより先に、カーネルが割込みをフックすることはしていません。直接、ユーザの記述した割込みハンドラへ飛んできます。
そしてNORTiでは、割込みハンドラを全てCで記述できるようにするため、独自の仕様として、割込みハンドラの先頭で呼ばれるent_intシステムコールを設けています。ent_intでは、レジスタの退避を行うと共に、スタックポインタを割込みハンドラ専用のスタック領域に切り替えています。

割込みサービスルーチンの起動
割込みサービスルーチンを登録した割込みが発生するとまずカーネル内の割込みハンドラに
コントロールが移りそこからユーザの記述した割込みサービスルーチンを呼び出しています。

RISCプロセッサの割込み
ARM, MIPS, PowerPC, SH-3/4等のRISC系プロセッサでは、全ての外部割込みが一ヶ所のエントリを共有しています。この場合、def_inhシステムコールでは、割込みベクタテーブルの代わりに、n4ixxx.cに定義してある配列へ、割込みハンドラのアドレスを設定するようにしてい
ます。そして、割込み要因を判別し、この配列を参照してジャンプするプログラムが、
vecxxx.asmにサンプルとして記述されています。したがって、RISC系のプロセッサでも、割込みベクタテーブルがあるかのごとく、プログラミングすることが可能です。システムコールを発行しない、カーネルの割込み禁止レベルより高優先度の割込みルーチンはent_int, ret_intが不要であることはCISCプロセッサと同様です。

カーネルより高優先の割込みルーチン
カーネルの割込み禁止レベルより高いレベルの割込みルーチンを使うことができます。この割込みルーチンにとって、カーネル内部の割込み禁止区間は割込み許可と同じことになり、非常に高速な割込み応答が要求されるシステムでもNORTiを応用することができるようになります。
ただし、カーネルより高優先の割込みルーチンでは、システムコールを発行できません。割込みの入り口と出口のレジスタ待避・復元も、ent_int()とret_int()ではなく、コンパイラが interrupt関数として提供する機能か、あるいは、独自にアセンブラで行ってください。
カーネルより高優先の割込みルーチンでは、タスクとの同期や通信を行うことができません。
一連の割込みの区切りでタスクと同期・通信すれば良い場合、高優先の割込みルーチンからカーネルのレベル以下の割込みハンドラを起動して、そこでシステムコールを発行するテクニックを使ってください。

4.12 メモリプール管理機能

概要
NORTiのメモリ管理機能は、可変長のメモリブロック、および、固定長のメモリブロックを扱う2種類の機能を提供します。タスクは、メモリが必要になるとメモリプールからメモリブロックを獲得し、そのメモリが不要になると同じメモリプールへメモリブロックを返却するようにプログラムしてください。タスク間で共有されるメモリ領域は、メモリプールと呼ばれる単位で管理され、1つのメモリプールは、複数のメモリブロックから構成されます。
メモリプールの機能は、C の標準ライブラリのmalloc/free関数と似ています。malloc/free 関数との違いは、メモリを解放した時に他タスクのメモリ獲得待ちを解除することやリエントラントであることなどの、マルチタスクに適した機能が備わっていることです。
可変長メモリプールの生成と削除はcre_mpl, acre_mplとdel_mplでおこないます。メモリブロックを返却するrel_mplに対し、メモリブロックの獲得待ちをおこなうget_mpl、待たずにポーリングをおこなうpget_mpl、タイムアウト付きで待つtget_mplがあります。その他に、可変長メモリプールの状態を参照するref_mplシステムコールがあります。
固定長メモリプールの生成と削除はcre_mpf, acre_mpfとdel_mpfでおこないます。メモリブロックを返却するrel_mpfに対し、メモリブロックの獲得待ちをおこなうget_mpf、待たずにポーリングをおこなうpget_mpf、タイムアウト付きで待つtget_mpfがあります。その他に、固定長メモリプールの状態を参照するref_mpfシステムコールがあります。

NORTi3との差異
rel_blk, get_blk, pget_blk, tget_blkはそれぞれXXX_mplに名称変更されました。 rel_blf, get_blf, pget_blf, tget_blfはそれぞれXXX_mpfに名称変更されました。
vcre_mpl, vcre_mpfはそれぞれacre_XXXに名称変更されました。
可変長/固定長のメモリプール生成情報から拡張情報が削除されました。
ref_mpl, ref_mpfで参照できる情報から、拡張情報が削除されました。

メモリブロック待ち行列
複数のタスクが同じメモリプールで待つことができます。メモリプール生成時にFIFOを指定した場合は、先に要求した順番で、待ち行列をつくります。メモリプール生成時に優先度順を指定した場合は、タスクの優先度順(同一優先度なら先に要求した順)で、待ち行列をつくります。

MemoryPool

獲得
この図には両方が描かれていますが、固定長メモリプールでは、メモリブロック待ちタスクとメモリブロックが同時に存在することはありません。

メッセージ送受信との組み合わせ
一般的に、メールボックス機能のメッセージパケット領域にはメモリプールのメモリブロックを利用します。メッセージ送信側でメモリブロックを獲得し、メッセージ受信側でそのメモリブロックを返却するようにプログラムしてください。

可変長と固定長
可変長メモリプールの方が固定長メモリプールより便利ですが、動的なメモリ管理を伴うため、可変長メモリプールは重たい部類のシステムコールです。固定長で済む用途には、固定長メモリプールの方を使うことを推奨します。
可変長メモリプールでは、1つのメモリブロックを獲得する際に、そのサイズを記憶するためにsizeof (int \*)サイズのメモリを余分に消費します。それに対し、固定長メモリブロックでは、無駄なメモリ消費がありません。

複数のメモリプール
用途別に複数のメモリプールを設けることを推奨します。1つだけのメモリプールを様々なタスクから使うと、メモリプールを使い切った時にデッドロックの恐れがあります。すなわち、
1個所の遅れがシステム全体に波及して処理が破綻する場合があり得ます。
例えば、タスクAとタスクBとタスクCが、メモリプールを組み合わせたメッセージ送受信により協調して動作する場合で説明します。処理の流れとしては、タスクAが指令メッセージをタスクBへ送り、それを受けたタスクBがさらに指令メッセージをタスクCへ送り、それを受けたタスクCが、返答メッセージをタスクBに送り返す場合を考えます。もし、タスクCの処理が遅いと、タスクAからBへのメッセージが次々とキューイングされ、やがてメモリブロックを使い果たします。すると処理の終わったタスクCは返答メッセージを返すためのメモリブロックが獲得できなくなり、この返答を待つタスクBも永久に止ってしまいます。
一方、用途別にメモリプールを分ければ、メモリプールが空になるのを積極的に利用して、処理のキューイング数を制御することができます。

4.13 時間管理機能

概要
時間管理機能に分類されるのは、set_tim, get_tim, cre_cyc, acre_cyc, del_cyc, sta_cyc, stp_cyc, ref_cyc, cre_alm, acre_alm, del_alm, sta_alm, stp_alm, ref_alm, def_ovr, sta_ovr, stp_ovr, ref_ovr, isig_tim システムコールです。

NORTi3との差異
システムが使用するシステムクロックとは別にユーザ用にシステム時刻が導入されました。
set_tim, get_timはシステム時刻を設定・参照するように仕様変更されました。
タスク実行時間を監視するオーバーランハンドラが導入されました。
周期ハンドラに起動位相を扱う機能が追加されました。
周期ハンドラ生成情報からcycactが削除されました。生成時の動作状態は停止状態です。
絶対時刻でアラームハンドラを起動する機能は廃止されました。
アラームハンドラの解除は自動的におこなわれません。
act_cycがsta_cycとstp_cycに分割されました。 def_cycがcre_cycとdel_cycに分割されました。
acre_cycが新設されました。
def_almがcre_almに変更されました。
del_almが新設されました。
sta_alm, stp_almが新設されました。
ret_tmrが廃止されました。

システム時刻とシステムクロック
システムクロックは、システム起動時に0クリアされ以後周期割込みごとにカウントアップされます。
システム時刻は set_timにより任意の値に初期化され以後周期割込みごとにカウントアップ
されます。このシステム時刻値は、get_timシステムコールで読み出すことができます。set_tim するまでシステム時刻は不定です。
タイムイベントハンドラはシステムクロックをベースに起動されます。したがってシステム時刻を変更してもすでに設定してある動作に影響はありません。
システムコール内部での乗除算のオーバヘッドを避けるため、時間の単位はタイマ割込み周期を使用しています。

周期ハンドラ
指定した時間間隔で起動実行されるタイムイベントハンドラです。時間的な正確さが要求されるデータのサンプリングや、rot_rdq発行によるラウンドロビンケジューリング等に応用できます。
周期ハンドラは、cre_cyc, acre_cycシステムコールにより登録し、del_cycにより取り消しをおこないます。その他、ハンドラの活性制御をおこなうsta_cyc, stp_cyc、活性状態や次の起動までの時間を調べるref_cycシステムコールがあります。

アラームハンドラ
指定した時間後に1度だけ起動実行されるタイムイベントハンドラです。
アラームハンドラは、cre_alm, acre_almシステムコールにより登録し、del_almにより取り消しをおこないます。登録直後は起動時刻が設定されておらずsta_almにより設定をおこないます。設定を解除はstp_almによりおこないます。アラームハンドラが起動されると自動的に
設定が解除されますが、登録の取り消しはおこないません。他、起動までの時間を調べる ref_almシステムコールがあります。

オーバーランハンドラ
タスク毎に設定された実行時間を監視し、設定された時間を使い切った場合に起動されるタイムイベントハンドラです。実行時間の監視はシステムクロックを用いておこなっています。したがって監視対象タスクの連続実行時間がシステムクロックインタバル以下の場合実行時間を充分な精度で監視することができません。実行条件等により無限ループに陥る可能性のあるタスクの監視に使用してください。
オーバーランハンドラはシステムにひとつだけdef_ovrによって登録および解除することができます。sta_ovrによって監視するタスクとそのタスクの持ち時間を設定します。複数のタスクに対して設定することが可能です。監視を解除する場合はstp_ovrを使用します。ref_ovr によってオーバーランハンドラの動作状態と指定したタスクの残り時間を参照することができます。

4.14 拡張サービスコール管理機能

概要
サービスコール管理機能によって拡張サービスコールの定義と呼出をおこなうことができます。拡張サービスコールは、ダイナミックにロードしたモジュールやファームウェアに置かれたモジュールなどのシステム全体をひとつにリンクしない場合のモジュールを呼び出すための機能です。
def_svcで拡張サービスコールの登録／解除をおこない、cal_svcにより登録したルーチンを呼び出します。

NORTi3との差異
μITRON4.0から導入された機能です。

拡張サービスコールルーチンの記述

```c
ER_UINT svcrtn(VP_INT par1, VP_INT par2, ..., VP_INT par6) {
}
```

C言語により上記の様な形式でサービスコールルーチンを記述してください。パラメータ数は
0～6個まで指定できます。

4.15 システム状態管理機能

概要
システム状態管理機能はシステムの状態参照／変更をするための機能で、レディーキューを回転するためのrot_rdq、自タスクのタスクIDを得るためのget_tid, vget_tid、CPUをロック／アンロックするためのloc_cpu, unl_cpu、ディスパッチを禁止／許可するためのdis_dsp, ena_dsp、システム状態を参照するためのsns_loc, sns_ctx, sns_dsp, sns_dpn, ref_sysが含まれます。

NORTi3との差異
新設の機能分類です。
get_tidを非タスクコンテキスト部から呼んだ場合FALSEではなくRUNNING状態のタスクIDが返ります。
CPUロック状態とディスパッチ禁止状態は独立に操作できるようになりました。

タスクの実行順制御
ディスパッチ禁止dis_dspと許可ena_dspにより、複数のシステムコールを発行した後でまとめてタスク切り替えをおこなうことができます。レディキューを回転するrot_rdqにより、同一優先度のタスクに実行権を渡したり、ラウンドロビンのような実行順制御が可能になります。
CPUをロックすることで一時的に割込みを禁止することもできます。

4.16 システム構成管理機能
システム管理機能に分類されるシステムコールは、OSのバージョンを得るref_ver、コンフィグレーション情報を参照するref_cfgです。

NORTi3との差異
get_verは、ref_verに名称変更されました。

未サポート機能
NORTiでは、CPU例外ハンドラ定義def_excは未サポートです。

※ 次ページ以降のエラーの分類表記について
次章のシステムコール解説で、戻値に記載されている\*と\*\*マークは、次の様なエラーの分類を示します。\*パラメータチェック無しライブラリでは検出しない静的なエラー。
標準のライブラリではチェックされSYSER変数に記録される。
\*\*いずれのライブラリでも検出され、SYSER変数に記録される。
マーク無しのエラーは、いずれのライブラリでも検出されますが、SYSERエラー変数へは記録されません。
第5章 システムコール解説

5.1 タスク管理機能

### cre_tsk

機能 タスク生成

形式 ER cre_tsk(ID tskid, const T_CTSK \*pk_ctsk);

tskid タスクID
pk_ctsk タスク生成情報パケットへのポインタ

解説 tskidで指定されたタスクを生成します。すなわち、システムメモリから、タスク管理ブロッ
ク(TCB)を動的に割り当てます。タスク生成情報パケットのスタック領域先頭番地(stk)が NULLの場合にスタック用メモリから、スタック領域を動的に確保します。生成した結果、対象タスクはNON-EXISTENT状態からDORMANT状態へ遷移します。
タスク生成情報パケットの構造は次の通りです。

```c
typedef struct t_ctsk {
    ATR tskatr;   /* タスク属性 */
    VP_INT exinf; /* 拡張情報 */
    FP task;      /* タスクとする関数へのポインタ */
    PRI itskpri;  /* タスク起動時優先度 */
    SIZE stksz;   /* スタックサイズ(バイト数) */
    VP stk;       /* スタック領域先頭番地 */
    B* name;      /* タスク名へのポインタ（省略可） */
} T_CTSK;
```

exinf の値は act_tsk によるタスク起動時にタスクパラメータとしてタスクに渡されるほか、オーバーランハンドラにも渡されます。exinfはref_tskで参照できます。
tskatrには、タスクが高級言語で記述されていることを示すTA_HLNGを入れてください。また、タスク生成後DORMANT状態からREADY状態とする場合はTA_ACTを入れてください。
nameには、タスク名文字列を入れてください。対応デバッガ用でOSが使用することはありません。名前を指定しない場合には\"\"かNULLを入れてください。T_CTSK構造体を初期値付きで定義する場合には、nameを省略しても構いません。
スタック領域をユーザプログラム内に確保した場合は、その先頭番地を stk に、サイズを stkszにそれぞれ設定してください。

戻値 E_OK 正常終了
E_PAR 優先度が範囲外~\*~

E_ID タスクIDが範囲外~\*~

E_OBJ タスクが既に生成されている

E_CTX 割込みハンドラから発行~\*~

E_SYS 管理ブロック用のメモリが確保できない~\*\*~
E_NOMEM スタック用のメモリが確保できない~\*\*~

注意 タスク生成情報パケットは、タスク管理ブロックへコピーされないので、本システムコール発行後も保持する必要があります。const変数として定義しROMに配置してください。 ROM以外に配置された場合には、実行中に変更または廃棄された場合の動作異常を防ぐために、システムメモリにタスク生成情報パケットのコピーを作成します。

例

```c
#define ID_task2 2
const T_CTSK ctsk2 = {TA_HLNG, NULL, task2, 8, 512, NULL};
TASK task1(void) {
    ER ercd;

    :

        ercd = cre_tsk(ID_task2, &ctsk2);

    :
}
```

### acre_tsk

機能 タスク生成(ID自動割り当て)

形式 ER_ID acre_tsk(const T_CTSK \*pk_ctsk);
pk_ctsk タスク生成情報パケットへのポインタ
解説 未生成タスクのIDを、大きな方から検索して割り当てます。タスクIDが割り当てられない場合は、E_NOIDエラーを返します。それ以外は、cre_tskと同じです。

戻値 正の値 割り当てられたタスクID
E_PAR 優先度が範囲外\* E_NOID タスクIDが不足

E_CTX 割込みハンドラから発行\*

E_SYS 管理ブロック用のメモリが確保できない\*\*
E_NOMEM スタック用のメモリが確保できない\*\*

例

```c
ID ID_task2;
const T_CTSK ctsk2 = {TA_HLNG, NULL, task2, 8, 512, NULL};
TASK task1(void) {
    ER_ID ercd;

    :
        ercd = acre_tsk(&ctsk2);
    if (ercd > 0) ID_task2 = ercd;

    :
}
```

### del_tsk

機能 タスク削除
形式 ER del_tsk(ID tskid); tskid タスクID
解説 tskidで指定されたタスクを削除します。すなわち、このタスクのスタック領域をスタック用メモリへ解放し、タスク管理ブロック(TCB)をシステムメモリへ解放します。削除した結果、対象タスクはDORMANT状態からNON-EXISTENT状態へ遷移します。このシステムコールでは、自タスクは指定できません、exd_tskを使用してください。

戻値
E_OK 正常終了
E_ID タスクIDが範囲外\*

E_OBJ 自タスク指定(tskid = TSK_SELF)\*

E_CTX 割込みハンドラから発行\*
E_NOEXS タスクが生成されていない

E_OBJ タスクがDORMANT状態でない
注意 対象タスクが獲得していたミューテックス以外の資源(セマフォやメモリブロック)は自動的に解放されません。ユーザーの責任において、タスク削除の前に資源を解放してください。

例

```c
#define ID_task2 2
TASK task1(void) {
    :

        del_tsk(ID_task2);

    :
}
```

### act_tsk, iact_tsk

機能 タスク起動
形式 ER act_tsk(ID tskid); ER iact_tsk(ID tskid);

tskid タスクID
解説 tskidで指定されたタスクを起動します。iact_tskはμITRON仕様と互換性を取るためのマクロによるact_tskの再定義です。対象タスクはDORMANT状態からREADY状態へ遷移します(現在のRUNNINGタスクより高優先ならRUNNING状態へ遷移)。対象タスクがDORMANT状態でない場合、このシステムコールにより起動要求のキューイングがおこなわれます。タ
スク起動時にタスク生成情報に含まれる拡張情報が渡されます。
tskidにTSK_SELFを指定すると自タスクに対する起動要求になりキューイングされます。

戻値
E_OK 正常終了
E_ID タスクIDが範囲外\*
E_NOEXS タスクが生成されていない

E_QOVR キューイングオーバーフロー

例

```c
#define ID_task2 2
#define ID_task3 3
const T_CTSK ctsk2 = {TA_HLNG, 1, task2, 8, 512, NULL};
const T_CTSK ctsk3 = {TA_HLNG, NULL, task3, 8, 512, NULL};
TASK task2(int exinf) {
    if (exinf == 1)

        :
}

TASK task3(void) /* exinfを使用しない場合 \*/ {
    :
}

TASK task1(void) {
    :
        cre_tsk(ID_task2, &ctsk2);
    cre_tsk(ID_task3, &ctsk3);

    :
        act_tsk(ID_task2);
    act_tsk(ID_task3);

    :
}
```

### can_act

機能 タスク起動要求のキャンセル

形式 ER_UINT can_act(ID tskid);

tskid タスクID
解説 tskidで指定されたタスクに対する起動要求をキャンセルし0にします。キャンセルする前の起動要求キューイング数(actcnt)を、関数の戻値として返します。
tskid = TSK_SELFで自タスクを指定できます。

戻値 正または0 キューイングされていた起動要求数

E_ID タスクIDが範囲外\*
E_NOEXS タスクが生成されていない

例

```c
#define ID_task2 2
const T_CTSK ctsk2 = {TA_HLNG, 1, task2, 8, 512, NULL};
TASK task2(int exinf) {
    :
}
TASK task1(void) {
    cre_tsk(ID_task2, &ctsk2);

    :

        act_tsk(ID_task2);

    :

        can_act(ID_task2);

    :
}
```

### sta_tsk

機能 タスク起動

形式 ER sta_tsk(ID tskid, VP_INT stacd);
tskid タスクID stacd タスク起動コード

解説 tskidで指定されたタスクを起動し、stacdを渡します(stacdを使用しない場合は0を推
奨)。対象タスクは DORMANT状態から READY状態へ遷移します(現在のRUNNINGタスクより高優先ならRUNNING状態へ遷移)。
このシステムコールによる起動要求のキューイングはおこなわれません。したがって、対象タスクがDORMANT状態でない場合は、エラーとなります。

戻値
E_OK 正常終了
E_ID タスクIDが範囲外\*

E_OBJ 自タスク指定(tskid = TSK_SELF)\*
E_NOEXS タスクが生成されていない

E_OBJ タスクが既に起動されている

例

```c
#define ID_task2 2
#define ID_task3 3
TASK task2(int stacd) {
    if (stacd == 1)

        :
}

TASK task3(void) /* stacdを使用しない場合 \*/ {
    :
}
TASK task1(void) {
    :
        sta_tsk(ID_task2, 1);
    sta_tsk(ID_task3, 0);

    :
}
```

### ext_tsk

機能 自タスク終了

形式 void ext_tsk(void);
解説 タスク自ら終了します。タスクは起動要求がキューイングされてなければRUNNING状態からDORMANT状態へ遷移します。起動要求がキューイングされていた場合は、キューイング数から1を減じて再起動します。再起動時にはタスクの内部状態は初期化されます。すなわち、タスクがミューテックスをロックしていた場合はアンロックし、オーバーランハンドラへの登録が解除され、タスク例外処理が禁止され、優先度・起床要求数・強制待ち要求数・保留例外要因・スタックが初期状態になります。
再起動された場合、初期優先度レディーキューの 後につながります。

戻値 なし(呼び出し元に戻りません)

補足 内部的には次のエラーを検出しています。

E_CTX 非タスクコンテキストまたは、ディスパッチ禁止状態で実行\*
注意 タスクが獲得していたミューテックス以外の資源(セマフォやメモリブロック)は自動的に解放されません。ユーザーの責任において、タスク終了前に資源を解放してください。

例

```c
TASK task2(void) {
    :

        ext_tsk();
}
```

このように明示的に呼び出さなくともメインルーチンからのリターンで自動的に呼び出されます。

### exd_tsk

機能 自タスクの終了と削除

形式 void exd_tsk(void);

解説 タスク自ら終了し、削除されます。すなわち、タスクのスタック領域をスタック用メモリ
へ解放し、タスク管理ブロック(TCB)をシステムメモリへ解放します。削除された結果、タスクはRUNNING状態から、直接NON-EXISTENT状態へ遷移します。キューイングされていた起動要求はキャンセルされます。

戻値 なし(呼び出し元に戻りません)

補足 内部的には次のエラーを検出しています。

E_CTX 非タスクコンテキストで、または、ディスパッチ禁止状態で実行\*
注意 タスクが獲得していたミューテックス以外の資源(セマフォやメモリブロック)は自動的に解放されません。ユーザーの責任において、タスク終了前に資源を解放してください。

例

```c
TASK task2(void) {
    :

        exd_tsk();
}
```

### ter_tsk

機能 他タスク強制終了
形式 ER ter_tsk(ID tskid); tskid タスクID

解説 tskidで指定されたタスクを終了させます。終了させた結果、対象タスクはREADYまたは
WAITINGまたはWAITING-SUSPEND状態からDORMANT状態へ遷移します。起動要求がキューイングされている場合は再起動されます。対象タスクが何等かの待ち行列につながれていた場合には、ter_tskの実行によって、対象タスクはその待ち行列から外されます。このシステムコールでは、自タスクは指定できません。

戻値
E_OK 正常終了
E_ID タスクIDが範囲外\*
E_ILUSE 自タスク指定(tskid = TSK_SELF)\*
E_NOEXS タスクが生成されていない

E_OBJ タスクが起動されていない
注意 タスクが獲得していたミューテックス以外の資源（セマフォやメモリブロック）は自動的に解放されません。ユーザーの責任において、タスク終了前に資源を解放してください。

例

```c
#define ID_task2 2
TASK task1(void) {
    :

        ter_tsk(ID_task2);

    :
}
```

### chg_pri

機能 タスクベース優先度変更
形式 ER chg_pri(ID tskid, PRI tskpri); tskid タスクID tskpri 優先度

解説 tskid で指定されたタスクのベース優先度を tskpriの値とします。タスクの優先度は、数
の小さい方が高優先です。優先度には初期優先度とベース優先度、現在優先度があります。初期優先度はタスク生成情報に指定(itskpri)した優先度で、タスク起動時にベース優先度にコピーされます。タスクは通常ベース優先度で走行しますが、ミューテックスをロックした場合に一時的に優先度が変更される場合があります。一時的に変更された優先度が現在優先度です。ミューテックスをアンロックした時点でタスク優先度はベース優先度に戻ります。chg_priはこのベース優先度を変更します。
tskid = TSK_SELFで自タスクを指定できます。tskpri = TPRI_INIで初期優先度、TMIN_TPRI で 高優先度、TMAX_TPRIで 低優先度とすることができます。
対象タスクが優先度順の待ち行列(レディーキューあるいはセマフォやメモリプール等の優先度順待ち行列)につながれていた場合、優先度の変更により、待ち行列のつなぎ替えが起こります。現在優先度が変更された場合にも待ち行列のつなぎ替えが起こります。ミューテックスを使用した場合には遷移的(芋づる式)に待ち行列のつなぎ替えが起こるため注意が必要です。
READY状態である対象タスクの優先度を、このシステムコールを発行したタスクより高くした場合、このシステムコールを発行したタスクはRUNNING状態からREADY状態へ遷移し、対象タスクはRUNNING状態へ遷移します。
自タスクの優先度を他のREADYタスクより低くした場合、自タスクはRUNNING状態から
READY状態へ遷移し、他のREADYタスクの中で も優先度の高いタスクがRUNNING状態へ遷移します。
現在と同じ優先度を指定した場合、他に同じ優先度のタスクがあると、対象タスクはその優先度の待ち行列の 後に回ります。
このシステムコールで変更した優先度は、タスクが終了するまで有効です。次にタスクが起動した時には、初期優先度に戻ります。

戻値
E_OK 正常終了
E_PAR 優先度が範囲外\* E_ID タスクID が範囲外\* 非タスクコンテキストでTSK_SELFを指定 \*
E_NOEXS タスクが生成されていない

E_OBJ タスクが起動されていない

例

```c
TASK task1(void) {
    :

        chg_pri(TSK_SELF, TMIN_TPRI); /* 一時的に 高優先度へ \*/

    :

        chg_pri(TSK_SELF, TPRI_INI); /* 優先度を戻す \*/

    :
}
```

### get_pri

機能 タスク現在優先度参照

形式 ER get_pri(ID tskid, PRI \*tskpri);

tskid タスクID

tskpri 対象タスクの現在優先度を返すアドレス
解説 tskidで指定されたタスクの現在優先度をtskpriに返します。tskid = TSK_SELFで自タスクを指定できます。

戻値
E_OK 正常終了
E_ID タスクID が範囲外\*
E_NOEXS タスクが生成されていない

E_OBJ タスクが起動されていない

例

```c
TASK task1(void) {
    PRI tskpri;

    :

        get_pri(TSK_SELF, &tskpri);

    :
}
```

### ref_tsk

機能 タスク状態参照

形式 ER ref_tsk(ID tskid, T_RTSK \*pk_rtsk);

tskid タスクID
pk_rtsk タスク状態パケットを格納する場所へのポインタ

解説 tskid で指定されたタスクの状態を、\*pk_rtskに返します。
tskid = TSK_SELFで自タスクを指定できます。
タスク状態パケットの構造は次の通りです。

```c
typedef struct t_rtsk {
    STAT tskstat;  /* タスク状態                  */
    PRI tskpri;    /* > 現在優先度                */
    PRI tskbpri;   /* > ベース優先度              */
    STAT tskwait;  /* > 待ち要因                  */
    ID wid;        /* > 待ちオブジェクトID        */
    TMO lefttmo;   /* > タイムアウトまでの時間    */
    UINT actcnt;   /* > 起動要求カウント          */
    UINT wupcnt;   /* > 起床要求カウント          */
    UINT suscnt;   /* > 強制待ち要求カウント      */
    VP exinf;      /* > 拡張情報                  */
    ATR tskatr;    /* > タスク属性                */
    FP task;       /* > タスク起動アドレス        */
    PRI itskpri;   /* > タスク起動時優先度        */
    int stksz;     /* > スタックサイズ(バイト数)  */
                   /*                             */
} T_RTSK;          /*                             */
```

exinf, tskatr, task, itskpri, stkszには、タスク生成で指定された値がそのまま返ります。 tskstatには、タスク状態を示す次の値が返ります。
TTS_RUN 0x0001 RUNNING状態
TTS_RDY 0x0002 READY状態
TTS_WAI 0x0004 WAITING状態
TTS_SUS 0x0008 SUSPENDED状態
TTS_WAS 0x000c WAITING-SUSPENDED状態
TTS_DMT 0x0010 DORMANT状態 tskwaitには、タスクが待ち状態の場合に、その要因を示す次の値が返ります。
TTW_SLP 0x0001 slp_tskまたはtslp_tskによる待ち
TTW_DLY 0x0002 dly_tskによる待ち
TTW_SEM 0x0004 wai_semまたはtwai_semによる待ち
TTW_FLG 0x0008 wai_semまたはtwai_semによる待ち
TTW_SDTQ 0x0010 snd_dtqによる待ち
TTW_RDTQ 0x0020 rcv_dtqによる待ち
TTW_MBX 0x0040 rcv_msgまたはtrcv_msgによる待ち TTW_MTX 0x0080 loc_mtxによる待ち
TTW_SMBF 0x0100 snd_mbfまたはtsnd_mbfによる待ち
TTW_RMBF 0x0200 rcv_mbfまたはtrcv_mbfによる待ち
TTW_CAL 0x0400 ランデブ呼出待ち
TTW_ACP 0x0800 ランデブ受付待ち
TTW_RDV 0x1000 ランデブ終了待ち
TTW_MPF 0x2000 固定長メモリブロックの獲得待ち
TTW_MPL 0x4000 可変長メモリブロックの獲得待ち

戻値
E_OK 正常終了
E_ID タスクIDが範囲外
E_NOEXS タスクが生成されていない

例

```c
#define ID_task2 2
TASK task1(void) {
    T_RTSK rtsk;

    :
        ref_tsk(ID_task2, &rtsk);
    if (rtsk.tskstat == TTS_WAI)

        :
}
```

### ref_tst

機能 タスク状態参照
形式 ER ref_tst(ID tskid, T_RTST \*pk_rtst); tskid タスクID
pk_rtst タスク状態パケットを格納する場所へのポインタ

解説 tskidで指定されたタスクの状態を、\*pk_rtstに返します。
tskid = TSK_SELFで自タスクを指定できます。
タスク状態パケットの構造は次の通りです。

```c
typedef struct t_rtst

{
    STAT tskstat; /* タスク状態 */
    STAT tskwait; /* 待ち要因 */
} T_RTST;
```

tskstat, tskwaitにはref_tskと同様の内容が返ります。

戻値
E_OK 正常終了
E_ID タスクID が範囲外
E_NOEXS タスクが生成されていない

例

```c
#define ID_task2 2
TASK task1(void) {
    T_RTSK rtst;

    :
        ref_tst(ID_task2, &rtst);
    if (rtst.tskstat == TTS_WAI)

        :
}
```

5.2 タスク付属同期機能

### sus_tsk

機能 タスクを強制待ち状態へ移行

形式 ER sus_tsk(ID tskid);

tskid タスクID

解説 tskidで指定されたタスクの実行を抑制します。すなわち、対象タスクがREADY状態ならば、
SUSPENDED状態へ遷移させます。対象タスクがWAITING状態ならば、WAITING-SUSPENDED状態へ遷移させます。tskid = TSK_SELFで自タスクを指定できます。
この強制待ち状態は、rsm_tsk, frsm_tskシステムコールにより解除されます。強制待ち要求はネストさせることができます。すなわち、sus_tskの発行回数と同一回数のrsm_tsk の発行で、はじめてSUSPENDED状態が解除されます。

戻値
E_OK 正常終了
E_ID タスクIDが範囲外\*

E_CTX ディスパッチ禁止状態で自タスクを指定(tskid = TSK_SELF)\*
E_NOEXS タスクが生成されていない E_OBJ タスクが起動されていない

E_QOVR 強制待ち要求数のオーバーフロー(TMAX_SUSCNT = 255を超える)

例

```c
#define ID_task2 2
TASK task1(void) {
    :

        sus_tsk(ID_task2);

    :
}
```

### rsm_tsk

機能 強制待ち状態のタスクを再開

形式 ER rsm_tsk(ID tskid);

tskid タスクID
解説 tskidで指定されたタスクの実行抑制を解除します。すなわち、対象タスクがSUSPENDED 状態だった場合、対象タスクはREADY状態へ遷移します。(現在のRUNNINGタスクより高優先ならRUNNING状態へ遷移)。対象タスクがWAITING-SUSPENDED状態だった場合、対象タスクはWAITING状態へ遷移します。
rsm_tskでは、sus_tsk 1回分の強制待ち要求を解除します。つまり、対象タスクに2回以上のsus_tskが発行されていた場合は、rsm_tskを1回実行した後も、対象タスクは強制待ち状態のままです。
本システムコールでは、自タスクを指定することはできません。

戻値
E_OK 正常終了
E_ID タスクIDが範囲外\*

E_OBJ 自タスク指定(tskid = TSK_SELF)\*
E_NOEXS タスクが生成されていない

E_OBJ タスクがSUSPENDED状態でない

例

```c
#define ID_task2 2
TASK task1(void) {
    :

        sus_tsk(ID_task2);

    :

        rsm_tsk(ID_task2);

    :
}
```

### frsm_tsk

機能 強制待ち状態のタスクを強制再開

形式 ER frsm_tsk(ID tskid);

tskid タスクID
解説 tskidで指定されたタスクの実行抑制を解除します。すなわち、対象タスクがSUSPENDED 状態だった場合、対象タスクはREADY状態へ遷移します。(現在のRUNNINGタスクより高優先ならRUNNING状態へ遷移)。対象タスクがWAITING-SUSPENDED状態だった場合、対象タスクはWAITING状態へ遷移します。
frsm_tskは、強制待ち要求を全て解除します。つまり、対象タスクに2回以上のsus_tsk が発行されていた場合でも、frsm_tskの1回の実行で強制待ち状態を解除できます。

戻値
E_OK 正常終了
E_ID タスクIDが範囲外\*

E_OBJ 自タスク指定(tskid = TSK_SELF)\*
E_NOEXS タスクが生成されていない

E_OBJ タスクがSUSPENDED状態でない

例

```c
#define ID_task2 2
TASK task1(void) {
    :
        sus_tsk(ID_task2);
    sus_tsk(ID_task2);

    :

        frsm_tsk(ID_task2);

    :
}
```

### slp_tsk

機能 自タスクを起床待ち状態へ移行

形式 ER slp_tsk(void);
解説 タスク自らWAITING状態へ遷移します。この待ち状態は、本タスクを対象としたwup_tsk システムコールの発行、または、rel_waiシステムコールの発行により解除されます。
wup_tskによる待ち解除では、正常終了E_OKとしてリターンします。wup_tskが先に発行されていて、起床要求がキューイングされている場合は、slp_tskで待ち状態に入らずに、起床要求カウントを1つ減じて、即時に正常終了E_OKとしてリターンします。この時にタスクのレディキューは変化しません。
rel_waiによる解除の場合は、エラーE_RLWAIとしてリターンします。

戻値
E_OK 正常終了
E_CTX 非タスクコンテキストで、または、ディスパッチ禁止状態で待ち実行\*
E_RLWAI 待ち状態を強制解除された(待ちの間にrel_waiを受け付け)

補足 tslp_tsk(TMO_FEVR)と同じです。

例

```c
#define ID_task1 1
TASK task1(void) {
    :

        slp_tsk();

    :
}
TASK task2(void) {
    :

        wup_tsk(ID_task1);

    :
}
```

### tslp_tsk

機能 自タスクを起床待ち状態へ移行(タイムアウト有)

形式 ER tslp_tsk(TMO tmout);

tmout タイムアウト値

解説 タスク自らWAITING状態へ遷移します。この待ち状態は、本タスクを対象としたwup_tsk
システムコールの発行やrel_waiシステムコールの発行、あるいは、tmoutで指定した時間の経過により解除されます。
wup_tskによる待ち解除では、正常終了E_OKとしてリターンします。wup_tskが先に発行されていて、起床要求がキューイングされている場合は、tslp_tskで待ち状態に入らず、起床要求カウントを1つ減じて、即時に正常終了E_OKとしてリターンします。この時にタスクのレディキューは変化しません。
rel_waiによる解除の場合は、エラーE_RLWAIとしてリターンします。指定時間経過による解除の場合は、タイムアウトエラーE_TMOUTとしてリターンします。tmoutの時間の単位は、システムクロックの割込み周期です。タイムアウトを検出するのは、tslp_tsk発行から tmout番目のシステムクロックです。
tmout = TMO_POL(= 0)とすると、起床要求がキューイングされている場合は、即時に正常終了E_OKとしてリターンし、起床要求がキューイングされていない場合は、即時にタイムアウトエラーE_TMOUTとしてリターンします。tmout = TMO_FEVR(= -1)によりタイムアウトをおこなわない、すなわちslp_tskと同じ動作になります。

戻値
E_OK 正常終了
E_CTX 非タスクコンテキストで、または、ディスパッチ禁止状態で待ち実行\*
E_RLWAI 待ち状態を強制解除された(待ちの間にrel_waiを受け付け)
E_TMOUT タイムアウト

補足 NORTi独自のMSECマクロを用いてtslp_tsk(100/MSEC);の様に記述することで待ち時間を
ミリ秒単位で指定できます。MSECマクロはkernel.hに#define 10と定義されていますが、システムクロックとして別の値を採用した場合は kernel.h を#include する前にその値に
#defineしてください。
注意 タイムアウト付きのシステムコールを発行した後の、 初の周期タイマ割込みが入るまでのタイミングはバラつきますから、タイムアウト時間には、-MSEC～0の誤差があります。例えばMSEC = 10の時に100msecのタイムアウトを指定すると、実際には90～100msecの範囲でタイムアウトします。
なお、μITRON4.0仕様書では、タイムアウトは「指定された以上の時が経過した後」と規定されています。すなわち、上記の例では100～110msecの範囲でタイムアウトさせねばなりませんが、NORTiの実装では90～100msecとなり、μITRON4.0仕様書とは誤差の方向が逆になっています。
現実には時間待ちを行うタスクは周期タイマ割込みに同期して動作しますので、次のような動作の違いとなります。

```c
for (;;) {
    led_on();               /* LED点灯 */
    tslp_tsk(100 / MSEC);   /* 100msec待ち */
    led_off();              /* LED消灯 \*/
    tslp_tsk(100 / MSEC);   /* 100msec待ち */
}
```

NORTiでの動作 → 200msec周期で点滅 μITRON4.0仕様 → 220msec周期で点滅

例

```c
#define MSEC 2
#include "kernel.h"
TASK task1(void) {
    ER ercd;

    :
        ercd = tslp_tsk(100 / MSEC);
    if (ercd == E_TMOUT)

        :
}
```

### wup_tsk, iwup_tsk

機能 他タスクの起床

形式 ER wup_tsk(ID tskid);
ER iwup_tsk(ID tskid); tskid タスクID

解説 slp_tskまたはtslp_tskシステムコールの実行によりWAITING状態になっているタスクを
READY状態へ遷移させます(現在のRUNNINGタスクより高優先ならRUNNING状態へ、
WAITING-SUSPENDED状態だったらSUSPENDED状態へ遷移)。対象タスクは、tskidで指定されます。タスクコンテキストから自タスクを指定することができます。
対象タスクがslp_tskまたは、tslp_tskを実行しておらず待ち状態でない場合、この起床要求はキューイングされます。キューイングされた起床要求は、後に対象タスクがslp_tsk または tslp_tsk システムコールを実行した時に有効となります。すなわち、起床要求がキューイングされている場合、slp_tsk, tslp_tskシステムコールは、起床要求を1つ減じて即時にリターンします。

戻値
E_OK 正常終了
E_ID タスクIDが範囲外\*

E_ID 非タスクコンテキストで自タスク指定(tskid = TSK_SELF)\*
E_NOEXS タスクが生成されていない E_OBJ タスクが起動されていない

E_QOVR 起床要求数のオーバーフロー(TMAX_WUPCNT = 255を超える)

例

```c
#define ID_task1 1
TASK task1(void) {
    :

        slp_tsk();

    :
}
TASK task2(void) {
    :

        wup_tsk(ID_task1);

    :
}
```

### can_wup

機能 タスクの起床要求を無効化
形式 ER_UINT can_wup(ID tskid); tskid タスクID
解説 tskidで指定されたタスクにキューイングされていた起床要求回数(wupcnt)を返し、同時にその起床要求をすべて解除します。tskid = TSK_SELFによって自タスクの指定になります。
このシステムコールは、周期的にタスクを起床する処理をおこなう場合に、時間内に処理が終わっているかどうかを判定するために利用できます。wupcntが0でなければ、前の起床要求に対する処理が時間内に終了しなかったことを示します。

戻値 正または0 キューイングされていた起床要求回数

E_ID タスクIDが範囲外\*
E_NOEXS タスクが生成されていない

例

```c
TASK task1(void) {
    ER_UINT wupcnt;

    :

        slp_tsk();

    wupcnt = can_wup(TSK_SELF);

    :
}
```

### vcan_wup

機能 自タスクの起床要求を無効化

形式 void vcan_wup(void);
解説 キューイングされている起床要求があれば、それをクリアします。自タスク専用です。NORTi 独自のシステムコールで、起床要求クリアだけなら、can_wupより高速です。

戻値 なし

例

```c
TASK task1(void) {
    :
        vcan_wup();
    tslp_tsk(100 / MSEC);

    :
}
```

### rel_wai, irel_wai

機能 他タスクの待ち状態解除
形式 ER rel_wai(ID tskid); ER irel_wai(ID tskid);

tskid タスクID
解説 tskidで指定されたタスクが何等かの待ち状態にある場合に、それを強制的に解除します。待ち解除されたタスクへは、E_RLWAIエラーが返ります。対象タスクがWAITING状態だった場合、対象タスクはREADY状態へ遷移します。(現在のRUNNINGタスクより高優先なら RUNNING状態へ遷移）。対象タスクがWAITING-SUSPENDED状態だった場合、対象タスクは SUSPENDED状態へ遷移します。
対象タスクがそれ以外の状態の時は、E_OBJエラーとなります。この時、対象タスクの状態は変化しません。本システムコールでは、待ち状態解除要求のキューイングはおこないません。

戻値
E_OK 正常終了
E_ID タスクID が範囲外\*

E_OBJ 自タスク指定(tskid = TSK_SELF)\*
E_NOEXS タスクが生成されていない

E_OBJ タスクが待ち状態でない

例

```c
#define ID_task2 2
TASK task1(void) {
    :

        rel_wai(ID_task2);

    :
}
```

### dly_tsk

機能 自タスク遅延
形式 ER dly_tsk(RELTIM dlytim); dlytim 遅延時間

解説 タスクの単純な時間待ちをおこないます。このシステムコールは、tslp_tsk(TMO tmout)とほぼ同じ機能ですが、wup_tskシステムコールの起床要求では待ち解除されません。単に時間待ちをおこなうだけの場合は、tslp_tskではなく、このdly_tskを使用してください。
遅延時間dlytimのRELTIM型は、タイムアウトのTMO型と同じlongです。遅延時間の単位も同じく、システムクロックの割込み周期です。

戻値
E_OK 正常終了
E_CTX 非タスクコンテキストで、または、ディスパッチ禁止状態で発行\*
E_RLWAI 待ち状態を強制解除された(待ちの間にrel_waiを受け付け)

5.3 タスク例外処理機能

### def_tex

機能 タスク例外処理ルーチンの定義
形式 ER def_tex(ID tskid, const T_DTEX \*pk_dtex); tskid タスクID
pk_dtex タスク例外処理ルーチン定義情報パケットへのポインタ

解説 tskid で指定されたタスクに対してタスク例外処理ルーチンを定義します。pk_dtexにNULL
を指定すると定義解除します。また、別の定義情報を指定すると再定義します。再定義の場合は、例外処理要求・例外処理許可/禁止状態を継承します。tskid = TSK_SELFで自タスクを対象タスクにします。
タスクが再起動された場合、例外処理要求はクリアされ、例外処理禁止状態になります。
タスクが削除された場合、タスク例外処理ルーチン定義は解除されます。
タスク例外処理ルーチン定義情報は、次の通りです。

```c
typedef struct t_dtex

{
    ATR texatr; /* タスク例外処理ルーチン属性 */
    FP texrtn;  /* タスク例外処理ルーチン起動番地 */
} T_DTEX;
```

texatrの内容にOSは感知しませんが、他のμITRONとの互換性を維持するためにTA_HLNG を指定してください。定義情報パケットをROM以外に置いた場合、すなわちconstを付けなかった場合、定義情報パケットはシステムメモリにコピーされます。

戻値
E_OK 正常終了
E_ID タスクIDが範囲外\*
E_NOEXS タスクが生成されていない

E_PAR パラメータエラー(texrtn == NULL)\*

例

```c
#define ID_task1 1
void texrtn(TEXPTN texptn, VP_INT exinf) {
    :
}
const T_DTEX dtex = {TA_HLNG, (FP)texrtn};
TASK task1(void) {
    :

        def_tex(ID_task1, &dtex);

    :
}
```

### ras_tex, iras_tex

機能 タスク例外処理要求
形式 ER ras_tex(ID tskid, TEXPTN rasptn); ER iras_tex(ID tslid, TEXPTN rasptn);
tskid タスクID rasptn タスク例外要因
解説 tskidで指定されたタスクに対してrasptnで指定される例外処理を要求します。対象タスクが広義の待ち状態のときは例外要因は保留され例外処理は実行されません。対象タスクが実行状態になるまで実行されません。tskid = TSK_SELFで自タスクを対象タスクにします。

戻値
E_OK 正常終了
E_ID タスクIDが範囲外\*

E_ID 非タスクコンテキストで自タスク指定(tskid = TSK_SELF)\*
E_NOEXS タスクが生成されていない

E_OBJ タスク例外処理ルーチン未定義

E_PAR rasptnが0

例

```c
#define ID_task1 1
TASK task1(void) {
    :

        ras_tex(ID_task1, 1);

    :

        ras_tex(ID_task1, 2);

    :
}
```

### dis_tex

機能 タスク例外処理禁止

形式 ER dis_tex(void);
解説 タスクコンテキストでは自タスク、割込みハンドラでは実行状態タスクに対してタスク例外処理を禁止します。タイムイベントハンドラでは、E_CTXエラーになります。

戻値
E_OK 正常終了
E_CTX コンテキストエラー

E_OBJ タスク例外処理ルーチンが未定義

例

```c
TASK task1(void) {
    :

        dis_tex();

    :
}
```

### ena_tex

機能 タスク例外処理許可

形式 ER ena_tex(void);

解説 タスクコンテキストでは自タスク、割込みハンドラでは実行状態タスクに対してタスク例
外処理を許可します。タイムイベントハンドラでは、E_CTXエラーになります。
保留例外要因があれば指定タスクが RUNNING 状態になった時に例外処理ルーチンが実行さ
れます。

戻値
E_OK 正常終了
E_CTX コンテキストエラー

E_OBJ タスク例外処理ルーチンが未定義

例

```c
TASK task1(void) {
    :

        ena_tex();

    :
}
```

### sns_tex

機能 自タスクのタスク例外処理禁止状態の参照

形式 BOOL sns_tex(void);
解説 実行状態のタスクがタスク例外処理禁止状態であればTRUE、許可状態であればFALSEを返します。実行状態のタスクが無い場合にはTRUEを返します。

戻値 TRUE 禁止中

FALSE 許可中

例

```c
TASK task1(void) {
    :

        if (sns_tex()) {
        :
    }

    :
}
```

### ref_tex

機能 タスク例外処理状態参照
形式 ER ref_tex(ID tskid, T_RTEX \*pk_rtex); tskid タスクID
pk_rtex タスク例外処理状態パケットを格納する場所へのポインタ

解説 tskidで指定されたタスクのタスク例外処理状態を、\*pk_rtexに返します。
tskid = TSK_SELFで自タスクを指定できます。
タスク例外処理状態パケットの構造は次の通りです。

```c
typedef struct t_rtex

{
    STAT texstat;   /* 例外処理の状態 */
    TEXPTN pndptn; /* 保留例外要因 */
} T_RTEX;
```

texstatには次の値が返されます。
TTEX_ENA 0x00 タスク例外処理許可状態 TTEX_DIS 0x01 タスク例外処理禁止状態
例外処理要求が無いときにはpndptn = 0となります。

戻値
E_OK 正常終了
E_ID タスクID が範囲外\*
E_NOEXS タスクが生成されていない

E_OBJ タスク例外処理ルーチンが未定義

E_OBJ 指定タスクが休止状態

例

```c
#define ID_task2 2
TASK task1(void) {
    T_RTEX rtex;

    :
        ref_tex(ID_task2, &rtex);
    if (rtex.pndptn != 0)

        :
}
```

5.4 同期・通信機能(セマフォ)

### cre_sem

機能 セマフォ生成
形式 ER cre_sem(ID semid, const T_CSEM \*pk_csem); semid セマフォID
pk_csem セマフォ生成情報パケットへのポインタ

解説 semidで指定されたセマフォを生成します。すなわち、システムメモリから、セマフォ管理
ブロックを動的に割り当てます。また、セマフォ生成情報のisemcntで指定される初期値をセマフォカウントに設定します。
定義情報パケットをROM以外に置いた場合、すなわちconstを付けなかった場合、定義情報パケットはシステムメモリにコピーされます。
セマフォ生成情報パケットの構造は次の通りです。

```c
typedef struct t_csem

{
    ATR sematr;   /* セマフォ属性 */
    UINT isemcnt; /* セマフォの初期値  */
    UINT maxsem;  /* セマフォの最大値 */
    B* name;      /* セマフォ名へのポインタ（省略可） */
} T_CSEM;
```

セマフォ属性sematrには次の値を入れてください。
TA_TFIFO 待ちタスク行列は先着順(FIFO)
TA_TPRI 待ちタスク行列はタスク優先度順
maxsemには使用可能とする資源数を設定してください。設定可能な上限値はTMAX_MAXSEM に定義されています。
nameは対応デバッガ用ですので、名前を指定しない場合には\"\"かNULLを入れてください。
この構造体を初期値付きで定義する場合には、nameを省略しても構いません。

戻値
E_OK 正常終了
E_PAR セマフォ 大値が負または255を超える\*

セマフォ初期値が負または 大値を超える\*

E_ID セマフォIDが範囲外\*

E_OBJ セマフォが既に生成されている

E_CTX 割込みハンドラから発行\*

E_SYS 管理ブロック用のメモリが確保できない\*\*

例

```c
#define ID_sem1 1
const T_CSEM csem1 = {TA_TFIFO, 1, 1};
TASK task1(void) {
    ER ercd;

    :

        ercd = cre_sem(ID_sem1, &csem1);

    :
}
```

### acre_sem

機能 セマフォ生成(ID自動割り当て)

形式 ER_ID acre_sem(const T_CSEM \*pk_csem);
pk_csem セマフォ生成情報パケットへのポインタ
解説 未生成セマフォのIDを、大きな方から検索して割り当てます。セマフォIDが割り当てられない場合は、E_NOIDエラーを返します。それ以外は、cre_semと同じです。

+---------+------------+----------------------------------------------+
| 戻値 | > 正の値 | 割り当てられたセマフォID |
+=========+============+==============================================+
| | > E_PAR | セマフォ 大値が負または255を超える\* |
+---------+------------+----------------------------------------------+
| | | セマフォ初期値が負または 大値を超える\* |
+---------+------------+----------------------------------------------+
| | > E_NOID | > セマフォIDが不足 |
+---------+------------+----------------------------------------------+
| | > E_CTX | 割込みハンドラから発行\* |
+---------+------------+----------------------------------------------+
| | > E_SYS | > 管理ブロック用のメモリが確保できない\*\* |
+---------+------------+----------------------------------------------+

例

```c
ID ID_sem1;
const T_CSEM csem1 = {TA_TFIFO, 0, 1};
TASK task1(void) {
    ER_ID ercd;

    :
        ercd = acre_sem(&csem1);
    if (ercd > 0) ID_sem1 = ercd;

    :
}
```

### del_sem

機能 セマフォ削除
形式 ER del_sem(ID semid); semid セマフォID

解説 semidで指定されたセマフォを削除します。すなわち、セマフォ管理ブロックをシステム
メモリへ解放します。
このセマフォに対して待っているタスクがあった場合、このタスクの待ちを解除します。
待ち解除されたタスクへは、削除されたことを示すE_DLTエラーが返ります。

戻値
E_OK 正常終了
E_ID セマフォID が範囲外\*
E_NOEXS セマフォが生成されていない

E_CTX 割込みハンドラから発行\*

例

```c
#define ID_sem1 1
TASK task1(void) {
    :

        del_sem(ID_sem1);

    :
}
```

### sig_sem, isig_sem

機能 セマフォ資源返却

形式 ER sig_sem(ID semid);
ER isig_sem(ID semid); semid セマフォID

解説 semidで指定されたセマフォに対して待っているタスクがなければ、セマフォのカウント値
を1だけ増やします(資源を返却)。セマフォのカウント値が、セマフォ生成時に指定した大値を越えた場合には、エラーE_QOVRを返します。
このセマフォに対して待っているタスクがあれば、待ち行列の先頭タスクの待ちを解除します。すなわち、WAITING状態からREADY状態へ遷移させます(現在のRUNNINGタスクより高優先ならRUNNING状態へ、WAITING-SUSPENDED状態だったらSUSPENDED状態へ遷移)。

戻値
E_OK 正常終了
E_ID セマフォIDが範囲外\*
E_NOEXS セマフォが生成されていない

E_QOVR セマフォカウントのオーバーフロー

### wai_sem

機能 セマフォ資源獲得

形式 ER wai_sem(ID semid);

semid セマフォID

解説 semidで指定されたセマフォのカウント値が1以上の場合、このセマフォのカウント値を1
だけ減じて(資源獲得して)、即リターンします。
セマフォのカウント値が 0 の場合、本システムコールの発行タスクはそのセマフォに対する待ち行列につながれます。この場合のセマフォのカウント値は0のままです。

戻値
E_OK 正常終了
E_ID セマフォID が範囲外\*
E_NOEXS セマフォが生成されていない

E_CTX 非タスクコンテキストで、または、ディスパッチ禁止状態で待ち実行\*
E_RLWAI 待ち状態を強制解除された(待ちの間にrel_waiを受け付け)

E_DLT 待ちの間にセマフォが削除された

補足 twai_sem(semid, TMO_FEVR)と同じです。

例

```c
#define ID_sem1 1
TASK task1(void) {
    :

        wai_sem(ID_sem1);

    :

        sig_sem(ID_sem1);

    :
}
```

### pol_sem

機能 セマフォ資源獲得(ポーリング)
形式 ER pol_sem(ID semid); semid セマフォID
解説 semidで指定されたセマフォのカウント値が1以上の場合、このセマフォのカウント値を1 だけ減じて(資源獲得して)、即リターンします。セマフォカウント値が 0 の場合は、待ち状態に入らずに、E_TMOUTエラーで即リターンします。

戻値
E_OK 正常終了
E_ID セマフォIDが範囲外\*
E_NOEXS セマフォが生成されていない
E_TMOUT ポーリング失敗
補足 twai_sem(semid, TMO_POL)と同じです。
例

```c
if (pol_sem(ID_sem1) == E_OK) {
    :

        if (pol_sem(ID_sem1) != E_TMOUT)

            :
}
```

### twai_sem

機能 セマフォ資源獲得(タイムアウト有)
形式 ER twai_sem(ID semid, TMO tmout); semid セマフォID

tmout タイムアウト値
解説 semidで指定されたセマフォのカウント値が1以上の場合、このセマフォのカウント値を1 だけ減じて(資源獲得して)、即リターンします。セマフォのカウント値が 0 の場合、本システムコールの発行タスクはそのセマフォに対する待ち行列につながれます。この場合のセマフォのカウント値は0のままです。tmoutで指定した時間が経過すると、タイムアウトエラーE_TMOUTとしてリターンします。tmout = TMO_POL(= 0)により待ちをおこなわない、すなわち pol_sem と同じ動作になります。tmout = TMO_FEVR(= -1)によりタイムアウトしない、すなわちwai_semと同じ動作になります。

戻値
E_OK 正常終了
E_ID セマフォID が範囲外\*
E_NOEXS セマフォが生成されていない

E_CTX 非タスクコンテキストで、または、ディスパッチ禁止状態で待ち実行\*
E_RLWAI 待ち状態を強制解除された(待ちの間にrel_waiを受け付け)

E_DLT 待ちの間にセマフォが削除された
E_TMOUT タイムアウト

例

```c
#define ID_sem1 1
TASK task1(void) {
    ER ercd;

    :
        ercd = twai_sem(ID_sem1, 100 / MSEC);
    if (ercd == E_OK)

        :
}
```

### ref_sem

機能 セマフォ状態参照

形式 ER ref_sem(ID semid, T_RSEM \*pk_rsem);

semid セマフォID
pk_rsem セマフォ状態パケットを格納する場所へのポインタ

解説 semidで指定されたセマフォの状態を、\*pk_rsemに返します。
セマフォ状態パケットの構造は次の通りです。

```c
typedef struct t_rsem

{
    ID wtskid;   /* 待ちタスクのタスクID 、無い場合はTSK_NONE */
    UINT semcnt; /* 現在のセマフォカウント値 */
} T_RSEM;
```

wtskidには、待ちタスクがある場合、その先頭の待ちタスクのID番号が返ります。待ちタスクがない場合は、TSK_NONEが返ります。

戻値
E_OK 正常終了
E_ID セマフォIDが範囲外
E_NOEXS セマフォが生成されていない

例

```c
#define ID_sem1 1
TASK task1(void) {
    T_RSEM rsem;

    :
        ref_sem(ID_sem1, &rsem);
    if (rsem.wtsk != FALSE)

        :
}
```

5.5 同期・通信機能(イベントフラグ)

### cre_flg

機能 イベントフラグ生成
形式 ER cre_flg(ID flgid, const T_CFLG \*pk_cflg); flgid イベントフラグID
pk_cflg イベントフラグ生成情報パケットへのポインタ

解説 flgidで指定されたイベントフラグを生成します。すなわち、システムメモリから、イベン
トフラグ管理ブロックを動的に割り当てます。また、イベントフラグ生成情報のiflgptn で指定される初期値をイベントフラグのビットパターンに設定します。
定義情報パケットをROM 以外に置いた場合、すなわちconstを付けなかった場合、定義情報パケットはシステムメモリにコピーされます。
イベントフラグ生成情報パケットの構造は次の通りです。

```c
typedef struct t_cflg

{
    ATR flgatr;    /* イベントフラグ属性 */
    FLGPTN iflgptn; /* イベントフラグの初期値 */
    B* name;       /* イベントフラグ名へのポインタ（省略可） */
} T_CFLG;
```

使用可能なフラグビット数はTBIT_FLGPTNマクロにより参照できます。
イベントフラグ属性flgatrには次の値を入れてください。

TA_WSGL 複数タスクの待ちを許さない

TA_WMUL 複数タスクの待ちを許す
TA_TFIFO 待ちタスク行列は先着順(FIFO)

TA_TPRI 待ちタスク行列はタスク優先度順

TA_CLR タスクの待ち解除時にフラグビットをすべてクリアする
待ち行列につながれたタスクは、待ち行列につながれた順に待ち解除されるとは限りません。待っているフラグビットパーターンに合致したタスクから待ち解除されます。また、 TA_CLRを指定しない場合、複数のタスクが同時に待ち解除されることもあります。TA_CLR を指定した場合、 初にタスクを待ち解除した時点でフラグがクリアされるため複数のタスクが同時に待ち解除されることはありません。
TA_WSGLを指定した場合には、TA_TFIFO, TA_TPRIを指定しても意味がありません。
nameは対応デバッガ用ですので、名前を指定しない場合には \"\"か NULLを入れてください。この構造体を初期値付きで定義する場合には、name を省略しても構いません。

+----------+------------+----------------------------------------------+
| 戻値 | E_OK | 正常終了 |
+==========+============+==============================================+
| | E_ID | イベントフラグIDが範囲外\* |
+----------+------------+----------------------------------------------+
| | E_OBJ | イベントフラグが既に生成されている |
+----------+------------+----------------------------------------------+
| | E_CTX | 割込みハンドラから発行\* |
+----------+------------+----------------------------------------------+
| | E_SYS | > 管理ブロック用のメモリが確保できない\*\* |
+----------+------------+----------------------------------------------+

例

```c
#define ID_flg1 1
const T_CFLG cflg1 = {TA_WMUL, 0};
TASK task1(void) {
    ER ercd;

    :

        ercd = cre_flg(ID_flg1, &cflg1);

    :
}
```

### acre_flg

機能 イベントフラグ生成(ID自動割り当て)

形式 ER_ID acre_flg(const T_CFLG \*pk_cflg);
pk_cflgイベントフラグ生成情報パケットへのポインタ
解説 未生成イベントフラグの ID を、大きな方から検索して割り当てます。イベントフラグ ID が割り当てられない場合は、E_NOIDエラーを返します。それ以外は、cre_flgと同じです。

戻値 正の値 割り当てられたイベントフラグID

E_NOID イベントフラグIDが不足

E_CTX 割込みハンドラから発行\*

E_SYS 管理ブロック用のメモリが確保できない\*\*

例

```c
ID ID_flg1;
const T_CFLG cflg1 = {TA_WMUL, 0};
TASK task1(void) {
    ER_ID ercd;

    :
        ercd = acre_flg(&cflg1);
    if (ercd > 0) ID_flg1 = ercd;

    :
}
```

### del_flg

機能 イベントフラグ削除

形式 ER del_flg(ID flgid);
flgid イベントフラグID

解説 flgidで指定されたイベントフラグを削除します。すなわち、イベントフラグ管理ブロック
をシステムメモリへ解放します。
このイベントフラグに対して待っているタスクがあった場合、このタスクの待ちを解除します。待ち解除されたタスクへは、削除されたことを示すE_DLTエラーが返ります。

戻値
E_OK 正常終了
E_ID イベントフラグIDが範囲外\*
E_NOEXS イベントフラグが生成されていない

E_CTX 割込みハンドラから発行\*

例

```c
#define ID_flg1 1
TASK task1(void) {
    :

        del_flg(ID_flg1);

    :
}
```

### set_flg, iset_flg

機能 イベントフラグのセット

形式 ER set_flg(ID flgid, FLGPTN setptn);
ER iset_flg(ID flgid, FLGPTN setptn); flgid イベントフラグID

setptn セットするビットパターン

解説 flgidで指定されるイベントフラグの、setptnで示されるビットがセットされます。つま
り、現在のイベントフラグの値に対して、setptnの値で論理和がとられます(flgptn \|= setptn)。
イベントフラグ値の変更の結果、そのイベントフラグを待っていたタスクの待ち条件を満たすようになれば、そのタスクの待ちを解除します。すなわち、WAITING状態からREADY 状態へ遷移させます(現在のRUNNINGタスクより高優先ならRUNNING状態へ、
WAITING-SUSPENDED状態だったらSUSPENDED状態へ遷移)。
イベントフラグ生成時にTA_CLRを指定した場合で、待ち解除されたタスクがある場合は、初のタスクを待ち解除した時点でイベントフラグをクリアします。
イベントフラグでの複数タスクの待ちを許していて TA_CLR を指定しない場合、1 回の set_flgで複数のタスクが一斉に待ち解除となることがあります。wai_flgにおけるwaiptn やwfmode、生成情報のTA_CLRの有無との関係により、必ずしも行列先頭のタスクから待ち解除になるとは限りません。また、待ち行列中にクリア指定のタスクがあってこれが待ち解除される場合、このタスクより後ろに並んでいるタスクは、クリアされたイベントフラグを見ることになるので、待ち解除されません。

戻値
E_OK 正常終了
E_ID イベントフラグID が範囲外\*
E_NOEXS イベントフラグが生成されていない

例

```c
#define ID_flg1 1
#define BIT0 0x0001
TASK task1(void) {
    :

        set_flg(ID_flg1, BIT0);

    :
}
```

### clr_flg

機能 イベントフラグのクリア

形式 ER clr_flg(ID flgid, FLGPTN clrptn);
flgid イベントフラグID clrptn クリアするビットパターン

解説 flgidで指定されるイベントフラグの、clrptnで0となっているビットがクリアされます。
つまり、現在のイベントフラグの値に対して、clrptnの値で論理積がとられます
（flgptn &= clrptn ）。
clr_flg では、そのイベントフラグを待っているタスクが待ち解除となることはありません。

戻値
E_OK 正常終了
E_ID イベントフラグID が範囲外\*
E_NOEXS イベントフラグが生成されていない

例

```c
#define ID_flg1 1
#define BIT0 0x0001
TASK task1(void) {
    :

        clr_flg(ID_flg1, ~BIT0);

    :
}
```

### wai_flg

機能 イベントフラグ待ち
形式 ER wai_flg(ID flgid, FLGPTN waiptn, MODE wfmode, flgptn \*p_flgptn); flgid イベントフラグID waiptn 待ちビットパターン wfmode 待ちモード
p_flgptn 待ち解除時のビットパターンを格納する場所へのポインタ

解説 waiptnとwfmodeで示される待ち条件にしたがって、flgidで指定されるイベントフラグが
セットされるのを待ちます。
待ちモードwfmodeには、次の様な値を入れてください。

---

TWF_ANDW AND待ち

---

TWF_ORW OR待ち

TWF_ANDW \| TWF_CLR クリア指定AND待ち

TWF_ORW \| TWF_CLR クリア指定OR待ち

---

TWF_ORWを指定した場合は、waiptnで指定したビットのいずれかがセットされるのを待ちます。TWF_ANDWを指定した場合は、waiptnで指定したビット全てがセットされるのを待ちます。waiptnで1のビットが1個だけなら、TWF_ANDW, TWF_ORWは同じ結果です。
TWF_CLRの指定がある場合は、条件が満足されてタスクが待ち解除となった時に、イベントフラグの全ビットをクリアします。ただし、生成情報でフラグ属性としてTA_CLRを指定した場合はTWF_CLRを指定しなくとも常に全ビットクリアされます。
\*p_flgptnには、待ち状態が解除される時のイベントフラグの値が返されます。クリア指定の場合は、クリアされる前の値が返されます。
すでにイベントフラグの条件が成立している場合には、待ち状態に入らず、上記の操作をおこないます。

戻値
E_OK 正常終了
E_PAR 待ちモードwfmodeが正しくない\* 待ちビットパターンwaiptnが0\*

E_ID イベントフラグIDが範囲外\*
E_NOEXS イベントフラグが生成されていない
E_ILUSE すでに待ちタスクあり(複数待ち許さない場合)

E_CTX 非タスクコンテキストで、または、ディスパッチ禁止状態で待ち実行\*
E_RLWAI 待ち状態を強制解除された(待ちの間にrel_waiを受け付け)

E_DLT 待ちの間にイベントフラグが削除された

補足 twai_flg(flgid, waiptn, wfmode, p_flgptn, TMO_FEVR)と同じです。

例

```c
#define ID_flg1 1
#define BIT0 0x0001
TASK task1(void) {
    FLGPTN ptn;

    :

        wai_flg(ID_flg1, BIT0, TWF_ANDW, &ptn);

    :
}
```

### pol_flg

機能 イベントフラグ待ち(ポーリング)
形式 ER pol_flg(ID flgid, FLGPTN waiptn, MODE wfmode, FLGPTN \*p_flgptn); flgid イベントフラグID waiptn 待ちビットパターン wfmode 待ちモード
p_flgptn 待ち解除時のビットパターンを格納する場所へのポインタ
解説 waiptnとwfmodeで示される待ち条件にしたがって、flgidで指定されるイベントフラグがセットされているかテストします。すでに待ち条件が満たされている場合には、正常終了します。待ち条件が満たされていない場合は、エラーE_TMOUTで即リターンします。
\*p_flgptnには、待ち状態が解除される時のイベントフラグの値が返されます。クリア指定の場合は、クリアされる前の値が返されます。
wfmodeの説明は、wai_flgを参照してください。

戻値
E_OK 正常終了
E_PAR 待ちモードwfmodeが正しくない\* 待ちビットパターンwaiptnが0\* E_ID イベントフラグIDが範囲外\*
E_NOEXS イベントフラグが生成されていない
E_ILUSE すでに待ちタスクあり(複数待ち許さない場合)
E_TMOUT ポーリング失敗
補足 twai_flg(flgid, waiptn, wfmode, p_flgptn, TMO_POL)と同じです。

例

```c
#define ID_flg1 1
TASK task1(void) {
    FLGPTN ptn;

    :

        if (pol_flg(ID_flg1, 0xffff, TWF_ORW | TWF_CLR, &ptn) == E_OK)

            :
}
```

### twai_flg

機能 イベントフラグ待ち(タイムアウト有)
形式 ER twai_flg(ID flgid, FLGPTN waiptn, MODE wfmode, FLGPTN \*p_flgptn, TMO tmout); flgid イベントフラグID waiptn 待ちビットパターン wfmode 待ちモード
p_flgptn 待ち解除時のビットパターンを格納する場所へのポインタ tmout タイムアウト値

解説 waiptnとwfmodeで示される待ち条件にしたがって、flgidで指定されるイベントフラグが
セットされるのを待ちます。すでに待ち条件が満たされている場合には、待ち状態に入らず正常終了します。
tmoutで指定した時間が経過すると、タイムアウトエラーE_TMOUTとしてリターンします。
tmout = TMO_POL(= 0)により待ちをおこなわない、すなわちpol_flgと同じ動作になります。tmout =TMO_FEVR(= -1)によりタイムアウトしない、すなわちwai_flgと同じ動作になります。
wfmode とp_flgptnの説明は、wai_flgを参照してください。

戻値
E_OK 正常終了
E_PAR 待ちモードwfmode が正しくない\* 待ちビットパターンwaiptnが0\*

E_ID イベントフラグIDが範囲外\*
E_NOEXS イベントフラグが生成されていない

E_OBJ すでに待ちタスクあり(複数待ちを許さない場合)

E_CTX 非タスクコンテキストで、または、ディスパッチ禁止状態で待ち実行\*
E_RLWAI 待ち状態を強制解除された(待ちの間にrel_waiを受け付け)

E_DLT 待ちの間にイベントフラグが削除された
E_TMOUT タイムアウト

例

```c
#define ID_flg1 1
TASK task1(void) {
    FLGPTN ptn;
    ER ercd;

    :
        ercd =
            twai_flg(ID_flg1, 0xffff, TWF_ANDW | TWF_CLR, &ptn, 1000 / MSEC);
    if (ercd == E_TMOUT)

        :
}
```

### ref_flg

機能 イベントフラグ状態参照

形式 ER ref_flg(ID flgid, T_RFLG \*pk_rflg);
flgid イベントフラグID
pk_rflg イベントフラグ状態パケットを格納する場所へのポインタ

解説 flgidで指定されたイベントフラグの状態を、\*pk_rflgに返します。
イベントフラグ状態パケットの構造は次の通りです。

```c
typedef struct t_rflg

{
    ID wtskid;    /* 待ちタスクIDまたはTSK_NONE */
    FLGPTN flgptn; /* 現在のビットパターン */
} T_RFLG;
```

wtskidには、待ちタスクがある場合、その先頭の待ちタスクのID番号が返ります。待ちタスクがない場合は、TSK_NONEが返ります。

戻値
E_OK 正常終了
E_ID イベントフラグIDが範囲外
E_NOEXS イベントフラグが生成されていない

例

```c
#define ID_flg1 1
TASK task1(void) {
    T_RFLG rflg;

    :
        ref_flg(ID_flg1, &rflg);
    if (rflg.flgptn != 0)

        :
}
```

5.6 同期・通信機能(データキュー)

### cre_dtq

機能 データキュー生成
形式 ER cre_dtq(ID dtqid, const T_CDTQ \*pk_cdtq); dtqid データキューID
pk_cdtq データキュー生成情報パケットへのポインタ

解説 dtqidで指定されたデータキューを生成します。すなわち、システムメモリから、データ
キュー管理ブロックを動的に割り当てます。
定義情報パケットをROM以外に置いた場合、すなわちconstを付けなかった場合、定義情報パケットはシステムメモリにコピーされます。
データキュー生成情報パケットの構造は次の通りです。

```c
typedef struct t_cdtq {
    ATR dtqatr;   /* データキュー属性                   */
    UINT dtqcnt;  /* > データキューサイズ(データ数)     */
    VP dtq;       /* データバッファアドレス             */
    B* name;      /* データキュー名へのポインタ(省略可) */
} T_CDTQ;
```

データキュー属性dtqatrには次の値を入れてください。
TA_TFIFO 送信待ちタスク行列は先着順(FIFO)
TA_TPRI 送信待ちタスク行列はタスク優先度順
受信待ちタスク行列は常に先着順(FIFO)になります。また、データ順も送信順になります。
ただし強制送信(fsnd_dtq, ifsnd_dtq)を使った場合は強制送信データが先に受信される場合があります。
dtqcntにはキューイングするデータ数を、dtq にはデータバッファのアドレスを設定してください。TSZ_DTQ(n)マクロによりデータ数nの場合の必要メモリ量を知ることができます。dtqにNULLを設定するとデータバッファはシステムメモリに取られます。dtqcntに0 を設定するとバッファを使用せずにタスク間のデータ直接渡しになり同期を取ることができます。
nameは対応デバッガ用ですので、名前を指定しない場合には \"\"かNULLを入れてください。
この構造体を初期値付きで定義する場合には、name を省略しても構いません。

+----------+------------+----------------------------------------------+
| 戻値 | E_OK | 正常終了 |
+==========+============+==============================================+
| | E_ID | データキューIDが範囲外\* |
+----------+------------+----------------------------------------------+
| | E_OBJ | データキューが既に生成されている |
+----------+------------+----------------------------------------------+
| | E_CTX | 割込みハンドラから発行\* |
+----------+------------+----------------------------------------------+
| | E_SYS | > 管理ブロック用のメモリが確保できない\*\* |
+----------+------------+----------------------------------------------+

例

```c
#define ID_dtq1 1
const T_CDTQ cdtq1 = {TA_TPRI, 30, NULL};
TASK task1(void) {
    ER ercd;

    :

        ercd = cre_dtq(ID_dtq1, &cdtq1);

    :
}
```

### acre_dtq

機能 データキュー生成(ID自動割り当て)

形式 ER_ID acre_dtq(const T_CDTQ \*pk_cdtq);
pk_cdtq データキュー生成情報パケットへのポインタ
解説 未生成データキューのIDを、大きな方から検索して割り当てます。データキューIDが割り当てられない場合は、E_NOIDエラーを返します。それ以外は、cre_dtqと同じです。

戻値 正の値 割り当てられたデータキューID

E_NOID データキューIDが不足

E_CTX 割込みハンドラから発行\*

E_SYS 管理ブロック用のメモリが確保できない\*\*

例

```c
ID ID_dtq1;
const T_CDTQ cdtq1 = {TA_TPRI, 30, NULL};
TASK task1(void) {
    ER_ID ercd;

    :
        ercd = acre_dtq(&cdtq1);
    if (rcd > 0) ID_dtq1 = ercd;

    :
}
```

### del_dtq

機能 データキュー削除

形式 ER del_dtq(ID dtqid);

dtqid データキューID
解説 dtqidで指定されたデータキューを削除します。すなわち、データキュー管理ブロックをシステムメモリへ解放します。データバッファをOSが確保した場合はデータバッファも開放されます。バッファ内のデータは破棄されます。
このデータキューに対して待っているタスクがあった場合、このタスクの待ちを解除します。待ち解除されたタスクへは、削除されたことを示すE_DLTエラーが返ります。

戻値
E_OK 正常終了
E_ID データキューIDが範囲外\*
E_NOEXS データキューが生成されていない

E_CTX 割込みハンドラから発行\*

例

```c
#define ID_dtq1 1
TASK task1(void) {
    :

        del_dtq(ID_dtq1);

    :
}
```

### snd_dtq

機能 データ送信

形式 ER snd_dtq(ID dtqid,VP_INT data);
dtqid データキューID data 送信するデータ

解説 dtqidで指定されるデータキューに、dataが送信されます。
受信待ち行列にタスクがある場合は、先頭タスクの待ちを解除します。すなわち、WAITING 状態からREADY状態へ遷移させます(現在のRUNNINGタスクより高優先ならRUNNING状態へ、 WAITING-SUSPENDED状態だったらSUSPENDED状態へ遷移)。
受信待ちのタスクが無い場合は、データをデータバッファの末尾に入れます。データバッファに空きが無い場合は自タスクを送信待ち行列につなぎます。

戻値
E_OK 正常終了
E_ID データキューIDが範囲外\*
E_NOEXS データキューが生成されていない
E_RLWAI 待ち状態を強制解除された(待ちの間にrel_waiを受け付け)

E_DLT 待ちの間にデータキューが削除された

E_CTX 非タスクコンテキスト部から、あるいはディスパッチ禁止中に実行
補足 tsnd_dtq(dtqid, data, TMO_FEVR)と同じです。

例

```c
#define ID_dtq1 1
TASK task1(void) {
    VP_INT data

        :
            data = (VP_INT)1;
    snd_dtq(ID_dtq1, data);

    :
}
```

### psnd_dtq, ipsnd_dtq

機能 データ送信(ポーリング)
形式 ER psnd_dtq(ID dtqid,VP_INT data); ER ipsnd_dtq(ID dtqid,VP_INT data);
dtqid データキューID data 送信するデータ

解説 dtqidで指定されるデータキューに、dataが送信されます。
受信待ち行列にタスクがある場合は、先頭タスクの待ちを解除します。すなわち、WAITING 状態からREADY状態へ遷移させます(現在のRUNNINGタスクより高優先ならRUNNING状態へ、 WAITING-SUSPENDED状態だったらSUSPENDED状態へ遷移)。
受信待ちのタスクが無い場合は、データをデータバッファの末尾に入れます。データバッファに空きが無い場合はエラーE_TMOUTで直ちにリターンします。データバッファサイズを 0とした場合は、受信待ちタスクがない場合にE_TMOUTで返ります。

戻値
E_OK 正常終了
E_ID データキューID が範囲外\*
E_NOEXS データキューが生成されていない
E_TMOUT ポーリング失敗
補足 tsnd_dtq(dtqid, data, TMO_POL)と同じです。

例

```c
#define ID_dtq1 1
TASK task1(void) {
    VP_INT data;
    ER ercd;

    :
        data = (VP_INT)1;
    ercd = psnd_dtq(ID_dtq1, data);
    if (ercd == E_OK)

        :

        :
}
```

### tsnd_dtq

機能 データ送信
形式 ER tsnd_dtq(ID dtqid, VP_INT data, TMO tmout); dtqid データキューID data 送信するデータ tmout タイムアウト値

解説 dtqidで指定されるデータキューに、dataが送信されます。
受信待ち行列にタスクがある場合は、先頭タスクの待ちを解除します。すなわち、WAITING 状態からREADY状態へ遷移させます(現在のRUNNINGタスクより高優先ならRUNNING状態へ、
WAITING-SUSPENDED状態だったらSUSPENDED状態へ遷移)。
受信待ちのタスクが無い場合は、データをデータバッファの末尾に入れます。データバッファに空きが無い場合は自タスクを送信待ち行列につなぎます。
tmoutで指定した時間が経過しても空きがない場合、タイムアウトエラーE_TMOUTとしてリターンします。tmout = TMO_POL(= 0)により待ちをおこなわない、すなわちpsnd_dtqと同じ動作になります。tmout = TMO_FEVR(= -1)によりタイムアウトしない、すなわちsnd_dtq と同じになります。

戻値
E_OK 正常終了
E_ID データキューID が範囲外\*
E_NOEXS データキューが生成されていない
E_RLWAI 待ち状態を強制解除された(待ちの間にrel_waiを受け付け)

E_DLT 待ちの間にデータキューが削除された

E_CTX 非タスクコンテキスト部から、あるいはディスパッチ禁止中に実行
E_TMOUT タイムアウト

例

```c
#define ID_dtq1 1
TASK task1(void) {
    VP_INT data;
    ER ercd;

    :
        data = (VP_INT)1;
    ercd = tsnd_dtq(ID_dtq1, data, 1000 / MSEC);
    if (ercd != E_TMOUT)

        :

        :
}
```

### fsnd_dtq, ifsnd_dtq

機能 強制データ送信
形式 ER fsnd_dtq(ID dtqid, VP_INT data); ER ifsnd_dtq(ID dtqid, VP_INT data);
dtqid データキューID data 送信するデータ

解説 dtqidで指定されるデータキューに、dataを強制送信します。
受信待ち行列にタスクがある場合は、先頭タスクにデータを渡し待ちを解除します。すなわち、WAITING状態からREADY状態へ遷移させます(現在のRUNNINGタスクより高優先なら RUNNING状態へ、WAITING-SUSPENDED状態だったらSUSPENDED状態へ遷移)。
受信待ちのタスクが無い場合は、データをデータバッファの末尾に入れます。データバッファに空きが無い場合はデータキューの先頭のデータを廃棄してそこに強制送信データを入れます。送信待ちタスクがある場合でもデータをバッファに入れます。
バッファサイズ0の場合は、受信待ちタスクがある場合でもE_ILUSEエラーを返します。

戻値
E_OK 正常終了
E_ID データキューIDが範囲外\*
E_NOEXS データキューが生成されていない
E_ILUSE バッファサイズ0

例

```c
#define ID_dtq1 1
TASK task1(void) {
    VP_INT data;

    :
        data = (VP_INT)1;
    fsnd_dtq(ID_dtq1, data);

    :
}
```

### rcv_dtq

機能 データキューからの受信
形式 ER rcv_dtq(ID dtqid, VP_INT \*p_data); dtqid デ ータキューID
p_data 受信したデータを格納する場所へのポインタ
解説 dtqid で指定されるデータキューから先頭のデータを受信します。送信待ちのタスクがある場合には、送信しようとしているデータをデータキューに入れて送信待ちタスクの待ちを解除します。データキューサイズが0 の場合は、送信待ち行列の先頭のタスクからデータを受け取りそのタスクの待ちを解除します。
データも送信待ちタスクも無い場合、発行タスクは受信待ち行列につながれます。

+------+-----------+--------------------------------------------------------------------+
| 戻値 | > E_OK | > 正常終了 |
+======+===========+====================================================================+
| | > E_ID | > データキューIDが範囲外\* |
+------+-----------+--------------------------------------------------------------------+
| | > E_NOEXS | データキューが生成されていない |
+------+-----------+--------------------------------------------------------------------+
| | > E_CTX | > 非タスクコンテキストで、または、ディスパッチ禁止状態で待ち実行\* |
+------+-----------+--------------------------------------------------------------------+
| | > E_RLWAI | 待ち状態を強制解除された(待ちの間にrel_waiを受け付け) |
+------+-----------+--------------------------------------------------------------------+
| | > E_DLT | > 待ちの間にデータキューが削除された |
+------+-----------+--------------------------------------------------------------------+

補足 trcv_dtq(dtqid, p_data, TMO_FEVER)と同じです。

例

```c
#define ID_dtq1 1
TASK task1(void) {
    VP_INT data;

    :

        rcv_dtq(ID_dtq1, &data);

    :
}
```

### prcv_dtq

機能 データキューからの受信(ポーリング)

形式 ER prcv_dtq(ID dtqid, VP_INT \*p_data);

dtqid データキューID

p_data 受信したデータを格納する場所へのポインタ
解説 dtqidで指定されるデータキューから先頭のデータを受信します。送信待ちのタスクがある場合には、送信しようとしているデータをデータキューに入れて送信待ちタスクの待ちを解除します。データキューサイズが0の場合は、送信待ち行列の先頭のタスクからデータを受け取りそのタスクの待ちを解除します。
データも送信待ちタスクも無い場合、E_TMOUTエラーで戻ります。

戻値
E_OK 正常終了
E_ID データキューIDが範囲外\*
E_NOEXS データキューが生成されていない
E_TMOUT ポーリング失敗
補足 trcv_dtq(dtqid, p_data, TMO_POL)と同じです。

例

```c
#define ID_dtq1 1
TASK task1(void) {
    VP_INT data;

    :

        if (prcv_dtq(ID_dtq1, &data) == E_OK)

            :
}
```

### trcv_dtq

機能 データキュー待ち(タイムアウト有)
形式 ER trcv_dtq(ID dtqid, VP_INT \*p_data, TMO tmout); dtqid データキューID
p_data 受信したデータを格納する場所へのポインタ tmout タイムアウト値

解説 dtqidで指定されるデータキューから先頭のデータを受信します。送信待ちのタスクがある
場合には、送信しようとしているデータをデータキューに入れて送信待ちタスクの待ちを解除します。データキューサイズが0の場合は、送信待ち行列の先頭のタスクからデータを受け取りそのタスクの待ちを解除します。
tmoutで指定した時間が経過しても受信できない場合、タイムアウトエラーE_TMOUTとしてリターンします。tmout = TMO_POL (= 0)により待ちをおこなわない、すなわち prcv_dtq と同じ動作になります。tmout = TMO_FEVR (= -1)によりタイムアウトしない、すなわち rcv_dtqと同じになります。

戻値
E_OK 正常終了
E_ID データキューIDが範囲外\*
E_NOEXS データキューが生成されていない

E_CTX 非タスクコンテキストで、または、ディスパッチ禁止状態で待ち実行\*
E_RLWAI 待ち状態を強制解除された(待ちの間にrel_waiを受け付け)

E_DLT 待ちの間にデータキューが削除された
E_TMOUT タイムアウト

例

```c
#define ID_dtq1 1
TASK task1(void) {
    VP_INT data;
    ER ercd;

    :
        ercd = trcv_dtq(ID_dtq1, &data, 1000 / MSEC);
    if (ercd == E_TMOUT)

        :
}
```

### ref_dtq

機能 データキュー状態参照

形式 ER ref_dtq(ID dtqid, T_RDTQ \*pk_rdtq);

dtqid データキューID
pk_rdtq データキュー状態パケットを格納する場所へのポインタ

解説 dtqidで指定されたデータキューの状態を、\*pk_rdtqに返します。
データキュー状態パケットの構造は次の通りです。

```c
typedef struct t_rdtq {
    ID stskid;  /* 送信待ちタスクIDまたはTSK_NONE  */
    ID rtskid;  /* 受信待ちタスクIDまたはTSK_NONE */
    UINT sdtqcnt; /* データキューに入っているデータ数 */
} T_RDTQ;
```

stskid, rtskidには、待ちタスクがある場合、その先頭の待ちタスクID番号が入ります。
待ちタスクがない場合は、TSK_NONEが返ります。

戻値
E_OK 正常終了
E_ID データキューIDが範囲外
E_NOEXS データキューが生成されていない

例

```c
#define ID_dtq1 1
TASK task1(void) {
    T_RDTQ rdtq;

    :
        ref_dtq(ID_dtq1, &rdtq);
    if (rdtq.sdtqcnt != 0)

        :
}
```

5.7 同期・通信機能(メールボックス)

### cre_mbx

機能 メールボックス生成
形式 ER cre_mbx(ID mbxid, const T_CMBX \*pk_cmbx); mbxid メールボックスID
pk_cmbx メールボックス生成情報パケットへのポインタ

解説 mbxidで指定されたメールボックスを生成します。すなわち、システムメモリから、メール
ボックス管理ブロックを動的に割り当てます。
メールボックス生成情報パケットの構造は次の通りです。

```c
typedef struct t_cmbx

{
    ATR mbxatr;   /* メールボックス属性 */
    PRI maxmpri;  /* メッセージ優先度の最大値 */
    VP mprihd;    /* メッセージ待ち行列先頭アドレス */
    B* name;      /* メールボックス名へのポインタ（省略可） */
} T_CMBX;
```

メールボックス属性mbxatrには次の値を入れてください。
TA_TFIFO 受信待ちタスク行列は先着順(FIFO)
TA_TPRI 受信待ちタスク行列はタスク優先度順
TA_MFIFO メッセージのキューイングは先着順(FIFO)
TA_MPRI メッセージのキューイングはメッセージ優先度順
mbxatrにTA_MPRIが指定された場合にはメッセージ優先度別のメッセージ待ち行列を作ります。メッセージ待ち行列ヘッダのサイズはTSZ_MPRIHDマクロにより知ることができます。
ユーザ領域に待ち行列ヘッダを用意する場合はTSZ_MPRIHDで得たバイト数のメモリ領域を確保して先頭アドレスをmprihdに設定してください。mprihdにNULL を設定した場合、行列ヘッダはシステムメモリに確保されます。
maxmpriには、メッセージ優先度の 大値を設定してください。大きな値を指定するとメモリ消費量が多くなるので注意してください。メッセージ優先度はタスク優先度と同様に1 が 優先で、値が大きくなるほど優先度が低くなります。
nameは対応デバッガ用ですので、名前を指定しない場合には\"\"か NULLを入れてください。
この構造体を初期値付きで定義する場合には、nameを省略しても構いません。

+----------+------------+----------------------------------------------+
| 戻値 | E_OK | 正常終了 |
+==========+============+==============================================+
| | E_ID | メールボックスIDが範囲外\* |
+----------+------------+----------------------------------------------+
| | E_OBJ | メールボックスが既に生成されている |
+----------+------------+----------------------------------------------+
| | E_CTX | 割込みハンドラから発行\* |
+----------+------------+----------------------------------------------+
| | E_SYS | > 管理ブロック用のメモリが確保できない\*\* |
+----------+------------+----------------------------------------------+

例

```c
#define ID_mbx1 1
const T_CMBX cmbx1 = {TA_TFIFO | TA_MFIFO, 1, NULL};
TASK task1(void) {
    ER ercd;

    :

        ercd = cre_mbx(ID_mbx1, &cmbx1);

    :
}
```

### acre_mbx

機能 メールボックス生成(ID自動割り当て)

形式 ER_ID acre_mbx(const T_CMBX \*pk_cmbx);
pk_cmbx メールボックス生成情報パケットへのポインタ
解説 未生成メールボックスの ID を、大きな方から検索して割り当てます。メールボックス ID が割り当てられない場合は、E_NOIDエラーを返します。それ以外は、cre_mbxと同じです。

戻値 正の値 割り当てられたメールボックスID

E_NOID メールボックスIDが不足

E_CTX 割込みハンドラから発行\*

E_SYS 管理ブロック用のメモリが確保できない\*\*

例

```c
ID ID_mbx1;
const T_CMBX cmbx1 = {TA_TFIFO | TA_MFIFO, 1, NULL};
TASK task1(void) {
    ER_ID ercd;

    :
        ercd = acre_mbx(&cmbx1);
    if (ercd > 0)

        ID_mbx1 = ercd;
}
```

### del_mbx

機能 メールボックス削除

形式 ER del_mbx(ID mbxid);
mbxid メールボックスID

解説 mbxidで指定されたメールボックスを削除します。すなわち、メールボックス管理ブロック
等の生成時に確保したメモリをシステムメモリへ解放します。
このメールボックスに対して、メッセージ受信を待っているタスクがあった場合、このタスクの待ちを解除します。待ち解除されたタスクへは、削除されたことを示すE_DLTエラーが返ります。
キューイングされたメッセージがあると、それは失われます。メモリプールからメッセージを動的に確保していた場合にはメールボックス削除の前に、prcv_mbxでメッセージを読み出して、適切なメモリプールへの返却をしてください。ユーザプログラムが確保した領域を自動的にOSが開放することはできないので、いわゆるメモリリークが発生します。

戻値
E_OK 正常終了
E_ID メールボックスID が範囲外\*
E_NOEXS メールボックスが生成されていない

E_CTX 割込みハンドラから発行\*

例

```c
#define ID_mbx1 1
TASK task1(void) {
    :

        del_mbx(ID_mbx1);

    :
}
```

### snd_mbx

機能 メールボックスへ送信
形式 ER snd_mbx(ID mbxid, T_MSG \*pk_msg); mbxid メールボックスID

pk_msg メッセージパケットへのポインタ

解説 mbxidで指定されるメールボックスを使って、pk_msgで指し示されるメッセージを送信し
ます。メッセージの内容はコピーされずに、受信側にはポインタ(pk_msgの値)のみが渡されます。OSはメッセージのサイズを関知しません。
このメールボックスに対して待っているタスクがなければ、メッセージをメールボックスのメッセージキューにつないで、即リターンします。
このメールボックスに対して待っているタスクがあれば、待ち行列の先頭タスクへメッ
セージを渡して、その待ちを解除します。すなわち、WAITING状態からREADY状態へ遷移させます(現在のRUNNINGタスクより高優先ならRUNNING状態へ、WAITING-SUSPENDED状態だったらSUSPENDED状態へ遷移)。
標準のメッセージパケットとして定義されているT_MSG型の構造を示します。

```c
typedef struct t_msg {
    struct t_msg* next; /* 次のメッセージへのポインタ */
    VB msgcont[MSGS];   /* メッセージの内容 */
} T_MSG;
```

メッセージをキューイングするために、メッセージヘッダ部nextを、OSがポインタとして使います。ユーザーが実際にメッセージを入れることができるのは、メッセージヘッダの後の部分msgcontからとなります。
T_MSG型は、システムコール関数のプロトタイプ宣言のために定義されており、ユーザープログラムでは、通常、これを使用しません。用途に応じたメッセージの型を定義し、システムコールへ渡す際に、(T_MSG \*)や(T_MSG\*\*)でキャストしてください。メッセージ優先度を使う場合は、nextに続けてINT msgpri;を設けてください(次々ページ例2参照)。
既にキューイングされているメッセージを再度snd_mbxした場合もOSが使用する領域が破壊されますので多重送信はしないでください。

戻値
E_OK 正常終了
E_ID メールボックスIDが範囲外\*
E_NOEXS メールボックスが生成されていない

補足 メッセージ長MSGSは標準で16バイトですが、#include "kernel.h"の前でMSGSを別の値
に#defineできます(例1)。
それよりも、用途に応じてmsgcontの部分を変更したメッセージパケット構造体を、ユーザーが独自定義する方がよいでしょう(例2)。メールボックス生成時に、メッセージ優先度順のキューイングを指定しない場合、msgpriメンバーは省略できます。メッセージはコピーされずにキューイングされるので、各メッセージはメモリプール等から取得した別々の領域へ格納してください。グローバルな1個の変数を使用する場合は、2つ以上キューイングすると多重送信問題が発生します。
また、関数の中で自動変数として確保した領域は、その関数から抜けると開放されてしまうため、メッセージ領域としては使用禁止です。

例1

```c
#define MSGS 4
#include "kernel.h"
#define ID_mbx 1
#define ID_mpf 1
TASK task1(void) {
    T_MSG* msg;

    :
        get_mpf(ID_mpf, &msg); /* メッセージ領域を得る */
    msg->msgcont[0] = 2;
    msg->msgcont[1] = 0;
    msg->msgcont[2] = 3;
    msg->msgcont[3] = 0;

    snd_mbx(ID_mbx, msg); /* メールボックスへ送信 \*/

    :
}
```

例2

```c
typedef struct t_mymsg {
    struct t_mymsg* next; /* 次のメッセージへのポインタ(注) \*/
    INT msgpri;           /* メッセージ優先度(使わない場合は定義不要) \*/
    H fncd;
    H data;
} T_MYMSG;
#define ID_mbx 1
#define ID_mpf 1
TASK task1(void) {
    T_MYMSG* msg;

    :
        get_mpf(ID_mpf, &msg); /* メッセージ領域を得る */
    msg->msgpri = 1;           /* メッセージ優先度(使わない場合は設定不要) */
    msg->fncd = 2;
    msg->data = 3;
    snd_mbx(ID_mbx, (T_MSG*)msg); /* メールボックスへ送信 \*/

    :
}
```

(注)FARポインタのある処理系では、struct t_mymsg PFAR \*next;の様に記述する必要があります。

### rcv_mbx

機能 メールボックスから受信
形式 ER rcv_mbx(ID mbxid, T_MSG \*\*ppk_msg); mbxid メールボックスID

ppk_msg メッセージパケットへのポインタを格納する場所へのポインタ

解説 mbxidで指定されたメールボックスからメッセージを受け取ります。メッセージ内容はコ
ピーされずに、ポインタのみを\*ppk_msgへ受け取ります。
すでにメッセージがキューイングされている場合、先頭のメッセージへのポインタを \*ppk_msgに入れ、即リターンします。メールボックスにまだメッセージが到着していない
場合、本システムコールの発行タスクは、そのメールボックスの待ち行列につながれます。

戻値
E_OK 正常終了
E_ID メールボックスIDが範囲外\*
E_NOEXS メールボックスが生成されていない

E_CTX 非タスクコンテキストで、または、ディスパッチ禁止状態で待ち実行\*
E_RLWAI 待ち状態を強制解除された(待ちの間にrel_waiを受け付け)

E_DLT 待ちの間にメールボックスが削除された

注意 ppk_msg は、ポインタへのポインタです。

補足 trcv_mbx(ppk_msg, mbxid, TMO_FEVR)と同じです
送信側タスクがメッセージ領域をメモリプールから獲得していた場合、受信側タスクでは、メッセージの参照が終わったら、その領域を同じメモリプールへ返却しなければなりません。

例

```c
#define ID_mbx1 1
#define ID_mpf1 1
TASK task2(void) {
    T_MYMSG* msg;

    :

        rcv_mbx(ID_mbx1, (T_MSG**)&msg);

    :

        rel_mpf(ID_mpf1, (VP)msg); /* メッセージをメモリプールへ返却 \*/
}
```

### prcv_mbx

機能 メールボックスから受信(ポーリング)

形式 ER prcv_mbx(ID mbxid, T_MSG \*\*ppk_msg);
mbxid メールボックスID
ppk_msg メッセージパケットへのポインタを格納する場所へのポインタ
解説 mbxidで指定されたメールボックスからメッセージを受け取ります。メッセージ内容はコピーされずに、ポインタのみを\*ppk_msgへ受け取ります。
すでにメッセージがキューイングされている場合、先頭のメッセージへのポインタを \*ppk_msgに入れ、即リターンします。メールボックスにまだメッセージが到着していない場合は、待ち状態に入らずに、E_TMOUTエラーで即リターンします。

戻値
E_OK 正常終了
E_ID メールボックスIDが範囲外\*
E_NOEXS メールボックスが生成されていない
E_TMOUT ポーリング失敗
注意 ppk_msgは、ポインタへのポインタです。
補足 trcv_mbx(ppk_msg, mbxid, ppk_msg, TMO_POL)と同じです。

例

```c
#define ID_mbx1 1
TASK task1(void) {
    T_MYMSG* msg;
    ER ercd;

    :
        ercd = prcv_mbx(ID_mbx1, (T_MSG**)&msg);
    if (ercd == E_OK)

        :
}
```

### trcv_mbx

機能 メールボックスから受信(タイムアウト有)
形式 ER trcv_mbx(ID mbxid, T_MSG \*\*ppk_msg, TMO tmout); mbxid メールボックスID
ppk_msg メッセージパケットへのポインタを格納する場所へのポインタ tmout タイムアウト値

解説 mbxidで指定されたメールボックスからメッセージを受け取ります。メッセージ内容はコ
ピーされずに、ポインタのみを\*ppk_msgへ受け取ります。
すでにメッセージがキューイングされている場合、先頭のメッセージへのポインタを
\*ppk_msgに入れ、即リターンします。メールボックスにまだメッセージが到着していない場合、本システムコールの発行タスクは、そのメールボックスの待ち行列につながれます。
tmoutで指定した時間が経過してもメッセージが来ない場合、タイムアウトエラーE_TMOUT としてリターンします。tmout = TMO_POL(= 0)により待ちをおこなわない、すなわち prcv_mbxと同じ動作になります。tmout = TMO_FEVR(= -1)によりタイムアウトしない、すなわちrcv_mbxと同じ動作になります。

戻値
E_OK 正常終了
E_ID メールボックスIDが範囲外\*
E_NOEXS メールボックスが生成されていない

E_CTX 非タスクコンテキストで、または、ディスパッチ禁止状態で待ち実行\*
E_RLWAI 待ち状態を強制解除された(待ちの間にrel_waiを受け付け)

E_DLT 待ちの間にメールボックスが削除された
E_TMOUT タイムアウト

注意 ppk_msgは、ポインタへのポインタです。

例

```c
#define ID_mbx1 1
TASK task1(void) {
    T_MYMSG* msg;
    ER ercd;

    :
        ercd = trcv_mbx(ID_mbx1, (T_MSG**)&msg, 1000 / MSEC);
    if (ercd == E_OK)

        :
}
```

### ref_mbx

機能 メールボックス状態参照

形式 ER ref_mbx(ID mbxid, T_RMBX \*pk_rmbx);
mbxid メールボックスID
pk_rmbx メールボックス状態パケットを格納する場所へのポインタ
解説 mbxidで指定されたメールボックスの状態を、\*pk_rmbxに返します。メールボックス状態パケットの構造は次の通りです。

```c
typedef struct t_rmbx

{
    ID wtskid;      /* 待ちタスクIDまたはTSK_NONE */
    T_MSG* pk_msg; /* 先頭の送信待ちメッセージアドレスまたはNULL */
} T_RMBX;
```

wtskidには、待ちタスクがある場合、その先頭の待ちタスクのID番号が返ります。待ちタスクがない場合は、TSK_NONEが返ります。

戻値
E_OK 正常終了
E_ID メールボックスIDが範囲外
E_NOEXS メールボックスが生成されていない

例

```c
#define ID_mbx1 1
TASK task1(void) {
    T_RMBX rmbx;

    :
        ref_mbx(ID_mbx1, &rmbx);
    if (rmbx.pk_msg != NULL)

        :
}
```

5.8 拡張同期・通信機能(ミューテックス)

### cre_mtx

機能 ミューテックス生成
形式 ER cre_mtx(ID mtxid, const T_CMTX \*pk_cmtx); mtxid ミューテックスID
pk_cmtx ミューテックス生成情報パケットへのポインタ

解説 mtxidで指定されたミューテックスを生成します。すなわち、システムメモリから、ミュー
テックス管理ブロックを動的に割り当てます。
定義情報パケットをROM以外に置いた場合、すなわちconstを付けなかった場合、定義情報パケットはシステムメモリにコピーされます。
ミューテックス生成情報パケットの構造は次の通りです。

```c
typedef struct t_cmtx

{
    ATR mtxatr;  /* ミューテックス属性 */
    PRI ceilpri; /* 優先度上限プロトコルで使用する上限優先度 */
    B* name;     /* ミューテックス名へのポインタ（省略可） */
} T_CMTX;
```

ミューテックス属性mtxatrには次の値を入れてください。

+----------------------+-----------------------------------------------+
| TA_TFIFO | > 待ちタスク行列は先着順(FIFO) |
+======================+:==============================================+
| TA_TPRI | > 待ちタスク行列はタスク優先度順 |
+----------------------+-----------------------------------------------+
| TA_INHERIT | 優先度継承プロトコルを使用 |
+----------------------+-----------------------------------------------+
| TA_CEILING | 優先度上限プロトコルを使用 |
+----------------------+-----------------------------------------------+
TA_INHERIT, TA_CEILINGいずれかを指定しない場合ミューテックスは基本的にバイナリセマフォと同一の機能を提供します。ただし、ミューテックスの場合タスクがロックしたまま終了した場合自動的にアンロックされます。
TA_INHERITを指定した場合、優先度継承プロトコルを使ってタスクの現在優先度を操作して優先度逆転を防ぎます。ミューテックスをロック中に、優先度の高いタスクがそのミューテックスをロックしようとしてWAITING状態になると、ロック中のタスクの優先度が待ち行列にあるタスクのうちもっとも優先度の高いタスクの優先度と同一になります。このようにすることで中間の優先度を持つタスクがミューテックスをロック中のタスクをプリエンプトして間接的にそのミューテックスをロック待ちしているより優先度の高いタスクをブロックすることを防ぎます。
TA_CEILINGを指定した場合、優先度上限プロトコルを使ってタスクの現在優先度を操作します。優先度上限プロトコルでは、生成情報で指定されたceilpriを使用します。タスクがTA_CEILING指定されたミューテックスをロックするとそのタスクの現在優先度が
ceilpriで指定した値になります。ceilpri にそのミューテックスを共有するタスクの中で高の優先度を持つタスクの優先度値を設定することで、優先度継承プロトコルと同様の効果を得ることができます。
nameは対応デバッガ用ですので、名前を指定しない場合には\"\"か NULL を入れてください。
この構造体を初期値付きで定義する場合には、name を省略しても構いません。

+----------+------------+----------------------------------------------+
| 戻値 | E_OK | 正常終了 |
+==========+============+==============================================+
| | E_ID | ミ ューテックスIDが範囲外\* |
+----------+------------+----------------------------------------------+
| | E_OBJ | ミューテックスが既に生成されている |
+----------+------------+----------------------------------------------+
| | E_CTX | 割込みハンドラから発行\* |
+----------+------------+----------------------------------------------+
| | E_SYS | > 管理ブロック用のメモリが確保できない\*\* |
+----------+------------+----------------------------------------------+

例

```c
#define ID_mtx1 1
const T_CMTX cmtx1 = {TA_INHERIT, 0};
TASK task1(void) {
    ER ercd;

    :

        ercd = cre_mtx(ID_mtx1, &cmtx1);

    :
}
```

### acre_mtx

機能 ミューテックス生成(ID自動割り当て)

形式 ER_ID acre_mtx(const T_CMTX \*pk_cmtx);
pk_cmtx ミューテックス生成情報パケットへのポインタ
解説 未生成ミューテックスの ID を、大きな方から検索して割り当てます。ミューテックス ID が割り当てられない場合は、E_NOIDエラーを返します。それ以外は、cre_mtxと同じです。

戻値 正の値 割り当てられたミューテックスID

E_NOID ミューテックスIDが不足

E_CTX 割込みハンドラから発行\*

E_SYS 管理ブロック用のメモリが確保できない\*\*

例

```c
ID ID_mtx1;
const T_CMTX cmtx1 = {TA_TFIFO, 0};
TASK task1(void) {
    ER_ID ercd;

    :
        ercd = acre_mtx(&cmtx1);
    if (ercd > 0) ID_mtx1 = ercd;

    :
}
```

### del_mtx

# 機能 ミューテックス削除

形式 ER del_mtx(ID mtxid);

mtxid ミューテックスID

解説 mtxidで指定されたミューテックスを削除します。すなわち、ミューテックス管理ブロック
をシステムメモリへ解放します。
このミューテックスに対して待っているタスクがあった場合、タスクの待ちを解除します。
待ち解除されたタスクへは、削除されたことを示すE_DLTエラーが返ります。

戻値
E_OK 正常終了
E_ID ミューテックスIDが範囲外\*
E_NOEXS ミューテックスが生成されていない

E_CTX 割込みハンドラから発行\*

例

```c
#define ID_mtx1 1
TASK task1(void) {
    :

        del_mtx(ID_mtx1);

    :
}
```

### unl_mtx

機能 ミューテックスロック解除

形式 ER unl_mtx(ID mtxid);

mtxid ミューテックスID

解説 mtxidで指定されたミューテックスをロック解除する。
このミューテックスに対して待っているタスクがあれば、待ち行列の先頭タスクの待ちを解除します。すなわち、WAITING状態からREADY状態へ遷移させます(現在のRUNNINGタスクより高優先ならRUNNING状態へ、WAITING-SUSPENDED状態だったらSUSPENDED状態へ遷
移)。そして、ミューテックスをロック状態にします。
ロック待ちしているタスクが無い場合ロックを解除します。
自タスクがロックしていないミューテックスをロック解除することはできません。

戻値
E_OK 正常終了
E_ID ミューテックスIDが範囲外\*
E_NOEXS ミューテックスが生成されていない
E_ILUSE 対象ミューテックスをロックしていない

### loc_mtx

# 機能 ミューテックス資源獲得

形式 ER loc_mtx(ID mtxid);

mtxid ミューテックスID

解説 mtxidで指定されたミューテックスがロックされていない場合はロック状態にします。対象
ミューテックスが既にロックされている場合は自タスクを待ち行列につなぎロック待ち状態にします。
自タスクがすでに対象ミューテックスをロックしている場合は、すなわち多重ロックしようとするとE_ILUSEエラーを返します。また、TA_CEILING指定されたミューテックスを上限優先度より高いベース優先度を持ったタスクがロックしようとした場合も E_ILUSE エラーを返します。

戻値
E_OK 正常終了
E_ID ミューテックスIDが範囲外\*
E_NOEXS ミューテックスが生成されていない

E_CTX 非タスクコンテキストで、または、ディスパッチ禁止状態で待ち実行\*
E_RLWAI 待ち状態を強制解除された(待ちの間にrel_waiを受け付け)

E_DLT 待ちの間にミューテックスが削除された
E_ILUSE 多重ロック、上限優先度違反

補足 tloc_mtx(mtxid, TMO_FEVR)と同じです。

例

```c
#define ID_mtx1 1
TASK task1(void) {
    :

        loc_mtx(ID_mtx1);

    :

        unl_mtx(ID_mtx1);

    :
}
```

### ploc_mtx

# 機能 ミューテックス資源獲得(ポーリング)

形式 ER ploc_mtx(ID mtxid);

mtxid ミューテックスID
解説 mtxidで指定されたミューテックスがロックされていない場合はロック状態にします。対象ミューテックスが既にロックされている場合は E_TMOUT エラーで返ります。その他は、 loc_mtxと同様です。

戻値
E_OK 正常終了
E_ID ミューテックスID が範囲外\*
E_NOEXS ミューテックスが生成されていない
E_ILUSE 多重ロック、上限優先度違反
E_TMOUT ポーリング失敗
補足 tloc_mtx(mtxid, TMO_POL)と同じです。
例

```c
if (ploc_mtx(ID_mtx1) == E_OK) {
    :

        unl_mtx(ID_mtx1);

    :
}
```

### tloc_mtx

機能 ミューテックス資源獲得(タイムアウト有)
形式 ER tloc_mtx(ID mtxid, TMO tmout); mtxid ミューテックスID tmout タイムアウト値

解説 mtxidで指定されたミューテックスがロックされていない場合はロック状態にします。対象
ミューテックスが既にロックされている場合は自タスクを待ち行列につなぎロック待ち状態にします。tmoutで指定した時間が経過すると、タイムアウトエラーE_TMOUTとしてリターンします。その他は、loc_mtxと同様です。
tmout = TMO_POL(= 0)により待ちをおこなわない、すなわち pol_mtx と同じ動作になります。tmout = TMO_FEVR(= -1)によりタイムアウトしない、すなわち loc_mtx と同じ動作になります。

戻値
E_OK 正常終了
E_ID ミューテックスIDが範囲外\*
E_NOEXS ミューテックスが生成されていない

E_CTX 非タスクコンテキストで、または、ディスパッチ禁止状態で待ち実行\*
E_RLWAI 待ち状態を強制解除された(待ちの間にrel_locを受け付け)

E_DLT 待ちの間にミューテックスが削除された
E_ILUSE 多重ロック、上限優先度違反
E_TMOUT タイムアウト

例

```c
#define ID_mtx1 1
TASK task1(void) {
    ER ercd;

    :
        ercd = tloc_mtx(ID_mtx1, 100 / MSEC);
    if (ercd == E_OK)

        :
}
```

### ref_mtx

# 機能 ミューテックス状態参照

形式 ER ref_mtx(ID mtxid, T_RMTX \*pk_rmtx); mtxid ミューテックスID
pk_rmtx ミューテックス状態パケットを格納する場所へのポインタ

解説 mtxid で指定されたミューテックスの状態を、\*pk_rmtx に返します。
ミューテックス状態パケットの構造は次の通りです。

```c
typedef struct t_rmtx

{
    ID htskid; /* ロックしているタスクのタスクID またはTSK_NONE */
    ID wtskid; /* ロック待ちしているタスクのタスクID またはTSK_NONE */
} T_RMTX;
```

htskidには、対象ミューテックスをロックしているタスクがあればそのタスクID番号が返ります。無い場合には、TSK_NONEが返ります。
wtskidには、待ちタスクがある場合、その先頭の待ちタスクのID番号が返ります。待ちタスクがない場合は、TSK_NONEが返ります。

戻値
E_OK 正常終了
E_ID ミューテックスIDが範囲外
E_NOEXS ミューテックスが生成されていない

例

```c
#define ID_mtx1 1
TASK task1(void) {
    T_RMTX rmtx;

    :

        ref_mtx(ID_mtx1, &rmtx);

    :
}
```

5.9 拡張同期・通信機能(メッセージバッファ)

### cre_mbf

機能 メッセージバッファ生成
形式 ER cre_mbf(ID mbfid, const T_CMBF \*pk_cmbf); mbfid メッセージバッファID
pk_cmbf 生成情報パケットへのポインタ

解説 mbfidで指定されたメッセージバッファを生成します。すなわち、システムメモリからメッ
セージバッファ管理ブロックを動的に割り当てます。
生成情報パケットをROM以外に置いた場合、すなわちconstを付けなかった場合、生成情報パケットはシステムメモリにコピーされます。
メッセージバッファ生成情報パケットの構造は次の通りです。

```c
typedef struct t_cmbf

{
    ATR mbfatr;  /*  メッセージバッファ属性                     */
    UINT maxmsz; /*  メッセージの 大長(バイト数)                */
    SIZE mbfsz;  /*  リングバッファの総サイズ(バイト数)         */
    VP mbf;      /* リングバッファのアドレス                    */
    B* name;     /*  メッセージバッファ名へのポインタ（省略可） */
} T_CMBF;        /*                                             */
```

メッセージバッファ属性mbfatrには次の値を入れてください。

TA_TFIFO 送信待ちタスク行列は先着順(FIFO)

TA_TPRI 送信待ちタスク行列はタスク優先度順 TA_TPRIR 受信待ちタスク行列はタスク優先度順
mbfatrにTA_TPRIRを指定しない場合受信待ちタスク行列は先着順(FIFO)になります。
リングバッファ領域をユーザプログラムで確保した場合には、その先頭アドレスをmbfに設定してください。この場合OSがメッセージを管理するためバッファの一部を使用するので、全てをユーザープログラムで使用することは出来ません。msgszバイト(msgsz \> 1)のメッセージをmsgcnt個格納するために確保すべきサイズはTSZ_MBF(msgcnt, msgsz)マクロによって、取得できます。ただし、メッセージサイズを1バイト(msgsz = 1)とした場合はmsgszバイトの領域を必要とします。すなわちOSによるオーバーヘッドはありません。 mbfがNULLの場合、メモリプール用メモリから動的にmbufszで指定されたサイズだけリングバッファ領域を確保します。
mbfsz に0を設定することも可能です。この場合リングバッファは必要ありません。この時は、タスク間で同期を取って直接データを渡すようになります。
nameは対応デバッガ用ですので、名前を指定しない場合には\"\"か NULL を入れてください。
この構造体を初期値付きで定義する場合には、nameを省略しても構いません。

+----------+------------+----------------------------------------------+
| 戻値 | E_OK | > 正常終了 |
+==========+============+==============================================+
| | E_ID | メッセージバッファID が範囲外\* |
+----------+------------+----------------------------------------------+
| | E_OBJ | > メッセージバッファが既に生成されている |
+----------+------------+----------------------------------------------+
| | E_PAR | パラメータエラー(maxmsz = 0)\* |
+----------+------------+----------------------------------------------+
| | E_CTX | 割込みハンドラから発行\* |
+----------+------------+----------------------------------------------+
| | E_SYS | > 管理ブロック用のメモリが確保できない\*\* |
+----------+------------+----------------------------------------------+
E_NOMEM リングバッファ用のメモリが確保できない\*\*

例

```c
#define ID_mbf1 1
const T_CMBF cmbf1 = {TA_TFIFO, 32, 512, NULL};
TASK task1(void) {
    ER ercd;

    :

        ercd = cre_mbf(ID_mbf1, &cmbf1);

    :
}
```

### acre_mbf

機能 メッセージバッファ生成(ID自動割り当て)

形式 ER_ID acre_mbf(const T_CMBF \*pk_cmbf);
pk_cmbf メッセージバッファ生成情報パケットへのポインタ
解説 未生成メッセージバッファのIDを、大きな方から検索して割り当てます。メッセージバッファIDが割り当てられない場合は、E_NOIDエラーを返します。それ以外は、cre_mbfと同じです。

戻値 正の値 割り当てられたメッセージバッファID

E_NOID メッセージバッファIDが不足

E_PAR パラメータエラー(maxmsz = 0)\*

E_CTX 割込みハンドラから発行\*

E_SYS 管理ブロック用のメモリが確保できない\*\*
E_NOMEM リングバッファ用のメモリが確保できない\*\*

例

```c
ID ID_mbf1;
const T_CMBF cmbf1 = {TA_TFIFO, 32, 512, NULL};
TASK task1(void) {
    ER_ID ercd;

    :
        ercd = acre_mbf(&cmbf1);
    if (ercd > 0)

        ID_mbf1 = ercd;
}
```

### del_mbf

機能 メッセージバッファ削除

形式 ER del_mbf(ID mbfid);
mbfid ッセージバッファID

解説 mbfidで指定されたメッセージバッファを削除します。すなわち、メッセージバッファ管理
ブロックをシステムメモリへ解放し、OSが確保した場合はリングバッファ領域をメモリプール用メモリへ解放します。
このメッセージバッファに対して、メッセージ送信やメッセージ受信を待っているタスクがあった場合、このタスクの待ちを解除します。待ち解除されたタスクへは、削除されたことを示すE_DLTエラーが返ります。

戻値
E_OK 正常終了
E_ID メッセージバッファIDが範囲外\*
E_NOEXS メッセージバッファが生成されていない

E_CTX 割込みハンドラから発行\*

例

```c
#define ID_mbf1 1
TASK task1(void) {
    :

        del_mbf(ID_mbf1);

    :
}
```

### snd_mbf

機能 メッセージバッファへ送信
形式 ER snd_mbf(ID mbfid, VP msg, UINT msgsz); mbfid メッセージバッファID

msg 送信メッセージへのポインタ

msgsz 送信メッセージのサイズ(バイト数)

解説 mbfidで指定されたメッセージバッファを使って、msgとmsgszで示されるメッセージを送
信します。
このメッセージバッファで受信を待っているタスクがある場合、受信待ち行列の先頭タスクの受信バッファへメッセージをコピーし、そのタスクの待ちを解除します。このメッセージバッファで受信を待っているタスクがない場合、メッセージをメッセージバッファが使用するリングバッファへコピーします。ただし、リングバッファに空きがなかった場合は、このシステムコールを発行したタスクの方が、送信待ち状態となります。
snd_mbf, psnd_mbf, tsnd_mbfで、サイズがmsgszのメッセージをキューイングするためには、リングバッファに、msgsz + 2バイト(メッセージサイズを示すヘッダの分)の空きが必要です。ただし、メッセージバッファ生成時に指定したメッセージの 大長maxmszが1バイトの場合に限って、+2バイトのヘッダ領域が不要となります。

戻値
E_OK 正常終了
E_PAR メッセージのサイズが範囲外(msgsz = 0, msgsz \> 生成情報のmaxmsz)\*

E_ID メッセージバッファIDが範囲外\*
E_NOEXS メッセージバッファが生成されていない

E_CTX 非タスクコンテキストから発行、または、ディスパッチ禁止状態で待ち実行\*
E_RLWAI 待ち状態強制解除された

E_DLT 待ちの間にメッセージバッファが削除された

補足 tsnd_mbf(mbfid, msg, msgsz, TMO_FEVR)と同じです。

例

```c
#define ID_mbf1 1
TASK task1(void) {
    H cmd = 0x0012;

    :

        snd_mbf(ID_mbf1, (VP)&cmd, sizeof cmd);

    :
}
```

### psnd_mbf

機能 メッセージバッファへ送信(ポーリング)
形式 ER psnd_mbf(ID mbfid, VP msg, UINT msgsz); mbfid メッセージバッファID msg 送信メッセージへのポインタ msgsz 送信メッセージのサイズ(バイト数)
解説 mbfidで指定されたメッセージバッファを使って、msgとmsgszで示されるメッセージを送信します。
このメッセージバッファで受信を待っているタスクがある場合、受信待ち行列の先頭タスクの受信バッファへメッセージをコピーし、そのタスクの待ちを解除します。このメッセージバッファで受信を待っているタスクがない場合、メッセージをメッセージバッファ内部のリングバッファへコピーします。リングバッファに空きがなかった場合は、待ち状態に入らずに、E_TMOUTを返します。

戻値
E_OK 正常終了
E_PAR メッセージのサイズが範囲外(msgsz = 0, msgsz \> 生成情報のmaxmsz)\*

E_ID メッセージバッファIDが範囲外\*
E_NOEXS メッセージバッファが生成されていない
E_TMOUT ポーリング失敗
補足 tsnd_mbf(mbfid, msg, msgsz, TMO_POL)と同じです。

例

```c
#define ID_mbf2 2
TASK task1(void) {
    B msg[16];

    :
        strcpy(msg, "Hello");
    if (psnd_mbf(ID_mbf2, (VP)msg, strlen(msg)) != E_OK)

        :
}
```

### tsnd_mbf

機能 メッセージバッファへ送信(タイムアウト有)
形式 ER tsnd_mbf(ID mbfid, VP msg, UINT msgsz, TMO tmout); mbfid メッセージバッファID

msg 送信メッセージへのポインタ
msgsz 送信メッセージのサイズ(バイト数) tmout タイムアウト値

解説 mbfidで指定されたメッセージバッファを使って、msgとmsgszで示されるメッセージを送信
します。
このメッセージバッファで受信を待っているタスクがある場合、受信待ち行列の先頭タスクの受信バッファへメッセージをコピーし、そのタスクの待ちを解除します。このメッセージバッファで受信を待っているタスクがない場合、メッセージをメッセージバッファ内部のリングバッファへコピーします。ただし、リングバッファに空きがなかった場合は、このシステムコールを発行したタスクの方が、送信待ち状態となります。
tmoutで指定した時間が経過しても空きがない場合、タイムアウトエラーE_TMOUTとしてリターンします。tmout = TMO_POL(= 0)により待ちをおこなわない、すなわちpsnd_mbfと同じ動作になります。tmout = TMO_FEVR(= -1)によりタイムアウトしない、すなわちsnd_mbf と同じ動作になります。

戻値
E_OK 正常終了
E_PAR メッセージのサイズが範囲外(msgsz = 0 ,msgsz \> 生成情報のmaxmsz)\*

E_ID メッセージバッファIDが範囲外\*
E_NOEXS メッセージバッファが生成されていない

E_CTX 非タスクコンテキストから発行、または、ディスパッチ禁止状態で待ち実行\*
E_RLWAI 待ち状態を強制解除された(待ちの間にrel_waiを受け付け)

E_DLT 待ちの間にメッセージバッファが削除された
E_TMOUT タイムアウト

例

```c
#define ID_mbf2 2
TASK task1(void) {
    B* res = "Hello";
    ER ercd;

    :
        ercd = tsnd_mbf(ID_mbf2, (VP)res, 5, 1000 / MSEC);
    if (ercd = E_TMOUT)

        :
}
```

### rcv_mbf

機能 メッセージバッファから受信
形式 ER_UINT rcv_mbf(ID mbfid, VP msg); mbfid メッセージバッファID

msg 受信メッセージを格納する場所へのポインタ

解説 mbfidで指定されたメッセージバッファを使ってメッセージを受信します。受信したメッ
セージは、msgへコピーされます。受信したメッセージのサイズ(msgsz)は、関数の戻値として返されます。
msgで指し示される領域は、メッセージバッファ生成時に指定したメッセージの 大長 maxmsz以上としてください。
メッセージバッファにまだメッセージが到着していない場合、本システムコールの発行タスクは、そのメッセージバッファの受信待ち行列につながれます。

戻値 正の値 受信メッセージバイト数

E_ID メッセージバッファIDが範囲外\*
E_NOEXS メッセージバッファが生成されていない

E_CTX 非タスクコンテキストから発行、または、ディスパッチ禁止状態で待ち実行\*
E_RLWAI 待ち状態を強制解除された(待ちの間にrel_waiを受け付け)

E_DLT 待ちの間にメッセージバッファが削除された

補足 trcv_mbf(mbfid, msg, TMO_FEVR)と同じです。

例

```c
#define ID_mbf1 1
TASK task1(void) {
    H cmd;
    ER_UINT msgsz;

    :

        msgsz = rcv_mbf(ID_mbf1, (VP)&cmd);

    :
}
```

### prcv_mbf

機能 メッセージバッファから受信(ポーリング)
形式 ER_UINT prcv_mbf(ID mbfid, VP msg); mbfid メッセージバッファID msg 受信メッセージを格納する場所へのポインタ
解説 mbfidで指定されたメッセージバッファを使ってメッセージを受信します。受信したメッセージは、msgへコピーされます。受信したメッセージのサイズ(msgsz)は、関数の戻値として返されます。
msgで指し示される領域は、メッセージバッファ生成時に指定したメッセージの 大長 maxmsz以上としてください。
メッセージバッファにまだメッセージが到着していない場合、待ち状態に入らずに、
E_TMOUTエラーを返します。

戻値 正の値 受信メッセージバイト数

E_ID メッセージバッファIDが範囲外\*
E_NOEXS メッセージバッファが生成されていない
E_TMOUT ポーリング失敗
補足 trcv_mbf(msg, p_msgsz, mbfid, TMO_POL)と同じです。

例

```c
#define ID_mbf2 2
TASK task1(void) {
    B buf[16];
    ER_UINT msgsz;

    :

        if ((msgsz = prcv_mbf(ID_mbf2, (VP)buf)) > 0)

            :
}
```

### trcv_mbf

機能 メッセージバッファから受信(タイムアウト有)
形式 ER_UINT trcv_mbf(ID mbfid, VP msg, TMO tmout); mbfid メッセージバッファID
msg 受信メッセージを格納する場所へのポインタ tmout タイムアウト値

解説 mbfidで指定されたメッセージバッファを使ってメッセージを受信します。
受信したメッセージは、msgへコピーされます。受信したメッセージのサイズ(msgsz)は、関数の戻値として返されます。msgで指し示される領域は、メッセージバッファ生成時に指定したメッセージの 大長maxmsz以上としてください。
メッセージバッファにまだメッセージが到着していない場合、本システムコールの発行タスクは、そのメッセージバッファの受信待ち行列につながれます。
tmoutで指定した時間が経過すると、タイムアウトエラーE_TMOUTとしてリターンします。
tmout = TMO_POL(= 0)により待ちをおこなわない、すなわちprcv_mbfと同じ動作になります。tmout = TMO_FEVR(= -1)によりタイムアウトしない、すなわち rcv_mbf と同じ動作になります。

戻値 正の値 受信メッセージバイト数

E_ID メッセージバッファID が範囲外\*
E_NOEXS メッセージバッファが生成されていない

E_CTX 非タスクコンテキストから発行、または、ディスパッチ禁止状態で待ち実行\*
E_RLWAI 待ち状態を強制解除された(待ちの間にrel_waiを受け付け)

E_DLT 待ちの間にメッセージバッファが削除された
E_TMOUT タイムアウト

例

```c
#define ID_mbf2 2
TASK task1(void) {
    B buf[16];
    ER_UINT msgsz;

    :
        msgsz = trcv_mbf(ID_mbf2, (VP)buf, 1000 / MSEC) if (ercd == E_TMOUT)

            :
}
```

### ref_mbf

機能 メッセージバッファ状態参照
形式 ER ref_mbf(ID mbfid, T_RMBF \*pk_rmbf); mbfid メッセージバッファID
pk_rmbf メッセージバッファ状態パケットを格納する場所へのポインタ

解説 mbfidで指定されたメッセージバッファの状態を、\*pk_rmbfに返します。
メッセージバッファ状態パケットの構造は次の通りです。

```c
typedef struct t_rmbf {
    ID stskid;   /* 送信待ちタスクID またはTSK_NONE */
    ID rtskid;   /* 受信待ちタスクID またはTSK_NONE */
    UINT smsgcnt; /* メッセージバッファに入っているメッセージ数 */
    SIZE fmbfsz; /* リングバッファの空きサイズ(バイト数) */
} T_RMBF;
```

stskidとrtskidには、待ちタスクがある場合、その先頭の待ちタスクのID番号が返ります。待ちタスクがない場合は、TSK_NONEが返ります。

戻値
E_OK 正常終了
E_ID メッセージバッファIDが範囲外
E_NOEXS メッセージバッファが生成されていない

例

```c
#define ID_mbf1 1
TASK task1(void) {
    T_RMBF rmbf;

    :
        ref_mbf(ID_mbf1, &rmbf);
    if (rmbf.fmbufsz >= 32 + sizeof(int))

        :
}
```

5.10 拡張同期・通信機能(ランデブ用ポート)

### cre_por

機能 ランデブ用ポート生成
形式 ER cre_por(ID porid, const T_CPOR \*pk_cpor); porid ランデブ用ポートID
pk_cpor ランデブ用ポート生成情報パケットへのポインタ

解説 poridで指定されたランデブ用ポートを生成します。すなわち、システムメモリから、ラン
デブ用ポート管理ブロックを動的に割り当てます。
定義情報パケットをROM以外に置いた場合、すなわちconstを付けなかった場合、定義情報パケットはシステムメモリにコピーされます。
ランデブ用ポート生成情報パケットの構造は次の通りです。

```c
typedef struct t_cpor

{
    ATR poratr;    /* ランデブ用ポート属性 */
    UINT maxcmsz; /* 呼出メッセージの 大長(バイト数) UINT maxrmsz; 返答メッセージの 大長(バイト数) */
    B* name;       /* ポート名へのポインタ（省略可） */
} T_CPOR;
```

ランデブ用ポート属性poratrには以下の値を設定してください。
TA_TFIFO呼出待ち行列を先着順(FIFO)とする
TA_TPRI呼出待ち行列をタスク優先度順とする
ランデブ受付の待ち行列はFIFOのみです。ランデブでは、呼出側と受付側がそろった時点で、メッセージのコピーがおこなわれますので、メッセージをキューイングするためのリングバッファ等は存在しません。
maxcmszとmaxrmszには0を設定することもできます。
nameは対応デバッガ用ですので、名前を指定しない場合には \"\"かNULLを入れてください。
この構造体を初期値付きで定義する場合には、nameを省略しても構いません。

+----------+------------+----------------------------------------------+
| 戻値 | > E_OK | 正常終了 |
+==========+============+==============================================+
| | > E_ID | ランデブ用ポートIDが範囲外\* |
+----------+------------+----------------------------------------------+
| | > E_OBJ | ランデブ用ポートが既に生成されている |
+----------+------------+----------------------------------------------+
| | > E_CTX | 割込みハンドラから発行\* |
+----------+------------+----------------------------------------------+
| | > E_SYS | > 管理ブロック用のメモリが確保できない\*\* |
+----------+------------+----------------------------------------------+

例

```c
#define ID_por1 1
const T_CPOR cpor1 = {TA_TFIFO, 64, 32};
TASK task1(void) {
    ER ercd;

    :

        ercd = cre_por(ID_por1, &cpor1);

    :
}
```

### acre_por

機能 ランデブ用のポート生成(ID自動割り当て)

形式 ER_ID acre_por(const T_CPOR \*pk_cpor);
pk_cpor ランデブ用ポート生成情報パケットへのポインタ
解説 未生成ランデブ用ポートのIDを、大きな方から検索して割り当てます。ランデブ用ポート IDが割り当てられない場合は、E_NOIDエラーを返します。それ以外は、cre_porと同じです。

戻値 正の値 割り当てられたランデブ用ポートID

E_NOID ランデブ用ポートIDが不足

E_CTX 割込みハンドラから発行\*

E_SYS 管理ブロック用のメモリが確保できない\*\*

例

```c
ID ID_por1;
const T_CPOR cpor1 = {TA_TFIFO, 64, 32};
TASK task1(void) {
    ER_ID ercd;

    :
        ercd = acre_por(&cpor1);
    if (ercd > 0) ID_por1 = ercd;

    :
}
```

### del_por

機能 ランデブ用のポート削除

形式 ER del_por(ID porid);

porid ランデブ用ポートID

解説 poridで指定されたランデブ用のポートを削除します。すなわち、ランデブ用ポート管理ブ
ロックをシステムメモリへ解放します。
このランデブ用ポートに対して、ランデブ受付やランデブ呼出を待っているタスクがあった場合、このタスクの待ちを解除します。待ち解除されたタスクへは、削除されたことを示すE_DLTエラーが返ります。
ランデブポートを削除してもすでに成立したランデブには影響ありません。

戻値
E_OK 正常終了
E_ID ランデブ用ポートIDが範囲外\*
E_NOEXS ランデブ用ポートが生成されていない

E_CTX 割込みハンドラから発行\*

例

```c
#define ID_por1 1
TASK task1(void) {
:

    del_por(ID_por1);

:
}
```

### cal_por

機能 ポートに対するランデブの呼出
形式 ER_UINT cal_por(ID porid, RDVPTN calptn, VP msg, UINT cmsgsz); porid ランデブ用ポートID

calptn 呼出側選択条件を表すビットパターン
msg 呼出メッセージへのポインタ、かつ、返答メッセージ格納場所へのポインタ cmsgsz 呼出メッセージのサイズ(バイト数)

解説 poridで指定されたランデブ用のポートを使い、受付側タスクと待ち合わせをおこなった上
で、受付側タスクへ呼出メッセージを渡します。さらに待ちをおこなって、受付側タスクから、返答メッセージを受け取ります。
calptnのビットパターンで、呼出側－受付側の組合せを選択することができます。この呼出側cal_porシステムコールのcalptnと、受付側acp_porシステムコールのacpptnとの論理積(calptn &acpptn)が0でない場合に、ランデブ成立となります。
このポートでランデブ受付待ちのタスクがある場合、受付待ちタスクとランデブが成立するか調べます(受付待ちタスクが複数ある場合は、受付待ち行列の先頭タスクから順に、ランデブ成立まで)。ランデブ受付待ちタスクがない場合やどの受付側タスクともランデブが成立しない場合、このシステムコールを発行した呼出側タスクは、ランデブ呼出待ちとして待ち行列につながれます。
ランデブが成立したなら、呼出メッセージを受付側タスクのバッファへコピーし、そのタスクの受付待ちを解除します。そしてこのシステムコールを発行した呼出側タスクは、ランデブ終了待ち状態になります。ランデブ終了待ち中は、タスクがポートから切り離されますので、待ち行列は作りません。
さらに、受付側タスクがrpl_rdvシステムコールにより返答を返すと、その返答メッセージを受け取ってランデブを終了します。返答メッセージは、msgへコピーされます。返答メッセージのサイズ(rmsgsz)は、関数の戻値として返されます。
msg で指し示される領域は、ランデブ用ポート生成時に指定した返答メッセージの 大長 maxrmsz以上としてください。

戻値 正または0 返答メッセージサイズ
E_PAR 呼出側選択条件を表すビットパターンcalptnが0\* メッセージサイズが範囲外(cmsgsz = 0, cmsgsz \> maxcmsz)\*

E_ID ランデブ用ポートIDが範囲外\*
E_NOEXS ランデブ用ポートが生成されていない
E_CTX 非タスクコンテキストから発行、または、ディスパッチ禁止状態で発行\* E_RLWAI 待ち状態を強制解除された(待ちの間にrel_waiを受け付け)

E_DLT 待ちの間にランデブ用ポートが削除された
補足 tcal_por(porid, calptn, msg, cmsgsz, TMO_FEVR)と同じです。

例

```c
#define ID_por1 1
TASK task1(void) {
    B msg[16];
    ER_UINT rmsgsz;

:
    strcpy(msg, "Hello");
    rmsgsz = cal_por(ID_por1, 0x0001, (VP)msg, strlen(msg));
    if (rmsgsz >= 0)

    :
}
```

### tcal_por

機能 ポートに対するランデブの呼出(タイムアウト有)
形式 ER_UINT tcal_por(ID porid, RDVPTN calptn, VP msg, UINT cmsgsz, TMO tmout); porid ランデブ用ポートID

calptn 呼出側選択条件を表すビットパターン
msg 返答メッセージを格納する場所へのポインタ cmsgsz 呼出メッセージのサイズ(バイト数) tmout タイムアウト値

解説 cal_porとの違いは次の通りです。
ランデブが終了しないまま、このシステムコール発行からtmoutで指定した時間が経過すると、タイムアウトエラーとしてリターンします。
tmout = TMO_POL(= 0)により待ちをおこなわない指定はE_PARエラーで返ります。
tmout = TMO_FEVR(= -1)によりタイムアウトしない指定はcal_porと同じ動作になります。

戻値 正または0 返答メッセージサイズ

E_PAR 呼出側選択条件を表すビットパターンcalptnが0\*
メッセージサイズが範囲外(cmsgsz = 0, cmsgsz \> maxcmsz)\* ポーリング指定\*

E_ID ランデブ用ポートIDが範囲外\*
E_NOEXS ランデブ用ポートが生成されていない

E_CTX 非タスクコンテキストから発行、または、ディスパッチ禁止状態で発行\*
E_RLWAI 待ち状態を強制解除された(待ちの間にrel_waiを受け付け)

E_DLT 待ちの間にランデブ用ポートが削除された
E_TMOUT タイムアウト

### acp_por

機能 ポートに対するランデブ受付
形式 ER_UINT acp_por(ID porid, RDVPTN acpptn, RDVNO \*p_rdvno, VP msg); porid ランデブ用ポートID

acpptn 受付側選択条件を表すビットパターン
p_rdvno ランデブ番号を格納する場所へのポインタ

msg 呼出メッセージを格納する場所へのポインタ

解説 poridで指定されたランデブ用ポートを使い、呼出側タスクと待ち合わせをおこなった上
で、呼出メッセージを受け取ります。
acpptnのビットパターンで、呼出側－受付側の組合せを選択することができます。呼出側 cal_porシステムコールのcalptnと、この受付側acp_porシステムコールのacpptnとの論理積(calptn & acpptn)が0でない場合に、ランデブ成立となります。
このポートでランデブ呼出待ちのタスクがある場合、呼出待ちタスクとランデブが成立するか調べます(呼出待ちタスクが複数ある場合は、呼出待ち行列の先頭タスクから順に、ランデブ成立まで)。ランデブ呼出待ちタスクがない場合や、どの呼出側タスクともランデブが成立しない場合、このシステムコールを発行した受付側タスクは、ランデブ受付待ちとして待ち行列につながれます。
ランデブが成立したら、呼出メッセージを受け取り、呼出側タスクを、呼出待ち状態からランデブ終了待ち状態にします。呼出メッセージは、msgへコピーされます。呼出メッセージのサイズ(cmsgsz)は、関数の戻値として返されます。
msgで指し示される領域は、ランデブ用ポート生成時に指定した呼出メッセージの 大長以上としてください。
\*p_rdvnoには、後でfwd_porやrpl_rdvシステムコールを発行する際に使用するランデブ番号が返されます。ランデブ終了待ち中の呼出側タスクはポートから切り離されており、ポート番号ではなく、タスク固有のランデブ番号による特定が必要なためです。

戻値 正の値 呼び出しメッセージサイズ(バイト)

E_PAR 受付側選択条件を表すビットパターンacpptnが0\*

E_ID ランデブ用ポートIDが範囲外\*
E_NOEXS ランデブ用ポートが生成されていない
E_CTX 非タスクコンテキストから発行、または、ディスパッチ禁止状態で待ち実行\* E_RLWAI 待ち状態を強制解除された(待ちの間にrel_waiを受け付け)

E_DLT 待ちの間にランデブ用ポートが削除された
補足 tacp_por(porid, acpptn, p_rdvno, msg, TMO_FEVR)と同じです。

例

```c
#define ID_por1 1
#define ID_por2 2
TASK task1(void) {
    B msg[64];
    ER_UINT cmsgsz;
    RDVNO rdvno;

:
    strcpy(msg, "Welcome");
    cmsgsz = acp_por(ID_por1, 0xffff, &rdvno, (VP)msg);
    if (memcmp(msg, "Hello", cmsgsz) == 0) {
        strcpy(msg, "World");
        rpl_rdv(rdvno, msg, strlen(msg));
    } else {
        fwd_por(ID_por2, 0x0001, rdvno, msg, strlen(msg));
    }

:

:
}
```

### pacp_por

機能 ポートに対するランデブ受付(ポーリング)
形式 ER_UINT pacp_por(ID porid, RDVPTN acpptn, RDVNO \*p_rdvno, VP msg); porid ランデブ用ポートID

acpptn 受付側選択条件を表すビットパターン
p_rdvno ランデブ番号を格納する場所へのポインタ

msg 呼出メッセージを格納する場所へのポインタ

解説 acp_porとの違いは次の通りです。
ランデブ呼出待ちタスクがない場合や、どの呼出側タスクともランデブが成立しない場合、待ち状態に入らずに、E_TMOUTエラーを返します。

戻値 正の値 呼出メッセージのサイズ(バイト数)

E_PAR 受付側選択条件を表すビットパターンacpptnが0\*

E_ID ランデブ用ポートIDが範囲外\*
E_NOEXS ランデブ用ポートが生成されていない
E_TMOUT ポーリング失敗

補足 tacp_por(porid, acpptn, p_rdvno, msg, TMO_POL)と同じです。

### tacp_por

機能 ポートに対するランデブ受付(タイムアウト有)
形式 ER_UINT tacp_por(ID porid, RDVPTN acpptn, RDVNO \*p_rdvno, VP msg, TMO tmout); porid ランデブ用ポートID

acpptn 受付側選択条件を表すビットパターン
p_rdvno ランデブ番号を格納する場所へのポインタ
msg 呼出メッセージを格納する場所へのポインタ tmout タイムアウト値

解説 acp_porとの違いは次の通りです。
tmoutで指定した時間が経過してもランデブが成立しない場合、タイムアウトエラー
E_TMOUTとしてリターンします。
tmout = TMO_POL(= 0)により待ちをおこなわない、すなわちpacp_porと同じ動作になります。tmout = TMO_FEVR(= -1)によりタイムアウトしない、すなわち acp_por と同じ動作になります。

戻値 正の値 呼出メッセージのサイズ(バイト数)

E_PAR 受付側選択条件を表すビットパターンacpptnが0\*

E_ID ランデブ用ポートIDが範囲外\*
E_NOEXS ランデブ用ポートが生成されていない

E_CTX 非タスクコンテキストから発行、または、ディスパッチ禁止状態で待ち実行\*
E_RLWAI 待ち状態を強制解除された(待ちの間にrel_waiを受け付け)

E_DLT 待ちの間にランデブ用ポートが削除された
E_TMOUT タイムアウト

### fwd_por

機能 ポートに対するランデブ回送
形式 ER fwd_por(ID porid, RDVPTN calptn, RDVNO rdvno, VP msg, UINT cmsgsz); porid 回送先のランデブ用ポートID
calptn 呼出側選択条件を表すビットパターン rdvno 回送前のランデブ番号

msg 呼出メッセージへのポインタ

cmsgsz 呼出メッセージのサイズ(バイト数)

解説 受け付けたランデブを他のポート(同じポートでもよい)へ回し、別のタスクに改めてラン
デブ受付をおこなわせます。
ランデブ終了待ち状態だった呼出側タスクは、 初に呼び出したポートとは別のポートで、再度、ランデブ呼出処理をおこなうことになります。また、ランデブ成立判定に使われるビットパターンは、このシステムコールのcalptnと置き換えられます。
回送後のポートで、ランデブ受付待ちのタスクがある場合、受付待ちタスクとランデブが成立するか調べます(受付待ちタスクが複数ある場合は、受付待ち行列の先頭タスクから順に、ランデブ成立まで)。ランデブ受付待ちタスクがない場合や、どの受付側タスクともランデブが成立しない場合、回送の対象となった呼出側タスクは、ランデブ呼出待ちとして待ち行列につながれます。
ランデブが成立したら、呼出メッセージを受付側タスクのバッファへコピーし、そのタスクの受付待ちを解除します。そして回送の対象となった呼出側タスクは、再び、ランデブ終了待ち状態になります。
このシステムコールを発行したタスクが、待ち状態となることはありません。このシステムコールを発行できるのは、ランデブ受付をおこなった後に限ります。回送されたランデブを、さらに回送することも可能です。

戻値
E_OK 正常終了
E_PAR 呼出側選択条件を表すビットパターンcalptnが0\*

メッセージサイズが範囲外(cmsgsz = 0, cmsgsz \> maxcmsz)\*

E_ID ランデブ用ポートIDが範囲外\*

E_OBJ 対象タスクがランデブ終了待ちでない

回送後のポートのmaxrmszが、回送前のmaxrmszより大きい\*
E_NOEXS ランデブ用ポートが生成されていない

### rpl_rdv

機能 ランデブ返答
形式 ER rpl_rdv(RDVNO rdvno, VP msg, UINT rmsgsz); rdvno ランデブ番号

msg 返答メッセージへのポインタ

rmsgsz 返答メッセージのサイズ(バイト数)

解説 rdvnoで特定されるランデブ呼出側タスクに返答メッセージを渡し、一連のランデブ処理を
終了させます。返答メッセージは、ランデブ呼出側タスクのバッファへコピーされます。
ランデブ呼出側タスクは、ランデブ終了待ちのWAITING状態から、READY状態へと遷移します(現在のRUNNINGタスクより高優先ならRUNNING状態へ、WAITING-SUSPENDED状態の場合はSUSPENDED状態へ遷移)。このシステムコールを発行したタスクが、待ち状態となることはありません。
このシステムコールを発行できるのは、ランデブ受付をおこなった後に限ります。

戻値
E_OK 正常終了
E_PAR メッセージサイズが範囲外

E_OBJ 対象タスクがランデブ終了待ちでない\*

### ref_por

機能 ポート状態参照
形式 ER ref_por(ID porid, T_RPOR \*pk_rpor); porid ランデブ用ポートID pk_rpor 状態パケットを格納する場所へのポインタ
解説 poridで指定されたランデブ用ポートの状態を、\*pk_rporに返します。ランデブ用ポート状態パケットの構造は次の通りです。

```c
typedef struct t_rpor {
    ID ctskid; /* 呼出待ちタスクIDまたはTSK_NONE  */
    ID atskid; /* 受付待ちタスクIDまたはTSK_NONE */
} T_RPOR;
```

ctskidとatskidには、待ちタスクがある場合、その先頭の待ちタスクのID番号が返ります。待ちタスクがない場合は、TSK_NONEが返ります。

戻値
E_OK 正常終了
E_ID ランデブ用ポートIDが範囲外
E_NOEXS ランデブ用ポートが生成されていない

例

```c
#define ID_por1 1
TASK task1(void) {
    T_RPOR rpor;

:
    ref_por(ID_por1, &rpor);
    if (rpor.atskid != TSK_NONE)

    :
}
```

### ref_rdv

機能 ランデブ状態参照
形式 ER ref_rdv(RDVNO rdvno, T_RRDV \*pk_rrdv); rdvno ランデブ番号
pk_rrdv 状態パケットを格納する場所へのポインタ
解説 rdvnoで指定されたランデブの状態を、\*pk_rrdvに返します。ランデブ状態パケットの構造は次の通りです。

```c
typedef struct t_rrdv {
    ID wtskid; // ランデブ終了待ちタスクID またはTSK_NONE
} T_RRDV;
```

wtskidには、待ちタスクがある場合、その先頭の待ちタスクのID番号が返ります。待ちタスクがない場合は、TSK_NONEが返ります。

戻値
E_OK 正常終了
E_ID ランデブ用ポートIDが範囲外
E_NOEXS ランデブ用ポートが生成されていない

例

```c
TASK task1(void) {
    T_RRDV rrdv;
    RDVNO rdvno; // 例として宣言を追加

:
    ref_rdv(rdvno, &rrdv);
    if (rrdv.wtskid != TSK_NONE)

    :
}
```

5.11 割込み管理機能

### def_inh

機能 割込みハンドラ定義
形式 ER def_inh(INHNO inhno, const T_DINH \*pk_dinh); inhno 割込みハンドラ番号
pk_dinh 割込みハンドラ定義情報パケットへのポインタ
解説 inhnoで指定される割込みベクタテーブルに、inthdrで示される割込みハンドラを設定します。割込みベクタテーブルが使えないプロセッサでは、配列変数として定義した割込みハンドラテーブルへ、inthdrを設定します。inhnoの内容はプロセッサにより異なります(割込みベクタ番号が一般的)。
割込みハンドラ定義情報パケットの構造は次の通りです。プロセッサによっては、割込みハンドラ開始時の割込みマスクimaskが追加されている場合があります。

```c
typedef struct t_dinh {
    ATR inhatr; // 割込みハンドラ属性
    FP inthdr;  // 割込みハンドラとする関数へのポインタ
    UINT imask; // 割込みマスク(一部のプロセッサのみ)
} T_DINH;
```

inhatrの値はNORTiでは参照していませんが、他社μITRONとの互換のためには、ハンドラが高級言語で記述されていることを示すTA_HLNGを入れてください。
プロセッサに依存しますので、カーネルとは別のn4ixxx.cにサンプルが記述されています。
これが、ユーザーのシステムに適合しない場合は、独自のdef_inhを作成してください。 μITRON仕様では、pk_dint = NULLで、割込みハンドラの定義を解除する仕様となってい
ますが、組込みシステムでは意味を持たないため、この機能は実装しなくても構いません。
割込みベクタテーブル領域をROMに割り当てる場合、このシステムコールは機能しません。
割込みハンドラのアドレスを、直接、割込みベクタテーブルに記述してください。

戻値
E_OK 正常終了
E_PAR 割込みハンドラ番号inhnoが範囲外\*

### ent_int

機能 割込みハンドラ開始

形式 void ent_int(void);

解説 割込み発生時のレジスタ類を保存し、スタックポインタを割込みハンドラ専用領域に切り
替えます。必ず割込みハンドラの先頭で呼び出してください。
スタックポインタがずれてしまいますので、割込みハンドラ入り口で、auto変数は定義できません。static変数にするか、割込みハンドラからさらに関数を呼んで、そこにauto変数を定義してください。
また、アセンブラレベルで見ると、ent_intをコールする前の部分に、レジスタを破壊するようなコードが展開される場合があります。この場合には、 適化をかけてコンパイルするか、実際の処理を割込みハンドラから呼ばれる関数へ移すことで、このコード展開を抑制してください。
マルチタスク動作に関与しない割込みルーチン(マルチタスク動作に関与する他の割込みハンドラの優先度以上であること)では、このent_intと次のret_intシステムコールを使わなくても構いません。その場合、コンパイラの拡張機能である interrupt 関数の機能を使うか、ユーザーが独自に、アセンブラでレジスタを保存／復元してください。

戻値 なし
補足 割込みハンドラをCで記述できるようにするための、NORTi独自のシステムコールです。例

```c
void func(void)
/* 最適化でinthdr内部にインライン展開されないこと */
{
    int c; // 例として追加

:
}
INTHDR inthdr(void) {
    ent_int();
    func();
    ret_int();
}
```

### ret_int

機能 割込みハンドラから復帰

形式 void ret_int(void);

解説 割込みハンドラを終了します。必ず割込みハンドラの 後で呼び出してください。
割込みハンドラ内で発行したシステムコールによるタスク切り替えは、この ret_int が発行されるまで遅延させられます(遅延ディスパッチ)。

戻値 なし(呼び出し元に戻りません)

例

```c
INTHDR inthdr(void) {
    ent_int();

:

    ret_int();
}
```

### chg_ims

機能 割込みマスク変更

形式 ER chg_ims(UINT imask);

imask 割込みマスク値

解説 プロセッサの割込みマスクを、imaskで指定した値に変更します。
割込み禁止／許可の2状態しかないプロセッサでは、imask = 0で割込み許可、imask != 0 で割込み禁止を指定します。
レベル割込み機能のあるプロセッサでは、imaskに割込みマスクレベルを指定します(0で割込み許可、1～で割込み禁止)。imask値の範囲はチェックしていません。
割込み禁止中に発行されたシステムコールで、タスク切り替が必要となった場合は、 chg_ims(0)が発行されて割込み許可となる時に、タスクの切り替えが行われます(遅延ディスパッチ)。

戻値
E_OK 正常終了

### get_ims

機能 割込みマスク参照

形式 ER get_ims(UINT \*p_imask);
p_imask 割込みマスク値を格納する場所へのポインタ

解説 プロセッサの割込みマスクを参照し、\*p_imaskに返します。
割込み禁止／許可の2状態しかないプロセッサでは、\*p_imask = 0で割込み許可状態、
\*p_imask = 1で割込み禁止状態を示します。

レベル割込み機能のあるプロセッサでは、\*p_imaskの値で割込みマスクレベルを示します。

戻値
E_OK 正常終了

### vdis_psw

機能 ステータスレジスタの割込みマスクセット

形式 UINT vdis_psw(void);

解説 プロセッサのステータスレジスタにある割込みマスクを、割込み禁止状態にセットします。
レベル割込みの機能を持ったプロセッサでは、 高の割込みレベルに設定して、全割込みを禁止します。
戻値として、この操作の前のプロセッサのステータスレジスタ値を返します。

戻値 割込み禁止前のプロセッサのステータスレジスタ値
補足 NORTi 独自のシステムコールです。vset_psw と組合せて、一時的な割込み禁止をおこなうのに便利です。カーネルより高優先の割込みルーチンからも発行できます。

例

```c
void func(void) {
    UINT psw;
    psw = vdis_psw(); /* 割込み禁止                       */
    vset_psw(psw);    /* > 割込み禁止/許可状態を元に戻す  */
}
```

同じことをchg_imsで実現するためには\...

```c
void func(void) {
    UINT imask;
    get_ims(&imask); /* 割込み禁止/許可を調べる              */
    chg_ims(7);      /* 割込み禁止(imask値はプロセッサ依存)  */
                     /*                                      */
:                    /*                                      */
    chg_ims(imask);  /* > 割込み禁止/許可状態を元に戻す      */
                     /*                                      */
}
```

### vset_psw

機能 ステータスレジスタのセット

形式 void vset_psw(UINT psw);

psw プロセッサのステータスレジスタ値

解説 プロセッサのステータスレジスタをpsw で指定した値に設定します。vdis_pswシステム
コールの戻値をpswとすれば、割込みマスクの完全な復元がおこなえます。
chg_ims(0)との違いは、遅延されたディスパッチがあっても実行されないことです。したがってvdis_psw～vset_pswの区間では、タスク切り替えが発生するようなシステムコールを発行できません。

戻値 なし
補足 NORTi 独自のシステムコールです。割込みマスクだけではなく、ステータスレジスタの全ビットが操作できます。カーネルより高優先の割込みルーチンからも発行できます。

例

```c
void func(void) {
    UINT psw;

    psw = vdis_psw();

:

    vset_psw(psw | 0x8000);

:
}
```

### cre_isr

機能 割込みサービスルーチンの生成
形式 ER cre_isr(ID isrid, const T_CISR \*pk_cisr); isrid 割込みサービスルーチンID
pk_cisr 割込みサービスルーチン生成情報パケットへのポインタ
解説 intnoで指定される割込み番号に、isrで示される割込みサービスルーチンを設定します。割込みベクタテーブルが使えないプロセッサでは、配列変数として定義した割込みハンドラテーブルへ、isrを設定します。intnoの内容はプロセッサにより異なります。割込みベクタ番号または割込み要因番号が一般的です。
割込みサービスルーチン生成情報パケットの構造は次の通りです。

```c
typedef struct t_cisr {
    ATR istatr;   /* 割込みハンドラ属性                     */
    VP_INT exinf; /* 拡張情報                               */
    INTNO intno;  /* > 割込み番号                           */
    FP isr;       /* 割込みサービスルーチンアドレス         */
    UINT imask; /* > 割込みマスク（一部のプロセッサのみ） */
                  /*                                        */
} T_CISR;         /*                                        */
```

istatrの値はNORTiでは参照していませんが、他社μITRONとの互換のためには、ハンドラが高級言語で記述されていることを示すTA_HLNGを入れてください。exinfは、割込みサービスルーチン起動時に第一引数として渡されます。
プロセッサに依存するので、カーネルとは別のn4ixxx.cに記述された関数を呼び出しています。これが、ユーザーのシステムに適合しない場合は、独自の関数を作成してください。
割込みサービスルーチンでは、割込み処理の入り口/出口処理をOSがおこなうため、
ent_int, ret_int等を呼ぶ必要がありません。またauto変数の使用禁止などの割込みハンドラにある制限は無いので、一般のC関数として記述することが出来ます。ただし、カーネルレベルより優先度の高い割込みに対して割込みサービスルーチンを使用することはできません。
付属のサンプルでは、def_inhで指定される割込みハンドラ番号と、cre_isrで指定される割込みハンドラ番号は同じとしてあります。同一の割込み番号に対して、割込みハンドラと割込みサービスルーチンとを重複して定義することはできません。

+----------+------------+----------------------------------------------+
| 戻値 | E_OK | 正常終了 |
+==========+============+==============================================+
| | E_PAR | 割込み番号intnoが範囲外\* |
+----------+------------+----------------------------------------------+
| | E_ID | IDが範囲外\* |
+----------+------------+----------------------------------------------+
| | E_SYS | > 管理ブロック用のメモリが確保できない\*\* |
+----------+------------+----------------------------------------------+

### acre_isr

機能 割込みサービスルーチンの生成(ID自動割り当て)

形式 ER_ID acre_isr(const T_CISR \*pk_cisr);
pk_cisr 割込みサービスルーチン生成情報パケットへのポインタ
解説 未生成割込みサービスルーチンのIDを、大きな方から検索して割り当てます。割込みサービスルーチン ID が割り当てられない場合は、E_NOID エラーを返します。それ以外は、 cre_isrと同じです。

戻値 正の値 割り当てられた割込みサービスルーチンID

E_NOID 割込みサービスルーチンIDが不足

E_CTX 割込みハンドラから発行\*

E_SYS 管理ブロック用のメモリが確保できない\*\*

例

```c
ID ID_isr1;
extern void sioisr(VP_INT);
const T_CISR cisr1 = {TA_HLNG, NULL, INT_SIO1, sioisr, 0x07};
TASK task1(void) {
    ER_ID ercd;

:
    ercd = acre_isr(&cisr1);
    if (ercd > 0) ID_isr1 = ercd;
}
```

+-----------+--------------------------------------------------------------+
| > del_isr | |
+===========+==============================================================+
| > 機能 | > 割込みサービスルーチンの削除 |
+-----------+--------------------------------------------------------------+
| > 形式 | ER del_isr(ID isrid); |
| | |
| | isrid 割込みサービスルーチンID |
+-----------+--------------------------------------------------------------+
| > 解説 | > isridで指定される割込みサービスルーチンを削除します。 |
+-----------+--------------------------------------------------------------+
| > 戻値 | E_OK 正常終了 |
| | |
| | E_ID IDが範囲外\* |
| | |
| | > E_NOEXS オブジェクト未生成 |
| | |
| | E_CTX 割込みハンドラから実行\* |
+-----------+--------------------------------------------------------------+
| > ref_isr | |
+-----------+--------------------------------------------------------------+

機能 割込みサービスルーチンの状態参照
形式 ER ref_isr(ID isrid, T_RISR \*pk_risr); isrid 割込みサービスルーチンID
pk_risr 割込みサービスルーチン状態パケットを格納する場所へのポインタ

解説 isridで指定される割込みサービスルーチンの状態を参照し、pk_risrに返します。
割込みサービスルーチン状態パケットの構造は次の通りです。

```c
typedef struct t_risr {
    INTNO intno; /* 割込み番号 */
    UINT imask;  /* 割込みマスク(一部のプロセッサのみ) */
} T_RISR;
```

戻値
E_OK 正常終了
E_ID IDが範囲外\*
E_NOEXS オブジェクト未生成

5.12 メモリプール管理機能(可変長)

### cre_mpl

機能 可変長メモリプール生成
形式 ER cre_mpl(ID mplid, const T_CMPL \*pk_cmpl); mplid 可変長メモリプールID
pk_cmpl 可変長メモリプール生成情報パケットへのポインタ

解説 mplidで指定された可変長メモリプールを生成します。すなわち、システムメモリから可変
長メモリプール管理ブロックを動的に割り当て、またpk_mpl-\>mplがNULLの場合メモリプール用メモリからpk_cmpl-\>mplszで指定されたサイズだけ、メモリプール領域を動的に割り当てます。
定義情報パケットをROM以外に置いた場合、すなわちconstを付けなかった場合、定義情報パケットはシステムメモリにコピーされます。
可変長メモリプール生成情報パケットの構造は次の通りです。

```c
typedef struct t_cmpl {
    ATR mplatr; /* > 可変長メモリプール属性               */
    SIZE mplsz; /* > メモリプール全体のサイズ（バイト数） */
    VP mpl;     /* メモリプールの先頭アドレスまたはNULL   */
    B *name;    /* > メモリプール名へのポインタ（省略可） */
                /*                                        */
} T_CMPL;       /*                                        */
```

可変長メモリプール属性mplatrには次の値を入れてください。
TA_TFIFO 獲得待ちタスク行列は先着順(FIFO)
TA_TPRI 獲得待ちタスク行列はタスク優先度順
ユーザープログラムでメモリプール領域を用意する場合は、確保した領域の先頭番地とバイトサイズをpk_cmpl-\>mplとpk_cmpl-\>mplszに設定してください。OSが使用するオーバヘッドがあるため確保した領域全てをユーザープログラムから使用できるわけではありません。
TSZ_MPL(cnt, size)
によってsizeバイトのデータをcnt個確保するのに必要なトータルメモリサイズを得ることができます。
nameは対応デバッガ用ですので、名前を指定しない場合には\"\"か NULL を入れてください。この構造体を初期値付きで定義する場合には、nameを省略しても構いません。

+-------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| 戻値 | E_OK 正常終了 |
| | |
| | E_ID 可変長メモリプールIDが範囲外\* |
| | |
| | E_OBJ 可変長メモリプールが既に生成されている |
| | |
| | E_CTX 割込みハンドラから発行\* |
| | |
| | E_SYS 管理ブロック用のメモリが確保できない\*\* E_NOMEM メモリプール用のメモリが確保できない\*\* |
+-------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| | |
+-------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| 注意1 | 1回のメモリブロック獲得毎に、sizeof (int \*)バイトだけ、すなわち、データ領域のアドレス空間が32ビットのCPUで4バイト、16ビットのCPUで2バイトを、OSが管理用に使用します。したがって、このOS使用分を加味して、mplszの値は決めてください。 |
| | |
| | さらに、sizeof (int \*)バイトの境界にそろえるため、サイズによっては無駄な領域を取られる場合があります。 |
+-------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| | |
+-------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| 注意2 | 獲得と返却を繰り返すと、メモリが断片化する可能性があります。すなわち、連続空き領域のサイズが小さくなる可能性があります。(ガーベジコレクション機能はありません。) |
+-------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| | |
+-------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| 例 | #define ID_mpl1 1 |
+-------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

```c
const T_CMPL cmpl1 = {TA_TFIFO, 1024, NULL};
TASK task1(void) {
    ER ercd; // 例として追加

:

    ercd = cre_mpl(ID_mpl1, &cmpl1);

:
}
```

### acre_mpl

機能 可変長メモリプール生成(ID自動割り当て)

形式 ER_ID acre_mpl(const T_CMPL \*pk_cmpl);
pk_cmpl 可変長メモリプール生成情報パケットへのポインタ
解説 未生成可変長メモリプールのIDを、大きな方から検索して割り当てます。可変長メモリプールIDが割り当てられない場合は、E_NOIDエラーを返します。それ以外は、cre_mplと同じです。

戻値 正の値 割り当てられた可変長メモリプールID

E_NOID 可変長メモリプールIDが不足

E_CTX 割込みハンドラから発行\*

E_SYS 管理ブロック用のメモリが確保できない\*\*
E_NOMEM メモリプール用のメモリが確保できない\*\*

例

```c
ID ID_mpl1;
const T_CMPL cmpl1 = {TA_TFIFO, 1024, NULL};
TASK task1(void) {
    ER_ID ercd;

:
    ercd = acre_mpl(&cmpl1);
    if (ercd > 0) ID_mpl1 = ercd;

:
}
```

### del_mpl

機能 可変長メモリプール削除

形式 ER del_mpl(ID mplid);

mplid 可変長メモリプールID
解説 mplidで指定された可変長メモリプールを削除します。すなわち、OSが確保した場合はメモリプール領域をメモリプール用メモリへ解放し、可変長メモリプール管理ブロックをシステムメモリへ解放します。
この可変長メモリプールに対して、獲得を待っているタスクがあった場合、このタスクの待ちを解除します。待ち解除されたタスクへは、削除されたことを示す E_DLT エラーが返ります。

戻値
E_OK 正常終了
E_ID 可変長メモリプールIDが範囲外\*
E_NOEXS 可変長メモリプールが生成されていない

E_CTX 割込みハンドラから発行\*

例

```c
#define ID_mpl1 1
TASK task1(void) {
:

    del_mpl(ID_mpl1);

:
}
```

### get_mpl

機能 可変長メモリブロック獲得
形式 ER get_mpl(ID mplid, UINT blksz, VP \*p_blk); mplid 可変長メモリプールID

blksz メモリブロックサイズ(バイト数)

p_blk メモリブロックへのポインタを格納する場所へのポインタ
解説 mplidで指定された可変長メモリプールから、blkszで指定されるサイズのメモリブロックを切り出し、そのメモリブロックへのポインタを\*p_blkに返します。獲得したメモリのゼロクリア等はおこなわれません。内容は不定です。
可変長メモリプールの空き領域が足りない場合、本システムコールの発行タスクは、その可変長メモリプールの待ち行列につながれます。
メモリブロックサイズblkszの 小値は、1バイト以上です。ただし、ワードのアラインメントの必要なプロセッサでは、blkszをintのサイズの整数倍としてください。(整数倍とせず端数のあるサイズを指定した場合は、内部で切り上げられます。)
サイズがblkszのメモリブロックを得るためには、可変長メモリプールにblksz + sizeof
(int \*)の空きが必要です。
要求するメモリブロックのサイズが小さい方を優先させる処理はおこなっていません。

戻値
E_OK 正常終了
E_ID 可変長メモリプールIDが範囲外\*
E_NOEXS 可変長メモリプールが生成されていない

E_CTX 非タスクコンテキストから発行、または、ディスパッチ禁止状態で待ち実行\*
E_RLWAI 待ち状態を強制解除された(待ちの間にrel_waiを受け付け)

E_DLT 待ちの間に可変長メモリプールが削除された

注意 p_blkは、ポインタへのポインタです。

補足 tget_mpl(mplid, blksz, p_blk, TMO_FEVR)と同じです。

例

```c
#define ID_mpl1 1
TASK task1(void) {
    B *blk;

:
    get_mpl(ID_mpl1, 256, (VP *)&blk);
    blk[0] = 0;
    blk[1] = 1;
:
}
```

### pget_mpl

機能 可変長メモリブロック獲得(ポーリング)
形式 ER pget_mpl(ID mplid, UINT blksz, VP \*p_blk); mplid 可変長メモリプールID blksz メモリブロックサイズ(バイト数) p_blk メモリブロックへのポインタを格納する場所へのポインタ

解説 get_mplとの違いは次の通りです。
可変長メモリプールの空き領域が足りない場合、待ち状態に入らずに、E_TMOUTエラーを返します。

戻値
E_OK 正常終了
E_ID 可変長メモリプールIDが範囲外\*
E_NOEXS 可変長メモリプールが生成されていない
E_TMOUT ポーリング失敗

E_CTX 割込みハンドラから発行\*
注意 p_blkは、ポインタへのポインタです。
補足 tget_mpl(mplid, blksz, p_blk, TMO_POL)と同じです。

例

```c
#define ID_mpl1 1
TASK task1(void) {
    B *blk;
    ER ercd;

:
    ercd = pget_mpl(ID_mpl1, 256, (VP *)&blk);
    if (ercd == E_OK)

    :
}
```

### tget_mpl

機能 可変長メモリブロック獲得(タイムアウト有)
形式 ER tget_mpl(ID mplid, UINT blksz, VP \*p_blk, TMO tmout); mplid 可変長メモリプールID blksz メモリブロックサイズ(バイト数) p_blk メモリブロックへのポインタを格納する場所へのポインタ tmout タイムアウト値
解説 get_mplとの違いは次の通りです。 tmoutで指定した時間が経過してもメモリプールの空き領域が不足したままの場合、タイムアウトエラーE_TMOUTとしてリターンします。
tmout = TMO_POL(= 0)により待ちをおこなわない、すなわちpget_mplと同じ動作になります。tmout = TMO_FEVR(= -1)によりタイムアウトしない、すなわち get_mpl と同じ動作になります。

戻値
E_OK 正常終了
E_ID 可変長メモリプールIDが範囲外\*
E_NOEXS 可変長メモリプールが生成されていない
E_CTX 非タスクコンテキストから発行、または、ディスパッチ禁止状態で待ち実行\* E_RLWAI 待ち状態を強制解除された(待ちの間にrel_waiを受け付け)

E_DLT 待ちの間に可変長メモリプールが削除された
E_TMOUT タイムアウト
注意 p_blkは、ポインタへのポインタです。

例

```c
#define ID_mpl1 1
TASK task1(void) {
    B *blk;
    ER ercd;

:
    ercd = tget_mpl(ID_mpl1, 256, (VP *)&blk, 100 / MSEC);
    if (ercd == E_OK)

    :
}
```

### rel_mpl

機能 可変長メモリブロック返却

形式 ER rel_mpl(ID mplid, VP blk);

mplid 可変長メモリプールID

blk メモリブロックへのポインタ

解説 mplidで指定された可変長メモリプールへ、blkで指し示されるメモリブロックを返却しま
す。
この可変長メモリプールでメモリブロック獲得を待っているタスクがあり、返却の結果、メモリープールの空きサイズが、先頭の待ちタスクの要求サイズ以上になったならば、このタスクにメモリブロックを獲得させ、待ちを解除します。複数の待ちタスクの中で、要求サイズが小さい方を優先させるような処理はおこなっていません。
1回の返却で、複数のタスクのメモリブロック獲得待ちが解除される場合があります。この場合は、待ち行列の先頭から順に、獲得待ちを解除していきます。このシステムコールを発行したタスクが、待ち状態となることはありません。
メモリブロックは、必ず、獲得した元のメモリプールへ返却してください。返却せずにタスクを終了等した場合メモリリークが発生します。

戻値
E_OK 正常終了
E_PAR 異なるメモリプールへの返却

E_ID 可変長メモリプールIDが範囲外\*
E_NOEXS 可変長メモリプールが生成されていない

E_CTX 割込みハンドラから発行\*

例

```c
#define ID_mpl1 1
TASK task1(void) {
    B *blk;

:

    get_mpl(ID_mpl1, 256, (VP *)&blk);

:

    rel_mpl(ID_mpl1, (VP)blk);

:
}
```

### ref_mpl

機能 可変長メモリプール状態参照
形式 ER ref_mpl(ID mplid, T_RMPL \*pk_rmpl); mplid 可変長メモリプールID
pk_rmpl 可変長メモリプール状態パケットを格納する場所へのポインタ

解説 mplidで指定された可変長メモリプールの状態を、\*pk_rmplに返します。
可変長メモリプール状態パケットの構造は次の通りです。

```c
typedef struct t_rmpl {
    ID wtskid;   /* 待ちタスクのIDまたはTSK_NONE */
    SIZE fmplsz; /* 空き領域の合計サイズ(バイト数) */
    UINT fblksz; /* 最大の連続空き領域のサイズ(バイト数) */
} T_RMPL;
```

wtskidには、待ちタスクがある場合その先頭の待ちタスクのID番号が返ります。待ちタスクがない場合は、TSK_NONEが返ります。

戻値
E_OK 正常終了
E_ID 可変長メモリプールIDが範囲外
E_NOEXS 可変長メモリプールが生成されていない

例

```c
#define ID_mpl1 1
TASK task1(void) {
    T_RMPL rmpl;

:
    ref_mpl(ID_mpl1, &rmpl);
    if (rmpl.fmplsz >= 256 + sizeof(int))

    :
}
```

5.13 メモリプール管理機能(固定長)

### cre_mpf

機能 固定長メモリプール生成
形式 ER cre_mpf(ID mpfid, const T_CMPF \*pk_cmpf); mpfid 固定長メモリプールID
pk_cmpf 固定長メモリプール生成情報パケットへのポインタ
解説 mpfidで指定された固定長メモリプールを生成します。すなわち、システムメモリから固定長メモリプール管理ブロックを動的に割り当て、またpk_mpf-\>mpfがNULLの場合メモリプール用メモリから、blkcnt×blfszで指定されたサイズだけ、メモリプール領域を動的に割り当てます。ユーザープログラムでメモリプール領域を確保した場合はその先頭アドレスを pk_mpf-\>mpfに設定してください。
固定長メモリプール生成情報パケットの構造は次の通りです。

```c
typedef struct t_cmpf {
    ATR mpfatr; /* 固定長メモリプール属性 */
    UINT blkcnt; /* メモリプール全体のブロック数 */
    UINT blfsz; /* 固定長メモリブロックサイズ(バイト数) */
    VP mpf;     /* メモリプール先頭番地またはNULL */
    B *name;    /* メモリプール名へのポインタ（省略可） */
} T_CMPF;
```

固定長メモリプール属性mpfatrには次の値を入れてください。
TA_TFIFO 獲得待ちタスク行列は先着順(FIFO)
TA_TPRI 獲得待ちタスク行列はタスク優先度順
メモリブロックサイズblfszの 小値は、処理系のポインタのサイズ以上です。また、ワードのアラインメントの必要なプロセッサでは、blfszをintのサイズの整数倍としてください。(整数倍とせず端数のあるサイズを指定した場合は、内部で切り上げられます。)
サイズがblfszのメモリブロック獲得によって消費されるメモリプールのサイズはblfszに等しく、無駄がありません。
nameは対応デバッガ用ですので、名前を指定しない場合には\"\"かNULLを入れてください。
この構造体を初期値付きで定義する場合には、nameを省略しても構いません。

+----------+------------+----------------------------------------------+
| 戻値 | E_OK | 正常終了 |
+==========+============+==============================================+
| | E_ID | 固定長メモリプールIDが範囲外\* |
+----------+------------+----------------------------------------------+
| | E_OBJ | 固定長メモリプールが既に生成されている |
+----------+------------+----------------------------------------------+
| | E_CTX | 割込みハンドラから発行\* |
+----------+------------+----------------------------------------------+
| | E_SYS | > 管理ブロック用のメモリが確保できない\*\* |
+----------+------------+----------------------------------------------+
E_NOMEM メモリプール用のメモリが確保できない\*\*

例

```c
#define ID_mpf1 1
const T_CMPF cmpf1 = {TA_TFIFO, 10, 256, NULL};
TASK task1(void) {
    ER ercd;

:

    ercd = cre_mpf(ID_mpf1, &cmpf1);

:
}
```

### acre_mpf

機能 固定長メモリプール生成(ID自動割り当て)

形式 ER_ID acre_mpf(const T_CMPF \*pk_cmpf);
pk_cmpf 固定長メモリプール生成情報パケットへのポインタ
解説 未生成固定長メモリプールのIDを、大きな方から検索して割り当てます。固定長メモリプールIDが割り当てられない場合は、E_NOIDエラーを返します。それ以外は、cre_mpfと同じです。

戻値 正の値 割り当てられた固定長メモリプールID

E_NOID 固定長メモリプールIDが不足

E_CTX 割込みハンドラから発行\*

E_SYS 管理ブロック用のメモリが確保できない\*\*
E_NOMEM メモリプール用のメモリが確保できない\*\*

例

```c
ID ID_mpf1;
const T_CMPF cmpf1 = {TA_TFIFO, 10, 256, NULL};
TASK task1(void) {
    ER_ID ercd;

:
    ercd = acre_mpf(&cmpf1);
    if (ercd > 0) ID_mpf1 = ercd;

:
}
```

### del_mpf

機能 固定長メモリプール削除

形式 ER del_mpf(ID mpfid);

mpfid 固定長メモリプールID
解説 mpfidで指定された固定長メモリプールを削除します。すなわち、OSが確保した場合はメモリプール領域をメモリプール用メモリへ解放し、固定長メモリプール管理ブロックをシステムメモリへ解放します。
この固定長メモリプールに対して、獲得を待っているタスクがあった場合、このタスクの待ちを解除します。待ち解除されたタスクへは、削除されたことを示す E_DLT エラーが返ります。

戻値
E_OK 正常終了
E_ID 固定長メモリプールIDが範囲外\*
E_NOEXS 固定長メモリプールが生成されていない

E_CTX 割込みハンドラから発行\*

例

```c
#define ID_mpf1 1
TASK task1(void) {
:

    del_mpf(ID_mpf1);

:
}
```

### get_mpf

機能 固定長メモリブロック獲得
形式 ER get_mpf(ID mpfid, VP \*p_blf); mpfid 固定長メモリプールID

p_blf メモリブロックへのポインタを格納する場所へのポインタ
解説 mpfidで指定された固定長メモリプールから、1個のメモリブロックを獲得して、そのメモリブロックへのポインタを\*p_blfに返します。メモリブロックのサイズは、固定長メモリブロック生成で指定したblfszに固定です。獲得したメモリブロックのゼロクリアは行われません。内容は不定です。
固定長メモリプールに空きブロックがない場合、本システムコールの発行タスクは、その固定長メモリプールの待ち行列につながれます。

戻値
E_OK 正常終了
E_ID 固定長メモリプールIDが範囲外\*
E_NOEXS 固定長メモリプールが生成されていない

E_CTX 非タスクコンテキストから発行、または、ディスパッチ禁止状態で待ち実行\*
E_RLWAI 待ち状態を強制解除された(待ちの間にrel_waiを受け付け)

E_DLT 待ちの間に固定長メモリプールが削除された

注意 p_blfは、ポインタへのポインタです。

補足 tget_mpf(mpfid, p_blf, TMO_FEVR)と同じです。

例

```c
#define ID_mpf1 1
TASK task1(void) {
    B *blf;

:
    get_mpf(ID_mpf1, (VP *)&blf);
    blf[0] = 0;
    blf[1] = 1;

:
}
```

### pget_mpf

機能 固定長メモリブロック獲得(ポーリング)
形式 ER pget_mpf(ID mpfid, VP \*p_blf); mpfid 固定長メモリプールID

p_blf メモリブロックへのポインタを格納する場所へのポインタ
解説 get_mpfとの違いは次の通りです。
固定 固定長メモリプールの空きブロックがない場合、待ち状態に入らずに、E_TMOUTエラーを返します。

戻値
E_OK 正常終了
E_ID 固定長メモリプールIDが範囲外\*
E_NOEXS 固定長メモリプールが生成されていない
E_TMOUT ポーリング失敗
注意 p_blfは、ポインタへのポインタです。
補足 tget_mpf(mpfid, p_blf, TMO_POL)と同じです。

例

```c
#define ID_mpf1 1
TASK task1(void) {
    B *blf;
    ER ercd;

:
    ercd = pget_mpf(ID_mpf1, (VP *)&blf);
    if (ercd == E_OK)

    :
}
```

### tget_mpf

機能 固定長メモリブロック獲得(タイムアウト有)
形式 ER tget_mpf(ID mpfid, VP \*p_blf, TMO tmout); mpfid 固定長メモリプールID
p_blf メモリブロックへのポインタを格納する場所へのポインタ tmout タイムアウト値
解説 get_mpfとの違いは次の通りです。 tmoutで指定した時間が経過してもメモリブロックが獲得できない場合、タイムアウトエラーE_TMOUTとしてリターンします。
tmout = TMO_POL(= 0)により待ちをおこわない、すなわちpget_mpfと同じ動作になります。 tmout = TMO_FEVR(= -1)によりタイムアウトしない、すなわち get_mpf と同じ動作になります。

戻値
E_OK 正常終了
E_ID 固定長メモリプールIDが範囲外\*
E_NOEXS 固定長メモリプールが生成されていない
E_CTX 非タスクコンテキストから発行、または、ディスパッチ禁止状態で待ち実行\* E_RLWAI 待ち状態を強制解除された(待ちの間にrel_waiを受け付け)

E_DLT 待ちの間に固定長メモリプールが削除された
E_TMOUT タイムアウト

例

```c
#define ID_mpf1 1
TASK task1(void) {
    B *blf;
    ER ercd;

:
    ercd = tget_mpf(ID_mpf1, (VP *)&blf, 100 / MSEC);
    if (ercd == E_OK)

    :
}
```

### rel_mpf

機能 固定長メモリブロック返却

形式 ER rel_mpf(ID mpfid, VP blf);

mpfid 固定長メモリプールID

blf メモリブロックへのポインタ

解説 mpfidで指定された固定長メモリプールへ、blfで指し示されるメモリブロックを返却しま
す。この固定長メモリプールでメモリブロック獲得を待っているタスクがあれば、先頭の待ちタスクにメモリブロックを獲得させ、待ちを解除します。
可変長のメモリブロックとは異なり、1回の返却で複数のタスクのメモリブロック獲得待ちが解除されることはありません。
このシステムコールを発行したタスクが、待ち状態となることはありません。メモリブロックは、必ず、獲得した元のメモリプールへ返却してください。

戻値
E_OK 正常終了
E_PAR 異なるメモリプールへの返却

E_ID 固定長メモリプールIDが範囲外\*
E_NOEXS 固定長メモリプールが生成されていない

例

```c
#define ID_mpf1 1
TASK task1(void) {
    B *blf;

:

    get_mpf(ID_mpf1, (VP *)&blf);

:

    rel_mpf(ID_mpf1, (VP)blf);

:
}
```

### ref_mpf

機能 固定長メモリプール状態参照
形式 ER ref_mpf(ID mpfid, T_RMPF \*pk_rmpf); mpfid 固定長メモリプールID
pk_rmpf 固定長メモリプール状態パケットを格納する場所へのポインタ

解説 mpfidで指定された固定長メモリプールの状態を、\*pk_rmpfに返します。
固定長メモリプール状態パケットの構造は次の通りです。

```c
typedef struct t_rmpf {
    ID wtskid;    /* 待ちタスクのIDまたはTSK_NONE */
    UINT fblkcnt; /* 空きメモリブロック数 */
} T_RMPF;
```

wtskidには、待ちタスクがある場合、その先頭の待ちタスクのID番号が返ります。待ちタスクがない場合は、TSK_NONEが返ります。

戻値
E_OK 正常終了
E_ID 固定長メモリプールIDが範囲外
E_NOEXS 固定長メモリプールが生成されていない

例

```c
#define ID_mpf1 1
TASK task1(void) {
    T_RMPF rmpf;

:
    ref_mpf(ID_mpf1, &rmpf);
    if (rmpf.fblkcnt > 0)

    :
}
```

5.14 時間管理機能

### set_tim

機能 システム時刻設定

形式 ER set_tim(SYSTIM \*p_systim);
p_systim 現在時刻パケットへのポインタ

解説 時間管理をおこなうシステムクロックを、\*p_systimで示される値に変更します。
時刻パケットの構造は次の通りです。

```c
typedef struct {
    H utime; /* 上位16 ビット */
    UW ltime; /* 下位32 ビット */
} SYSTIM;
```

set_timされたシステム時刻を周期割込みごとにカウントアップします。したがって、システム時刻は、周期割込みの回数をカウントしたデータです。msec等の時刻の単位との変換は、ユーザー側でおこなう必要があります。
システムクロックは、システム起動時に 0 クリアされその後カウントアップされる絶対時刻を表すのに対して、システム時刻は set_tim により初期化される相対時刻です。タイムイベントハンドラはシステムクロックを基準にしているため set_tim により影響を受けません。

戻値
E_OK 正常終了
例

```c
SYSTIM tim;

:
tim.utime = 0;
tim.ltime = 12345L;
set_tim(&tim);

:
```

### get_tim

機能 システム時刻参照

形式 ER get_tim(SYSTIM \*p_systim);
p_systim 現在時刻パケットを格納する場所へのポインタ

解説 システム時刻の現在の値を、\*p_systimに返します。
時刻パケットの構造はset_tim システムコールと同じです。

```c
typedef struct {
    H utime; /* 上位16ビット  */
    UW ltime; /* 下位32ビット */
} SYSTIM;
```

システム時刻は、周期割込みの回数をカウントしたデータです。msec 等の時刻の単位との変換は、ユーザー側でおこなう必要があります。

戻値
E_OK 正常終了
例

```c
SYSTIM tim;
:
get_tim(&tim);
if (tim.ltime == 10000L)

:
```

### cre_cyc

機能 周期ハンドラ生成
形式 ER cre_cyc(ID cycid, const T_CCYC \*pk_ccyc); cycid 周期ハンドラID
pk_ccyc 周期ハンドラ生成情報パケットへのポインタ

解説 cycidで指定される周期ハンドラを生成します。すなわち、システムメモリから、周期ハン
ドラ管理ブロックを動的に割り当てます。
周期ハンドラ生成情報パケットの構造は次の通りです

```c
typedef struct t_ccyc {
    ATR cycatr;    /* 周期ハンドラ属性                    */
    VP_INT exinf;  /* 拡張情報                            */
    FP cychdr;     /* 周期ハンドラとする関数へのポインタ  */
    RELTIM cyctim; /* 周期起動時間間隔                    */
    RELTIM cycphs; /* > 周期ハンドラ起動位相              */
} T_CCYC;
```

cycatrには、次の指定をできます。TA_STAとTA_PHSが不要な場合はTA_HLNG属性のみを指定してください。
TA_HLNG 他社μITRONとの互換のためには高級言語を示すこれを定義してください。
TA_STA ハンドラ生成と同時に動作状態とします。
TA_PHS ハンドラの起動位相を保存します。
起動位相を保存しない場合、ハンドラ動作を開始した時点で周期を初期化します。したがって、 初のハンドラ起動はつねに動作開始から起動周期経過後になります。位相を保存した場合、生成した時点から動作の有無に関係なく計時をおこないます。
exinfに指定した値は、ハンドラ起動時に第一パラメータとして渡されます。
cychdrは、周期ハンドラとする関数へのポインタです。周期ハンドラは、void型の関数として記述してください。
cyctimは、周期起動の時間間隔です。時間の単位は、システムクロックの割込み周期です。 cycphs には、ハンドラの動作を開始してから 初に起動するまでの時間を設定してください。二回目以降の起動はcyctim間隔になります。

起動位相 起動周期

起動周期
cre_cyc(TA_PHS指定あり) sta_cyc 周期ハンドラ起動

起動周期
cre_cyc(TA_PHS指定なし) sta_cyc 周期ハンドラ起動

+----------+------------+----------------------------------------------+
| 戻値 | E_OK | > 正常終了 |
+==========+============+==============================================+
| | E_ID | 周期ハンドラID番号が範囲外\* |
+----------+------------+----------------------------------------------+
| | E_PAR | > 周期ハンドラ活性状態が不正\* |
+----------+------------+----------------------------------------------+
| | E_CTX | > 割込みハンドラから発行\* |
+----------+------------+----------------------------------------------+
| | E_SYS | > 管理ブロック用のメモリが確保できない\*\* |
+----------+------------+----------------------------------------------+
※ NORTi カーネル 4.05.00 以前では、E_IDがE_PARと誤実装されています。

例

```c
#define ID_cyc1 1
extern void cyc1(VP_INT);
const T_CCYC ccyc1 = {TA_HLNG | TA_STA, NULL, cyc1, 10, 5};
TASK task1(void) {
    ER ercd;

:

    ercd = cre_cyc(ID_cyc1, &ccyc1);

:
}
```

### acre_cyc

機能 周期ハンドラ生成(ID自動割り当て)

形式 ER_ID acre_cyc(const T_CCYC \*pk_ccyc);
pk_ccyc 周期ハンドラ生成情報パケットへのポインタ
解説 未生成の周期ハンドラIDを、大きな方から検索して割り当てます。周期ハンドラIDが割り当てられない場合は、E_NOIDエラーを返します。それ以外は、cre_cycと同じです。

戻値 正の値 割り当てられた周期ハンドラID

E_NOID 周期ハンドラIDが不足

E_PAR 周期ハンドラ活性状態が不正\*

E_CTX 割込みハンドラから発行\*

E_SYS 管理ブロック用のメモリが確保できない\*\*

例

```c
ID ID_cyc1;
extern void cyc1(VP_INT);
const T_CCYC ccyc1 = {TA_HLNG | TA_STA, NULL, cyc1, 10, 5};
TASK task1(void) {
    ER_ID ercd;

:
    ercd = acre_cyc(&ccyc1);
    if (ercd > 0) ID_cyc1 = ercd;

:
}
```

### del_cyc

機能 周期ハンドラの削除

形式 ER del_cyc(ID cycid);

cycid 周期ハンドラID
解説 cycid で指定された周期ハンドラを削除します。すなわち、周期ハンドラ管理ブロックをシステムメモリへ解放します。

戻値
E_OK 正常終了
E_ID 周期ハンドラIDが範囲外\*
E_NOEXS 周期ハンドラが生成されていない

E_CTX 割込みハンドラから発行\*

例

```c
ID ID_cyc1; // ID_cyc1 は未定義だがそのままにする
TASK task1(void) {
    ER ercd;

:

    ercd = del_cyc(ID_cyc1);

:
}
```

### sta_cyc

機能 周期ハンドラ動作開始

形式 ER sta_cyc(ID cycid);

cycid 周期ハンドラID番号

解説 cycidで指定される周期ハンドラを動作状態にします。
TA_PHS 指定の無い場合は sta_cyc 呼出しから起動周期経過後にハンドラを起動します。 TA_PHSを指定した場合で、すでに動作状態の場合は何もしません。TA_PHSを指定した場合で停止状態の場合は、起動時刻の変更はせずに起動可能状態とします。TA_PHSを指定した場合は、起動可能か否かにかかわらず起動時間の更新を継続しておこなっています。

戻値
E_OK 正常終了
E_ID 周期ハンドラIDが範囲外\*
E_NOEXS 周期ハンドラが生成されていない
※ NORTi カーネル 4.05.00 以前では、E_IDがE_PARと誤実装されています。

### stp_cyc

機能 周期ハンドラ動作停止

形式 ER stp_cyc(ID cycid);

cycid 周期ハンドラID番号

解説 cycidで指定される周期ハンドラ動作していない状態にします。すでに停止しているハンド
ラが指定された場合は何もしません。
生成時にTA_PHSを指定した場合には、起動時刻の更新を継続します。

戻値
E_OK 正常終了
E_ID 周期ハンドラIDが範囲外\*
E_NOEXS 周期ハンドラが生成されていない

### ref_cyc

機能 周期ハンドラ状態参照
形式 ER ref_cyc(ID cycid, T_RCYC \*pk_rcyc); cycid 周期ハンドラID
pk_rcyc 周期ハンドラ状態パケットを格納する場所へのポインタ

解説 cycid で指定される周期ハンドラの状態を、\*pk_rcyc に返します。
周期ハンドラ状態パケットの構造は次の通りです。

```c
typedef struct t_rcyc {
    STAT cycstat;   /* ハンドラの動作状態 */
    RELTIM lefttim; /* 次回起動までの残り時間 */
} T_RCYC;
```

cycstat には、動作状態に応じて次の値が入ります。
TCYC_STP ハンドラは動作していない
TCYC_STA ハンドラは動作している
lefttim の単位は、システムクロックの割込み周期です。

戻値
E_OK 正常終了
E_ID 周期ハンドラIDが範囲外
E_NOEXS 周期ハンドラが生成されていない

例

```c
#define ID_cyc 1
TASK task1(void) {
    T_RCYC rcyc;

:
    ref_cyc(ID_cyc, &rcyc);
    if (rcyc.cycstat == TCYC_STA)

    :
}
```

### cre_alm

機能 アラームハンドラ生成
形式 ER cre_alm(ID almid, const T_CALM \*pk_calm); almid アラームハンドラID
pk_calm アラームハンドラ生成情報パケットへのポインタ

解説 almidで指定されるアラームハンドラを生成します。すなわち、システムメモリから、アラー
ムハンドラ管理ブロックを動的に割り当てます。
アラームハンドラ生成情報パケットの構造は次の通りです。

```c
typedef struct t_calm {
    ATR almatr;   // アラームハンドラ属性
    VP_INT exinf; // 拡張情報
    FP almhdr;    // アラームハンドラとする関数へのポインタ
} T_CALM;
```

almhdrは、アラームハンドラとする関数へのポインタです。アラームハンドラは、void型の関数として記述してください。
almatrの値はNORTiでは参照していませんが、他社μITRONとの互換のためには、ハンドラが高級言語で記述されていることを示すTA_HLNGを入れてください。exinfの値はアラームハンドラに第一引数として渡されます。

+----------+------------+----------------------------------------------+
| 戻値 | > E_OK | 正常終了 |
+==========+============+==============================================+
| | > E_ID | アラームハンドラID番号が範囲外\* |
+----------+------------+----------------------------------------------+
| | > E_PAR | > パラメータエラー\* |
+----------+------------+----------------------------------------------+
| | > E_OBJ | > アラームハンドラが登録済み\* |
+----------+------------+----------------------------------------------+
| | > E_CTX | 割込みハンドラから発行\* |
+----------+------------+----------------------------------------------+
| | > E_SYS | > 管理ブロック用のメモリが確保できない\*\* |
+----------+------------+----------------------------------------------+

例

```c
#define ID_alm1 1
extern void alm1(VP_INT);
const T_CALM calm1 = {TA_HLNG, NULL, alm1};
TASK task1(void) {
    ER ercd;

:

    ercd = cre_alm(ID_alm1, &calm1);

:
}
```

### acre_alm

機能 アラームハンドラ生成(ID自動割り当て)

形式 ER_ID acre_alm(const T_CALM \*pk_calm);
pk_calm アラームハンドラ生成情報パケットへのポインタ
解説 未生成のアラームハンドラIDを大きな方から検索して割り当てます。アラームハンドラID が割り当てられない場合は、E_NOIDエラーを返します。それ以外は、cre_almと同じです。

戻値 正の値 割り当てられたアラームハンドラID

E_NOID アラームハンドラIDが不足

E_OBJ アラームハンドラが登録済み\*

E_CTX 割込みハンドラから発行\*

E_SYS 管理ブロック用のメモリが確保できない\*\*

例

```c
ID ID_alm1;
extern void alm1(VP_INT);
const T_CALM calm1 = {TA_HLNG, NULL, alm1};
TASK task1(void) {
    ER_ID ercd;

:
    ercd = acre_alm(&calm1);
    if (ercd > 0) ID_alm1 = ercd;

:
}
```

### del_alm

機能 アラームハンドラの削除

形式 ER del_alm(ID almid);

almid アラームハンドラID
解説 almid で指定されたアラームハンドラを削除します。すなわち、アラームハンドラ管理ブロックをシステムメモリへ解放します。

戻値
E_OK 正常終了
E_ID アラームハンドラIDが範囲外\*
E_NOEXS アラームハンドラが生成されていない

E_CTX 割込みハンドラから発行\*

例

```c
ID ID_alm1;
TASK task1(void) {
    ER ercd;

:

    ercd = del_alm(ID_alm1);

:
}
```

+-----------+-----------------------------------------------------------------------------------+---+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---+
| > sta_alm | | | | |
+===========+===================================================================================+===+=====================================================================================================================================================================================================================================+===+
| > 機能 | | | > アラームハンドラ動作開始 | |
+-----------+-----------------------------------------------------------------------------------+---+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---+
| > 形式 | | | ER sta_alm(ID almid, RELTIM almtim); almid アラームハンドラID番号 almtim アラームハンドラ起動時刻(相対時刻) | |
+-----------+-----------------------------------------------------------------------------------+---+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---+
| > 解説 | | | > almidで指定されるアラームハンドラの起動時刻をalmtimに設定し動作を開始します。動作中のハンドラが指定された場合は起動時刻を新しい値に変更します。起動時刻はsta_alm が呼ばれた時刻を基準とした相対時刻で単位はタイマ割込み間隔です。 | |
+-----------+-----------------------------------------------------------------------------------+---+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---+
| > 戻値 | | | E_OK 正常終了 | |
| | | | | |
| | | | E_ID アラームハンドラIDが範囲外\* | |
| | | | | |
| | | | > E_NOEXS アラームハンドラが生成されていない | |
+-----------+-----------------------------------------------------------------------------------+---+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---+
| > stp_alm | | | | |
+-----------+-----------------------------------------------------------------------------------+---+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---+
| | | | | |
+-----------+-----------------------------------------------------------------------------------+---+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---+
| 機能 | > アラームハンドラ動作停止 | | | |
+-----------+-----------------------------------------------------------------------------------+---+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---+
| | | | | |
+-----------+-----------------------------------------------------------------------------------+---+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---+
| 形式 | ER stp_alm(ID almid); | | | |
| | | | | |
| | almid アラームハンドラID番号 | | | |
+-----------+-----------------------------------------------------------------------------------+---+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---+
| | | | | |
+-----------+-----------------------------------------------------------------------------------+---+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---+
| 解説 | > almidで指定されるアラームハンドラの起動時刻を解除し動作していない状態にします。 | | | |
| | > | | | |
| | > すでに停止しているハンドラが指定された場合は何もしません。 | | | |
+-----------+-----------------------------------------------------------------------------------+---+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---+
| | | | | |
+-----------+-----------------------------------------------------------------------------------+---+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---+
| 戻値 | E_OK 正常終了 | | | |
+-----------+-----------------------------------------------------------------------------------+---+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---+

E_ID アラームハンドラIDが範囲外\*
E_NOEXS アラームハンドラが生成されていない
※ NORTi カーネル 4.05.00 以前では、E_IDがE_PARと誤実装されています。

### ref_alm

機能 アラームハンドラ状態参照
形式 ER ref_alm(ID almid, T_RALM \*pk_ralm); almid アラームハンドラID
pk_ralm アラームハンドラ状態パケットを格納する場所へのポインタ

解説 almidで指定されるアラームハンドラの状態を、\*pk_ralmに返します。
アラームハンドラ状態パケットの構造は次の通りです。

```c
typedef struct t_ralm {
    STAT almstat;    // ハンドラの状態
    RELTIM lefttim;  // 起動までの時間
} T_RALM;
```

almstatには次の値が返ります。
TALM_STP アラームハンドラが動作していない
TALM_STA アラームハンドラが動作している
lefttimには起動までの残り時間が返ります。

戻値
E_OK 正常終了
E_ID アラームハンドラIDが範囲外\*
E_NOEXS アラームハンドラが生成されていない
※ NORTi カーネル 4.05.00 以前では、E_IDがE_PARと誤実装されています。

例

```c
#define ID_alm1 1
TASK task1(void) {
    T_RALM ralm;

:
    ref_alm(ID_alm1, &ralm);
    if (ralm.lefttim > 100 / MSEC)

    :
}
```

### isig_tim

機能 チックタイムの経過通知

形式 void isig_tim(void);
解説 OS に、周期タイマー割込みが入ったことを知らせます。割込みハンドラ専用です。

戻値 なし
補足 NORTi 独自のシステムコールです。

例

```c
INTHDR inthdr(void) {
    ent_int();
    isig_tim();
    ret_int();
}
```

### def_ovr

機能 オーバーランハンドラの定義

形式 ER def_ovr(const T_DOVR \*pk_dovr);
pk_dovr オーバーランハンドラ定義情報を入れたパケットへのポインタ

解説 オーバーランハンドラを定義情報に基づいて定義します。
オーバーランハンドラ定義情報パケットの構造は次の通りです。

```c
typedef struct t_dovr {
    ATR ovratr; /* オーバーランハンドラ属性              */
    FP ovrhdr;  /* オーバーランハンドラ先頭アドレス      */
    INTNO intno; /* 使用する周期割込み番号                */
    FP ovrclr; /* 割込み要因クリア処理関数先頭アドレス  */
    UINT imask; /* 割込みマスク                            */
                /*                                         */
} T_DOVR;       /*                                         */
```

ovratrの値はNORTiでは参照していませんが、他社μITRONとの互換のためには、ハンドラが高級言語で記述されていることを示すTA_HLNGを入れてください。exinfの値はオーバーハンドラの第二引数として渡されます。
ovrhdrは、オーバーランハンドラとする関数へのポインタです。オーバーランハンドラは、 void型の関数として以下の様に記述してください。

```c
void ovrhdr(ID tskid, VP_INT exinf) {
:

:
}
```

intnoにはオーバーランハンドラが使用する周期割込み番号を指定してください。一般的には、システムクロックと同じ周期割込み番号を使用します。ovrclrには、割込み要因をクリアするための関数を指定してください。割込み番号としてシステムクロックと同一の割込み番号を使用した場合、ovrclrにはNULLを指定してください。
システムクロックとは異なる割込み番号を使用する場合は、割込みの初期化ルーチンと ovrclr を独自に作成する必要があります。ovrclr に登録した関数は割込みが入るたびにコールされます。 pk_dovrにNULLを指定するとオーバーランハンドラ定義を解除します。すでに定義してある状態で再度pk_dovrにNULL以外の値を指定するとオーバーランハンドラを再定義します。独自の割込みを使用する場合は、割込みを禁止してから定義解除／再定義してください。
オーバーランハンドラは指定された割込み番号に対して、内部で割込みサービスルーチンを生成／削除します。

+---------+-----------+-----------------------------------------------+
| 戻値 | E_OK | > 正常終了 |
+=========+===========+===============================================+
| | E_NOID | > 割込みサービスルーチンIDが不足 |
+---------+-----------+-----------------------------------------------+
| | E_CTX | 割込みハンドラから発行\* |
+---------+-----------+-----------------------------------------------+
| | E_SYS | > 管理ブロック用のメモリが確保できない\*\* |
+---------+-----------+-----------------------------------------------+
| | E_PAR | 割込み番号intnoが範囲外\* |
+---------+-----------+-----------------------------------------------+
| | その他 | pk_dovr = NULLの時はacre_isrのエラー値 |
+---------+-----------+-----------------------------------------------+
| | | pk_dovr ≠ NULL del_isrのエラー値 |
+---------+-----------+-----------------------------------------------+
例

```c
#define INT_CMT INT_CMI0
extern void ovrhdr(ID, VP_INT);
const T_DOVR dovr = {TA_HLNG, ovrhdr, INT_CMT, NULL, 0x07};
TASK task1(void) {
    ER ercd;

:

    ercd = def_ovr(&dovr);

:
}
```

+-----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| > sta_ovr | |
+===========+==============================================================================================================================================================================================================================================================================================================================================================================================================+
| > 機能 | > オーバーランハンドラの動作開始 |
+-----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| > 形式 | ER sta_ovr(ID tskid, OVRTIM ovrtim); |
| | |
| | > tskid 持ち時間を設定するタスクのID ovrtim 持ち時間 |
+-----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| > 解説 | > tskidで指定されるタスクに対してプロセッサ時間を設定します。tskidにTSK_SELFを指定すると自タスクを対象とします。時間単位はdef_ovrで指定した割込み周期です。ovrtim で指定した時間を使い切るとオーバーランハンドラが起動されます。プロセッサ時間の計測は割込み時に実行していたタスクに対してプロセッサ時間を-1します。したがって、連続実行時間が割込み周期に対して充分長いタスク以外では誤差が大きくなります。 |
| | > |
| | > すでにプロセッサ時間が設定してあるタスクに対して再度 sta_ovr をおこなうとプロセッサ時間を更新します。 |
+-----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| > 戻値 | E_OK 正常終了 |
| | |
| | E_ID タスクIDが不正\* |
| | |
| | > E_NOEXS タスク未生成 |
| | |
| | E_PAR 持ち時間が不正 |
| | |
| | E_OBJ オーバーランハンドラ未定義 |
+-----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| > stp_ovr | |
+-----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

機能 オーバーランハンドラの動作停止

形式 ER stp_ovr(ID tskid);

tskid 計時を停止するタスクのID
解説 tskidで指定されるタスクに対してオーバーランハンドラの動作を停止します。プロセッサ時間の設定を解除します。tskid = TSK_SELFで自タスクを指定できます。

戻値
E_OK 正常終了
E_ID タスクIDが不正\*

E_OBJ オーバーランハンドラ未定義

### ref_ovr

機能 オーバーランハンドラ状態参照

形式 ER ref_ovr(ID tskid, T_ROVR \*pk_rovr);
tskid プロセッサ時間を参照するタスクのID pk_rovr オーバーランハンドラ状態パケットを格納する場所へのポインタ
解説 tskidで指定されるタスクのオーバーランハンドラの状態を、\*pk_rovrに返します。tskid = TSK_SELFで自タスクを指定できます。
オーバーランハンドラ状態パケットの構造は次の通りです。

```c
typedef struct t_rovr {
    STAT ovrstat;    // オーバーランハンドラの状態
    OVRTIM leftotm;  // プロセッサ残り時間
} T_ROVR;
```

ovrstatには次の値が返ります。
TOVR_STP プロセッサ時間が設定されていない TOVR_STA プロセッサ時間が設定されている
leftotmには起動までの残り時間が返ります。

戻値
E_OK 正常終了
E_ID タスクIDが不正\*

E_OBJ オーバーランハンドラ未定義

例

```c
TASK task1(void) {
    T_ROVR rovr;

:
    ref_ovr(TSK_SELF, &rovr);
    if (rovr.leftotm > 100 / MSEC)

    :
}
```

5.15 サービスコール管理機能

### def_svc

機能 拡張サービスコールの定義
形式 ER def_svc(FN fncd, const T_DSVC \*pk_dsvc); fncd 定義対象の機能コード
pk_dsvc 拡張サービスコール定義情報を入れたパケットへのポインタ

解説 fncdで指定される拡張サービスコールをpk_dsvcによって定義します。
拡張サービスコール定義情報パケットの構造は次の通りです。

```c
typedef struct t_dsvc {
    ATR svcatr; /* 拡張サービスコール属性 */
    FP svcrtn;  /* 拡張サービスコールルーチンアドレス */
    INT parn;   /* 拡張サービスコールルーチンのパラメータ数 */
} T_DSVC;
```

fncdには正の値を設定してください。svcatrの値はNORTiでは参照していませんが、他社μ ITRONとの互換のためには、ハンドラが高級言語で記述されていることを示すTA_HLNGを入れてください。
拡張サービスコールルーチンは以下の様な形式のC関数として記述してください。

```c
ER_UINT svcrtn(VP_INT par1, VP_INT par2, ..., VP_INT par6) {
:

:
}
```

parnにはパラメータの数を設定してください。パラメータ数は 小0個から 大は6個までです。拡張サービスコールルーチンは呼び出したコンテキストで実行されるサブルーチンです。標準システムコールを拡張サービスコールとして登録することも可能です。

戻値
E_OK 正常終了
E_CTX 非タスクコンテキストから発行\*

E_PAR パラメータエラー

例

```c
#define svc_ter_tsk 2
const T_DSVC dsvc2 = {TA_HLNG, (FP)v4_ter_tsk, 1};
TASK task1(void) {
    ER ercd;  // 例として追加 (元のコードにはなかった)
:

    ercd = def_svc(svc_ter_tsk, &dsvc2);

:
}
```

### cal_svc

機能 サービスコールの呼出
形式 ER_UINT cal_svc(FN fncd, VP_INT par1, VP_INT par2, \...); fncd 呼び出すサービスコール機能コード par1 サービスコールルーチンに渡す第一パラメータ par2 サービスコールルーチンに渡す第二パラメータ

\...

par6 サービスコールルーチンに渡す第六パラメータ
解説 fncdで指定されるサービスコールルーチンを、par1～par6をパラメータとして呼び出します。パラメータは必要な数のみ記述してください。

戻値 サービスコールからの戻り値

E_RSFN サービスコールルーチン未定義

E_PAR fncd不正\*

例

```c
#define svc_ter_tsk 2
#define Task2 2
const T_DSVC dsvc2 = {TA_HLNG, (FP)v4_ter_tsk, 1};
TASK task1(void) {
    ER ercd;  // 例として追加 (元のコードにはなかった)
:

    ercd = def_svc(svc_ter_tsk, &dsvc2);

:

    ercd = cal_svc(svc_ter_tsk, Task2);

:
}
```

5.16 システム状態管理機能

### rot_rdq, irot_rdq

機能 タスクのレディキュー回転

形式 ER rot_rdq(PRI tskpri);
ER irot_rdq(PRI tskpri); tskpri 優先度

解説 tskpriで指定された優先度のレディキューにおいて、先頭につながれているタスクを 後
尾へつなぎ替えます。つまり、同一優先度のタスクの実行を切り替えます。
tskpri = TPRI_SELFで、自タスクのベース優先度を対象優先度とします。
このシステムコールを周期ハンドラから一定間隔で発行することにより、ラウンドロビン・スケジューリングが実現できます。
このシステムコールを発行したタスクのレディキューが回転する場合、このタスクは
RUNNING状態からREADY状態へ遷移し、次に実行順序を待っていたタスクがREADY状態から RUNNING状態へ遷移します。つまり、自ら実行権を放棄するために、rot_rdqを発行することができます。
指定した優先度のレディキューにタスクがひとつ、あるいは無いい場合は何もしませんが、エラーとはなりません。

戻値
E_OK 正常終了
E_PAR 優先度が範囲外\*

例

```c
TASK task1(void) {
:

    rot_rdq(TPRI_SELF);

:
}
```

### get_tid, iget_tid

機能 実行タスクのタスクID参照
形式 ER get_tid(ID \*p_tskid); ER iget_tid(ID \*p_tskid);
p_tskid タスクIDを格納する場所へのポインタ
解説 このシステムコールを発行したタスクのID番号を、\*p_tskidに返します。割込みハンドラなどの非タスクコンテキスト部から呼ばれた場合には現在RUNNING状態にあるタスクのID を返します。RUNNING状態のタスクが無い場合はTSK_NONEを返します。

戻値
E_OK 正常終了
例

```c
TASK task1(void) {
    ID tskid;

:

    get_tid(&tskid);

:
}
```

### vget_tid

機能 自タスクのタスクIDを得る

形式 ID vget_tid(void);
解説 このシステムコールを発行したタスクのID番号を、関数戻り値として返します。その他は get_tidと同一です。

戻値 タスクID
補足 NORTi独自のシステムコールです。

例

```c
TASK task1(void) {
    ID tskid;

:

    tskid = vget_tid();

:
}
```

### loc_cpu, iloc_cpu

機能 CPUロック状態への移行(割込みとディスパッチの禁止)

形式 ER loc_cpu(void);
ER iloc_cpu(void);

解説 割込みの受付とタスク切り替えを禁止します。この禁止状態は、unl_cpuシステムコールで
解除されます。
すでに、CPUロック状態にあるとき、このシステムコールを発行してもエラーとはなりません。ただし、loc_cpu～unl_cpuの対はネスト管理されていませんので、複数回のloc_cpu に対して、1回のunl_cpuで禁止状態が解除されてしまいます。
割込みハンドラからは、このシステムコールを発行しないでください。割込みハンドラ以外の非タスクコンテキストからCPUロック状態に移行した場合は、復帰する前にCPUロック解除状態にしてください。

戻値
E_OK 正常終了
補足 レベル割込み機能のあるプロセッサの場合、NORTiでは、カーネルの割込み禁止レベルを標準で 高とはしていません。loc_cpuで設定される割込みマスクは、カーネルの割込み禁止レベルまでを禁止するものであり、カーネルより高優先の割込みは受付られます。

### unl_cpu, iunl_cpu

機能 CPUロック状態の解除

形式 ER unl_cpu(void);
ER iunl_cpu(void);
解説 loc_cpuで設定された禁止状態を解除します。ただし、割込みの受付とタスク切り替えが許可されるとは限りません。loc_cpuを発行した時点ですでにdis_dspによりディスパッチ禁止であればディスパッチは禁止されたままになります。この場合、ディスパッチ可能とするためにはena_dspによらなければなりません。
すでに、CPUロック解除状態にあるとき、このシステムコールを発行してもエラーとはなりません。ただし、loc_cpu～unl_cpuの対はネスト管理されていませんので、複数回のloc_cpu に対して、1回のunl_cpuで禁止状態が解除されてしまいます。
非タスクコンテキストのうちタイマイベントハンドラからiunl_cpuを呼ぶことは可能ですが、割込みハンドラからはこのシステムコールを発行しないでください。全割込みマスクが解除されてしまいます。レベル割込みをサポートしているプロセッサの場合、割込みハンドラでは ent_int から戻ってきた時点で、割込みサービスルーチンでは割込みサービスルーチンが呼ばれた時点でその割込みレベルまで割込みマスクは下がっています。

戻値
E_OK 正常終了

### dis_dsp

機能 ディスパッチ禁止

形式 ER dis_dsp(void);
解説 タスクの切り替えを禁止します。割込みは禁止されません。このシステムコールを発行した後の、他システムコール発行によるタスクの切り替えは保留されます。保留されたタスクの切り替えは、ena_dspシステムコールを発行した時に実行されます。
注意 ディスパッチ禁止の間は、待ちの生じるシステムコールを発行すると E_CTX エラーになります。

戻値
E_OK 正常終了
E_CTX 非タスクコンテキスト部からの発行\*

例

```c
TASK task1(void) {
:

    dis_dsp();
: /* ディスパッチ禁止区間 */
    ena_dsp();

:
}
```

### ena_dsp

機能 ディスパッチ許可

形式 ER ena_dsp(void);
解説 dis_dspシステムコールにより設定されていた、ディスパッチ禁止状態を解除します。先に dis_dspを発行していなくてもエラーとはしません。ディスパッチ禁止状態で保留されていたタスクの切り替えがあれば、このシステムコールで実行されます。

戻値
E_OK 正常終了
E_CTX 非タスクコンテキストからの発行\*

sns_ctx

機能 コンテキスト参照

形式 BOOL sns_ctx(void);
解説 非タスクコンテキスト部から呼ばれた場合にTRUE、タスクコンテキスト部から呼ばれた場合にFALSEを返します。

戻値 TRUE 非タスクコンテキスト

FALSE タスクコンテキスト部

### sns_loc

機能 CPUロック状態参照

形式 BOOL sns_loc(void);
解説 CPUロック状態の場合にTRUE、CPUロック解除状態の場合にFALSEを返します。

戻値 TRUE CPUロック状態

FALSE CPUロック解除状態

例

```c
BOOL cpu_lock = sns_loc();

:
if (!cpu_lock) loc_cpu();

:
/* CPU ロック状態でおこなわせたい処理 */

:
if (!cpu_lock) /* 不用意にロック解除しないため */
    unl_cpu();

:
```

+-----------+-----------------------------------------------------------------------------------+
| > sns*dsp | |
+===========+===================================================================================+
| > 機能 | > ディスパッチ禁止状態参照 |
+-----------+-----------------------------------------------------------------------------------+
| > 形式 | BOOL sns_dsp(void); |
+-----------+-----------------------------------------------------------------------------------+
| > 解説 | > ディスパッチ禁止状態の場合にTRUE、ディスパッチ許可状態の場合にFALSEを返します。 |
+-----------+-----------------------------------------------------------------------------------+
| > 戻値 | > TRUE ディスパッチ禁止状態 FALSE ディスパッチ許可状態 |
+-----------+-----------------------------------------------------------------------------------+
| > 例 | > BOOL task_lock = sns_dsp(); |
| | |
| | : |
| | |
| | > if (!task_lock) dis_dsp(); |
| | |
| | : |
| | |
| | > /* ディスパッチ禁止状態でおこなわせたい処理 _/ : |
| | > |
| | > if (!task_lock) /_ 不用意にディスパッチ許可しないため \_/ ena_dsp(); |
| | |
| | : |
+-----------+-----------------------------------------------------------------------------------+
| > sns_dpn | |
+-----------+-----------------------------------------------------------------------------------+

機能 ディスパッチ保留状態参照

形式 BOOL sns_dpn(void);
解説 CPUロック状態またはディスパッチ禁止の場合にTRUE、そうでない場合にFALSEを返します。

戻値 TRUE ディスパッチ保留状態

FALSE ディスパッチ可能状態

### ref_sys

機能 システム状態参照

形式 ER ref_sys(T_RSYS \*pk_rsys);
pk_rsys システム状態パケットを格納する場所へのポインタ

解説 OSの実行状態を、\*pk_rsysに返します。
システム状態パケットの構造は次の通りです。

```c
typedef struct t_rsys {
    INT sysstat;  // システム状態
} T_RSYS;
```

sysstatには、次の値が返ります。
TSS_TSK タスクコンテキスト部を実行中で、ディスパッチを許可した状態
TSS_DDSP タスクコンテキスト部を実行中で、ディスパッチを禁止した状態
TSS_LOC タスクコンテキスト部を実行中で、割込みとディスパッチを禁止した状態
TSS_INDP 非タスクコンテキスト部を実行中

戻値
E_OK 正常終了
例

```c
TASK task1(void) {
    T_RSYS rsys;

:
    ref_sys(&rsys);
    if (rsys.sysstat == TSS_LOC)

    :
}
```

5.17 システム構成管理機能

### ref_ver

機能 バージョン参照

形式 ER ref_ver(T_RVER \*pk_rver);
pk_rver バージョン情報パケットを格納する場所へのポインタ

解説 NORTi のバージョンを、\*pk_ver に返します。
バージョン情報パケットの構造は次の通りです。

```c
typedef struct t_rver {
    UH maker; /* メーカー（0108H:株式会社ミスポ）  */
    UH prid;  /* > 形式番号                        */
    UH spver; /* > 仕様書バージョン                */
    UH prver; /* > 製品バージョン                  */
    UH prno[4]; /* > 製品管理情報                    */
               /*                                   */
} T_RVER;      /*                                   */
```

構造体のメンバーの詳しい意味については、μITRON仕様書を、実際に返される値については、カーネルのソースファイルn4cxxx.asmを参照してください。

戻値
E_OK 正常終了

### ref_cfg

機能 コンフィグレーション情報参照

形式 ER ref_cfg(T_RCFG \*pk_rcfg);
pk_rcfg コンフィグレーション情報パケットを格納する場所へのポインタ

解説 コンフィグレーション情報を、\*pk_rcfg に返します。
このコンフィグレーション情報パケットの構造は、NORTi 独自です。

```c
typedef struct t_rcfg {
    ID tskid_max; /* > タスクID上限                                     */
    ID semid_max; /* > セマフォID上限                                   */
    ID flgid_max; /* > イベントフラグID上限                             */
    ID mbxid_max; /* > メールボックスID上限                             */
    ID mbfid_max; /* メッセージバッファID上限                           */
    ID porid_max; /* ランデブ用ポートID上限                             */
    ID mplid_max; /* 可変長メモリプールID上限                           */
    ID mpfid_max; /* 固定長メモリプールID上限                           */
    ID cycno_max; /* 周期ハンドラID上限                                 */
    ID almno_max; /* アラームハンドラID上限                             */
    PRI tpri_max; /* > タスク優先度上限                                 */
    int tmrqsz;   /* > タスクのタイマキューサイズ(バイト数)             */
    int cycqsz;   /* > 周期ハンドラのタイマキューサイズ(バイト数)       */
    int almqsz;   /* > アラームハンドラのタイマキューサイズ(バイト数)   */
    int istksz;   /* > 割込みハンドラのスタックサイズ(バイト数)         */
    int tstksz; /* > タイムイベントハンドラのスタックサイズ(バイト数) */
    SIZE sysmsz;  /* > システムメモリのサイズ(バイト数)                 */
    SIZE mplmsz;  /* > メモリプール用メモリのサイズ(バイト数)           */
    SIZE stkmsz;  /* > スタック用メモリのサイズ(バイト数)               */
    ID dtqid_max; /* > データキューID上限                               */
    ID mtxid_max; /* > ミューテックスID上限                             */
    ID isrid_max; /* > 割込みサービスルーチンID上限                     */
    ID svcfn_max; /* > 拡張サービスコール機能番号上限                   */

    // :(今後、追加される可能性があります)
} T_RCFG;
```

戻値 正常終了
第6章 独自システム関数

### sysini

機能 システム初期化

形式 ER sysini(void);

解説 カーネルを初期化します。他の全てのシステムコールに先だって、実行する必要がありま
す。通常は、main関数の先頭で呼び出してください。
ここで行われる初期化作業は、カーネルの内部変数の初期設定と、後述のintini関数の呼び出しです。sysini実行後は、割込み禁止状態となります。
スタック用メモリとして、コンパイラが提供する標準的なスタック領域を使う場合、すな
わち、コンフィグレーションで#define STKMSZ 0とした場合、確保されるスタックの底は、このsysiniを呼び出した時点のスタックポインタが基準となります。
コンフィグレータを使用する場合、コンフィグレータが生成する main 関数(kernel_cfg.c 内)から自動的に呼ばれるようになります。

戻値
E_OK 正常終了
E_SYS 管理ブロック用のメモリ不足\*\*
E_NOMEM スタック用のメモリ不足\*\* その他、intini関数の戻値

### syssta

機能 システム起動

形式 ER syssta(void);
解説 初期化ハンドラを終了して、マルチタスク状態へと移行します。このシステムコールを発行する前に、少なくとも1個以上のタスクの生成と起動がおこなわれていなければなりません。通常は、main関数の 後で呼び出してください。
起動されたタスクの中で、 も優先度の高いタスク(同優先度ならば、先に起動されたタスク)に制御が移ります。つまり、 初のディスパッチがおこなわれます。それに伴い、sysini で禁止されていた割込みが、ここで許可されます。
syssta実行前に、タスク生成等でエラーが発生していた場合は、システムを起動せずにエラーを返します。正常起動時は、sysstaからリターンしません。
コンフィグレータを使用する場合、コンフィグレータが生成する main 関数(kernel_cfg.c 内)から自動的に呼ばれるようになります。

戻値 E_PAR 優先度等が範囲外\*

E_ID IDが範囲外\*

E_OBJ 既に生成されている

E_SYS 管理ブロック用のメモリ不足\*\*
E_NOMEM スタック用やメモリプール用のメモリ不足\*\*

+----------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| > intsta | |
+==========+=================================================================================================================================================================================================================================================+
| > 機能 | > 周期タイマ割込み起動 |
+----------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| > 形式 | ER intsta(void); |
+----------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| > 解説 | > タスクの時間待ちを管理するための、周期タイマ割込みを起動します。この関数は、syssta システムコールの直前で、呼び出してください。タイムアウト付きのシステムコールやタイムイベントハンドラを使用しない場合は、intstaを実行する必要はありません。 |
| | > |
| | > 機種依存しますので、カーネルとは別のn4ixxx.cに定義されています。割込み周期は、標準で10msecです。サンプルとして付属のn4ixxx.cが適合しない場合は、ユーザーで作成してください。ユーザーが作成する場合、この関数名称にこだわる必要はありません。 |
| | > |
| | > コンフィグレータを使用する場合、コンフィグレータが生成するmain関数(kernel_cfg.c 内)から自動的に呼ばれるようになります。 |
| | > |
| | > オーバーランハンドラで周期タイマ割込みを使用する場合、def_ovrは周期タイマ割込み初期化後呼び出してください。 |
+----------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| > 戻値 | E_OK 正常終了 |
| | |
| | E_PAR 割込み周期等が範囲外(機種依存) |
+----------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| > intext | |
+----------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

機能 周期タイマ割込み終了

形式 void intext();

解説 intstaで起動したタイマを停止させます。
機種依存しますので、カーネルとは別のn4ixxx.cに定義されています。サンプルとして付属のn4ixxx.cが適合しない場合は、ユーザーで作成してください。ユーザーが作成する場合、この関数名称にこだわる必要はありません。タイマ割込みを止める必要性がなければ、作成しなくても構いません(サンプルの多くでも省略しています)。

戻値 なし

### intini

機能 割込み初期化

形式 ER intini(void);

解説 sysiniから割込み禁止状態で呼び出されます。ハードウェアの初期化等をおこないます。
機種依存しますので、カーネルとは別のサンプルn4ixxx.cに定義されています。この関数をユーザーが作成する場合、特に初期化するものがなければ、何もせずリターンしてください。

戻値
E_OK 正常終了
E_PAR 割込みベクタサイズ等が範囲外(機種依存)

第7章 一覧

7.1 エラーコード一覧

+-----------+------------------+---------------------------------------+
| E_OK | > 0 | > 正常終了 |
+===========+==================+=======================================+
| E_SYS | > 0xf..ffb (-5) | > システムエラー |
+-----------+------------------+---------------------------------------+
| E_NOSPT | 0xf..ff7 (-9) | > 未サポート機能 |
+-----------+------------------+---------------------------------------+
| E_RSFN | > 0xf..ff6 (-10) | > 予約機能コード |
+-----------+------------------+---------------------------------------+
| E_RSATR | > 0xf..ff5 (-11) | > 予約属性 |
+-----------+------------------+---------------------------------------+
| E_PAR | > 0xf..fef (-17) | > パラメータエラー |
+-----------+------------------+---------------------------------------+
| E_ID | > 0xf..fee (-18) | > 不正ID 番号 |
+-----------+------------------+---------------------------------------+
| E_CTX | > 0xf..fe7 (-25) | > コンテキストエラー |
+-----------+------------------+---------------------------------------+
| E_ILUSE | > 0xf..fe4 (-28) | > システムコール不正使用 |
+-----------+------------------+---------------------------------------+
| E_NOMEM | > 0xf..fdf (-33) | > メモリ不足 |
+-----------+------------------+---------------------------------------+
| E_NOID | 0xf..fde (-34) | > ID 番号不足 |
+-----------+------------------+---------------------------------------+
| E_OBJ | > 0xf..fd7 (-41) | > オブジェクト状態エラー |
+-----------+------------------+---------------------------------------+
| E_NOEXS | > 0xf..fd6 (-42) | > オブジェクト未生成 |
+-----------+------------------+---------------------------------------+
| E_QOVR | > 0xf..fd5 (-43) | > キューイングオーバーフロー |
+-----------+------------------+---------------------------------------+
| E_TMOUT | > 0xf..fce (-50) | > ポーリング失敗またはタイムアウト |
+-----------+------------------+---------------------------------------+
| E_RLWAI | > 0xf..fcf (-49) | > 待ち状態の強制解除 |
+-----------+------------------+---------------------------------------+
| E_DLT | > 0xf..fcd (-51) | > 待ちオブジェクトの削除 |
+-----------+------------------+---------------------------------------+

7.2 システムコール一覧

タスク管理機能

①②③

+-------------------------------------+--------------------------+-----+
| > タスク生成 | | ○○× |
| > | | |
| > cre_tsk(tskid, pk_ctsk); | | |
+=====================================+==========================+:====+
| > タスク生成(ID自動割付け) | | ○○× |
| > | | |
| > acre_tsk(pk_ctsk); | | |
+-------------------------------------+--------------------------+-----+
| > タスク削除 | | ○○× |
| > | | |
| > del_tsk(tskid); | | |
+-------------------------------------+--------------------------+-----+
| > タスク起動 | | ○○○ |
| > | | |
| > act_tsk(tskid); | | |
+-------------------------------------+--------------------------+-----+
| > タスク起動 | | ×○○ |
| > | | |
| > iact_tsk(tskid); | | |
+-------------------------------------+--------------------------+-----+
| > タスク起動要求のキャンセル | | ○○○ |
| > | | |
| > can_act(tskid); | | |
+-------------------------------------+--------------------------+-----+
| > タスク起動(起動コード指定) | | ○○○ |
| > | | |
| > sta_tsk(tskid, stacd); | | |
+-------------------------------------+--------------------------+-----+
| > 自タスク終了 | | ○×× |
| > | | |
| > ext_tsk(); | | |
+-------------------------------------+--------------------------+-----+
| > 自タスク終了と削除 | | ○×× |
| > | | |
| > exd_tsk(); | | |
+-------------------------------------+--------------------------+-----+
| > 他タスク強制終了 | | ○○○ |
| > | | |
| > ter_tsk(tskid); | | |
+-------------------------------------+--------------------------+-----+
| > タスク優先度変更 | | ○○○ |
| > | | |
| > chg_pri(tskid, tskpri); | | |
+-------------------------------------+--------------------------+-----+
| > タスク優先度参照 | | ○○○ |
| > | | |
| > get_pri(tskid, p_tskpri); | | |
+-------------------------------------+--------------------------+-----+
| > タスク状態参照 | | ○○○ |
| > | | |
| > ref_tsk(tskid, pk_rtsk); | | |
+-------------------------------------+--------------------------+-----+
| > タスク状態参照(簡易版) | | ○○○ |
| > | | |
| > ref_tst(tskid, pk_rtst); | | |
+-------------------------------------+--------------------------+-----+
凡例

- NORTi独自システムコール
  ①タスクから発行可能
  ②タイムイベントハンドラから発行可能
  ③割込みハンドラから発行可能

タスク付属同期

+-------------------------------------+--------------------------+-----+
| > 起床待ち | | ○×× |
| > | | |
| > slp_tsk(); | | |
+=====================================+==========================+:====+
| > 起床待ち（タイムアウト有） | | ○×× |
| > | | |
| > tslp_tsk(tmout); | | |
+-------------------------------------+--------------------------+-----+
| > タスク起床 | | ○○○ |
| > | | |
| > wup_tsk(tskid); | | |
+-------------------------------------+--------------------------+-----+
| > タスク起床 | | ×○○ |
| > | | |
| > iwup_tsk(tskid); | | |
+-------------------------------------+--------------------------+-----+
| > タスク起床要求のキャンセル | | ○○○ |
| > | | |
| > can_wup(tskid); | | |
+-------------------------------------+--------------------------+-----+
| > 自タスク起床要求キャンセル★ | | ○○○ |
| > | | |
| > vcan_wup(tskid); | | |
+-------------------------------------+--------------------------+-----+
| > 待ち状態の強制解除 | | ○○○ |
| > | | |
| > rel_wai(tskid); | | |
+-------------------------------------+--------------------------+-----+
| > 待ち状態の強制解除 | | ×○○ |
| > | | |
| > irel_wai(tskid); | | |
+-------------------------------------+--------------------------+-----+
| > 強制待ち状態へ移行 | | ○○○ |
| > | | |
| > sus_tsk(tskid); | | |
+-------------------------------------+--------------------------+-----+
| > 強制待ち状態からの再開 | | ○○○ |
| > | | |
| > rsm_tsk(tskid); | | |
+-------------------------------------+--------------------------+-----+
| > 強制待ち状態からの強制再開 | | ○○○ |
| > | | |
| > frsm_tsk(tskid); | | |
+-------------------------------------+--------------------------+-----+
| > 自タスクの遅延 | | ○×× |
| > | | |
| > dly_tsk(dlytim); | | |
+-------------------------------------+--------------------------+-----+
凡例

- NORTi独自システムコール
  ①タスクから発行可能
  ②タイムイベントハンドラから発行可能
  ③割込みハンドラから発行可能

タスク例外処理

+-----------------------------------------------------+---+--------------------------+-----+
| > タスク例外処理ルーチンの定義 | | | ○○× |
| > | | | |
| > def_tex(tskid, pk_dtex); | | | |
+=====================================================+===+==========================+:====+
| > タスク例外処理要求 | | | ○○○ |
| > | | | |
| > ras_tex(tskid, rasptn); | | | |
+-----------------------------------------------------+---+--------------------------+-----+
| > タスク例外処理要求 | | | ×○○ |
| > | | | |
| > iras_tex(tskid, rasptn); | | | |
+-----------------------------------------------------+---+--------------------------+-----+
| > タスク例外処理禁止 | | | ○○○ |
| > | | | |
| > dis_tex(); | | | |
+-----------------------------------------------------+---+--------------------------+-----+
| > タスク例外処理許可 | | | ○○○ |
| > | | | |
| > ena_tex(); | | | |
+-----------------------------------------------------+---+--------------------------+-----+
| > タスク例外処理禁止状態の参照 sns_tex(); | | | ○○○ |
+-----------------------------------------------------+---+--------------------------+-----+
| > タスク例外処理の状態参照 ref_tex(tskid, pk_rtex); | | | ○○○ |
+-----------------------------------------------------+---+--------------------------+-----+
凡例

- NORTi独自システムコール
  ①タスクから発行可能
  ②タイムイベントハンドラから発行可能
  ③割込みハンドラから発行可能

同期・通信 セマフォ

+-------------------------------------+--------------------------+-----+
| > セマフォ生成 | | ○○× |
| > | | |
| > cre_sem(semid, pk_csem); | | |
+=====================================+==========================+:====+
| > セマフォ生成（ID 自動割付け） | | ○○× |
| > | | |
| > acre_sem(pk_csem); | | |
+-------------------------------------+--------------------------+-----+
| > セマフォ削除 | | ○○× |
| > | | |
| > del_sem(semid); | | |
+-------------------------------------+--------------------------+-----+
| > セマフォ資源返却 | | ○○○ |
| > | | |
| > sig_sem(semid); | | |
+-------------------------------------+--------------------------+-----+
| > セマフォ資源返却 isig_sem(semid); | | ×○○ |
+-------------------------------------+--------------------------+-----+
| > セマフォ資源獲得 | | ○×× |
| > | | |
| > wai_sem(semid); | | |
+-------------------------------------+--------------------------+-----+
| > セマフォ資源獲得(ポーリング) | | ○○○ |
| > | | |
| > pol_sem(semid); | | |
+-------------------------------------+--------------------------+-----+
| > セマフォ資源獲得(タイムアウト有) | | ○×× |
| > | | |
| > twai_sem(semid, tmout); | | |
+-------------------------------------+--------------------------+-----+
| > セマフォ状態参照 | | ○○○ |
| > | | |
| > ref_sem(semid, pk_rsem); | | |
+-------------------------------------+--------------------------+-----+
凡例
★NORTi独自システムコール
①タスクから発行可能
②タイムイベントハンドラから発行可能
③割込みハンドラから発行可能

同期・通信 イベントフラグ

+-----------------------------------------------------------------+-----+
| > イベントフラグ生成 | ○○× |
| > | |
| > cre_flg(flgid, pk_cflg); | |
+=================================================================+:====+
| > イベントフラグ生成（ID 自動割付け） | ○○× |
| > | |
| > acre_flg(pk_cflg); | |
+-----------------------------------------------------------------+-----+
| > イベントフラグ削除 | ○○× |
| > | |
| > del_flg(flgid); | |
+-----------------------------------------------------------------+-----+
| > イベントフラグのセット | ○○○ |
| > | |
| > set_flg(flgid, setptn); | |
+-----------------------------------------------------------------+-----+
| > イベントフラグのセット | ×○○ |
| > | |
| > iset_flg(flgid, setptn); | |
+-----------------------------------------------------------------+-----+
| > イベントフラグのクリア | ○○○ |
| > | |
| > clr_flg(flgid, clrptn); | |
+-----------------------------------------------------------------+-----+
| > イベントフラグ待ち | ○×× |
| > | |
| > wai_flg(flgid, waiptn, wfmode, p_flgptn); | |
+-----------------------------------------------------------------+-----+
| > イベントフラグ待ち（ポーリング） | ○○○ |
| > | |
| > pol_flg(flgid, waiptn, wfmode, p_flgptn); | |
+-----------------------------------------------------------------+-----+
| > イベントフラグ待ち（タイムアウト有） | ○×× |
| > | |
| > twai_flg(flgid, waiptn, wfmode,p_flgptn, tmout); | |
+-----------------------------------------------------------------+-----+
| > イベントフラグ状態参照 | ○○○ |
| > | |
| > ref_flg(flgid, pk_rflg); | |
+-----------------------------------------------------------------+-----+
凡例
★NORTi独自システムコール
①タスクから発行可能
②タイムイベントハンドラから発行可能
③割込みハンドラから発行可能

同期・通信 データキュー

+-------------------------------------------------+--------------------------+-----+
| > データキュー生成 | | ○○× |
| > | | |
| > cre_dtq(dtqid, pk_cdtq); | | |
+=================================================+==========================+:====+
| > データキュー生成(ID自動割付け) | | ○○× |
| > | | |
| > acre_dtq(pk_cdtq); | | |
+-------------------------------------------------+--------------------------+-----+
| > データキュー削除 | | ○○× |
| > | | |
| > del_dtq(dtqid); | | |
+-------------------------------------------------+--------------------------+-----+
| > データキューへ送信 | | ○×× |
| > | | |
| > snd_dtq(dtqid, data); | | |
+-------------------------------------------------+--------------------------+-----+
| > データキューへ送信(ポーリング) | | ○○○ |
| > | | |
| > psnd_dtq(dtqid, data); | | |
+-------------------------------------------------+--------------------------+-----+
| > データキューへ送信(ポーリング) | | ×○○ |
| > | | |
| > ipsnd_dtq(dtqid, data); | | |
+-------------------------------------------------+--------------------------+-----+
| > データキューへ送信(タイムアウト有) | | ○×× |
| > | | |
| > tsnd_dtq(dtqid, data, tmout); | | |
+-------------------------------------------------+--------------------------+-----+
| > データキューへ強制送信 fsnd_dtq(dtqid, data); | | ○○○ |
+-------------------------------------------------+--------------------------+-----+
| > データキューへ強制送信 | | ×○○ |
| > | | |
| > ifsnd_dtq(dtqid, data); | | |
+-------------------------------------------------+--------------------------+-----+
| > データキューからの受信 | | ○×× |
| > | | |
| > rcv_dtq(dtqid, p_data); | | |
+-------------------------------------------------+--------------------------+-----+
| > データキューからの受信(ポーリング) | | ○○○ |
| > | | |
| > prcv_dtq(dtqid, p_data); | | |
+-------------------------------------------------+--------------------------+-----+
| > データキューからの受信(タイムアウト有) | | ○×× |
| > | | |
| > trcv_dtq(dtqid, p_data, tmout); | | |
+-------------------------------------------------+--------------------------+-----+
| > データキューの状態参照 | | ○○○ |
| > | | |
| > ref_dtq(dtqid, pk_rdtq); | | |
+-------------------------------------------------+--------------------------+-----+
凡例
★NORTi独自システムコール
①タスクから発行可能
②タイムイベントハンドラから発行可能
③割込みハンドラから発行可能

同期・通信機能 メールボックス

+-----------------------------------------------------+--------------------------+-----+
| > メールボックス生成 | | ○○× |
| > | | |
| > cre_mbx(mbxid, pk_cmbx); | | |
+=====================================================+==========================+:====+
| > メールボックス生成(ID自動割付け) | | ○○× |
| > | | |
| > acre_mbx(pk_cmbx); | | |
+-----------------------------------------------------+--------------------------+-----+
| > メールボックス削除 | | ○○× |
| > | | |
| > del_mbx(mbxid); | | |
+-----------------------------------------------------+--------------------------+-----+
| > メールボックスへ送信 | | ○○○ |
| > | | |
| > snd_mbx(mbxid, pk_msg); | | |
+-----------------------------------------------------+--------------------------+-----+
| > メールボックスから受信 | | ○×× |
| > | | |
| > rcv_mbx(mbxid, ppk_msg); | | |
+-----------------------------------------------------+--------------------------+-----+
| > メールボックスから受信(ポーリング) | | ○○○ |
| > | | |
| > prcv_mbx(mbxid, ppk_msg); | | |
+-----------------------------------------------------+--------------------------+-----+
| > メールボックスから受信(タイムアウト有) | | ○×× |
| > | | |
| > trcv_mbx(mbxid, ppk_msg, tmout); | | |
+-----------------------------------------------------+--------------------------+-----+
| > メールボックスの状態参照 ref_mbx(mbxid, pk_rmbx); | | ○○○ |
+-----------------------------------------------------+--------------------------+-----+
凡例
★NORTi独自システムコール
①タスクから発行可能
②タイムイベントハンドラから発行可能
③割込みハンドラから発行可能

拡張同期・通信 ミューテックス

+-----------------------------------------------------+--------------------------+-----+
| > ミューテックス生成 | | ○○× |
| > | | |
| > cre_mtx(mtxid, pk_cmtx); | | |
+=====================================================+==========================+:====+
| > ミューテックス生成（ID 自動割付け） | | ○○× |
| > | | |
| > acre_mtx(pk_cmtx); | | |
+-----------------------------------------------------+--------------------------+-----+
| > ミューテックス削除 | | ○○× |
| > | | |
| > del_mtx(mtxid); | | |
+-----------------------------------------------------+--------------------------+-----+
| > ミューテックスのロック | | ○×× |
| > | | |
| > loc_mtx(mtxid); | | |
+-----------------------------------------------------+--------------------------+-----+
| > ミューテックスのロック(ポーリング) | | ○○○ |
| > | | |
| > ploc_mtx(mtxid); | | |
+-----------------------------------------------------+--------------------------+-----+
| > ミューテックスのロック(タイムアウト有) | | ○×× |
| > | | |
| > tloc_mtx(mtxid,tmout); | | |
+-----------------------------------------------------+--------------------------+-----+
| > ミューテックスのロック解除 | | ○○○ |
| > | | |
| > unl_mtx(mtxid); | | |
+-----------------------------------------------------+--------------------------+-----+
| > ミューテックスの状態参照 ref_mtx(mtxid, pk_rmtx); | | ○○○ |
+-----------------------------------------------------+--------------------------+-----+
凡例
★NORTi独自システムコール
①タスクから発行可能
②タイムイベントハンドラから発行可能
③割込みハンドラから発行可能

拡張同期・通信機能 メッセージバッファ

+----------------------------------------------------------------+-----+
| > メッセージバッファ生成 | ○○× |
| > | |
| > cre_mbf(mbfid, pk_cmbf); | |
+================================================================+:====+
| > メッセージバッファ生成(ID 自動割付け) | ○○× |
| > | |
| > acre_mbf(pk_cmbf); | |
+----------------------------------------------------------------+-----+
| > メッセージバッファ削除 | ○○× |
| > | |
| > del_mbf(mbfid); | |
+----------------------------------------------------------------+-----+
| > メッセージバッファへ送信 | ○×× |
| > | |
| > snd_mbf(mbfid, msg, msgsz); | |
+----------------------------------------------------------------+-----+
| > メッセージバッファへ送信(ポーリング) | ○○○ |
| > | |
| > psnd_mbf(mbfid, msg, msgsz); | |
+----------------------------------------------------------------+-----+
| > メッセージバッファへ送信(タイムアウト有) | ○×× |
| > | |
| > tsnd_mbf(mbfid, msg, msgsz, tmout); | |
+----------------------------------------------------------------+-----+
| > メッセージバッファから受信 | ○×× |
| > | |
| > rcv_mbf(mbfid, msg); | |
+----------------------------------------------------------------+-----+
| > メッセージバッファから受信(ポーリング) | ○○○ |
| > | |
| > prcv_mbf(mbfid, msg); | |
+----------------------------------------------------------------+-----+
| > メッセージバッファから受信(タイムアウト有) | ○×× |
| > | |
| > trcv_mbf(mbfid, msg, tmout); | |
+----------------------------------------------------------------+-----+
| > メッセージバッファの状態参照 | ○○○ |
| > | |
| > ref_mbf(mbfid, pk_rmbf); | |
+----------------------------------------------------------------+-----+
凡例
★NORTi独自システムコール
①タスクから発行可能
②タイムイベントハンドラから発行可能
③割込みハンドラから発行可能

拡張同期・通信 ランデブ

+----------------------------------------------------------------+-----+
| > ランデブポート生成 | ○○× |
| > | |
| > cre_por(porid, pk_cpor); | |
+================================================================+:====+
| > ランデブポート生成(ID 自動割付け) | ○○× |
| > | |
| > acre_por(pk_cpor); | |
+----------------------------------------------------------------+-----+
| > ランデブポート削除 | ○○× |
| > | |
| > del_por(porid); | |
+----------------------------------------------------------------+-----+
| > ランデブポート呼出し | ○×× |
| > | |
| > cal_por(porid, calptn, msg, cmsgsz); | |
+----------------------------------------------------------------+-----+
| > ランデブポート呼出し(タイムアウト有) | ○×× |
| > | |
| > tcal_por(porid, calptn, msg, cmsgsz, tmout); | |
+----------------------------------------------------------------+-----+
| > ランデブポート待受け | ○×× |
| > | |
| > acp_por(porid, acpptn, p_rdvno, msg); | |
+----------------------------------------------------------------+-----+
| > ランデブポート待受け(ポーリング) | ○○○ |
| > | |
| > pacp_por(porid, acpptn, p_rdvno, msg); | |
+----------------------------------------------------------------+-----+
| > ランデブポート待受け(タイムアウト有) | ○×× |
| > | |
| > tacp_por(porid, acpptn, p_rdvno, msg, tmout); | |
+----------------------------------------------------------------+-----+
| > ランデブの回送 | ○○○ |
| > | |
| > fwd_por(porid, calptn, rdvno, msg, cmsgsz); | |
+----------------------------------------------------------------+-----+
| > ランデブの終了 | ○○○ |
| > | |
| > rpl_rdv(rdvno, msg, rmsgsz); | |
+----------------------------------------------------------------+-----+
| > ランデブポートの状態参照 ref_por(porid, pk_rpor); | ○○○ |
+----------------------------------------------------------------+-----+
| > ランデブの状態参照 | ○○○ |
| > | |
| > ref_rdv(rdvno, pk_rrdv); | |
+----------------------------------------------------------------+-----+
凡例
★NORTi独自システムコール
①タスクから発行可能
②タイムイベントハンドラから発行可能
③割込みハンドラから発行可能

メモリプール管理 固定長

+----------------------------------------------------------------+-----+
| > 固定長メモリプール生成 | ○○× |
| > | |
| > cre_mpf(mpfid, pk_cmpf); | |
+================================================================+:====+
| > 固定長メモリプール生成(ID自動割付け) | ○○× |
| > | |
| > acre_mpf(pk_cmpf); | |
+----------------------------------------------------------------+-----+
| > 固定長メモリプール削除 | ○○× |
| > | |
| > del_mpf(mpfid); | |
+----------------------------------------------------------------+-----+
| > 固定長メモリブロック獲得 | ○×× |
| > | |
| > get_mpf(mpfid, p_blk); | |
+----------------------------------------------------------------+-----+
| > 固定長メモリブロック獲得(ポーリング) | ○○○ |
| > | |
| > pget_mpf(mpfid, p_blk); | |
+----------------------------------------------------------------+-----+
| > 固定長メモリブロック獲得(タイムアウト有) | ○×× |
| > | |
| > tget_mpf(mpfid, p_blk, tmout); | |
+----------------------------------------------------------------+-----+
| > 固定長メモリブロック返却 | ○○○ |
| > | |
| > rel_mpf(mpfid, blk); | |
+----------------------------------------------------------------+-----+
| > 固定長メモリプールの状態参照 | ○○○ |
| > | |
| > ref_mpf(mpfid, pk_rmpf); | |
+----------------------------------------------------------------+-----+
凡例
★NORTi独自システムコール
①タスクから発行可能
②タイムイベントハンドラから発行可能
③割込みハンドラから発行可能

メモリプール管理 可変長

+----------------------------------------------------------------+-----+
| > 可変長メモリプール生成 | ○○× |
| > | |
| > cre_mpl(mplid, pk_cmpl); | |
+================================================================+:====+
| > 可変長メモリプール生成(ID 自動割付け) | ○○× |
| > | |
| > acre_mpl(pk_cmpl); | |
+----------------------------------------------------------------+-----+
| > 可変長メモリプール削除 | ○○× |
| > | |
| > del_mpl(mplid); | |
+----------------------------------------------------------------+-----+
| > 可変長メモリブロック獲得 | ○×× |
| > | |
| > get_mpl(mplid, blksz, p_blk); | |
+----------------------------------------------------------------+-----+
| > 可変長メモリブロック獲得(ポーリング) | ○○× |
| > | |
| > pget_mpl(mplid, blksz, p_blk); | |
+----------------------------------------------------------------+-----+
| > 可変長メモリブロック獲得(タイムアウト有) | ○×× |
| > | |
| > tget_mpl(mplid, blksz, p_blk, tmout); | |
+----------------------------------------------------------------+-----+
| > 可変長メモリブロック返却 | ○○× |
| > | |
| > rel_mpl(mplid, blk); | |
+----------------------------------------------------------------+-----+
| > 可変長メモリプールの状態参照 | ○○× |
| > | |
| > ref_mpl(mplid, pk_rmpl); | |
+----------------------------------------------------------------+-----+
凡例
★NORTi独自システムコール
①タスクから発行可能
②タイムイベントハンドラから発行可能
③割込みハンドラから発行可能

時間管理 システム時刻管理

+-------------------------------------+--------------------------+-----+
| > システム時刻の設定 | | ○○○ |
| > | | |
| > set_tim(p_tim); | | |
+=====================================+==========================+:====+
| > システム時刻の参照 | | ○○○ |
| > | | |
| > get_tim(p_tim); | | |
+-------------------------------------+--------------------------+-----+
| > タイムティックの供給 | | ××○ |
| > | | |
| > isig_tim(); | | |
+-------------------------------------+--------------------------+-----+
| > タイムティックの供給 | | ××○ |
| > | | |
| > sig_tim(); | | |
+-------------------------------------+--------------------------+-----+
凡例
★NORTi独自システムコール
①タスクから発行可能
②タイムイベントハンドラから発行可能
③割込みハンドラから発行可能

時間管理 周期ハンドラ

+-------------------------------------+--------------------------+-----+
| > 周期ハンドラの生成 | | ○○× |
| > | | |
| > cre_cyc(cycid, pk_ccyc); | | |
+=====================================+==========================+:====+
| > 周期ハンドラの生成(ID自動割付け) | | ○○× |
| > | | |
| > acre_cyc(pk_ccyc); | | |
+-------------------------------------+--------------------------+-----+
| > 周期ハンドラの削除 | | ○○× |
| > | | |
| > del_cyc(cycid); | | |
+-------------------------------------+--------------------------+-----+
| > 周期ハンドラの開始 | | ○○○ |
| > | | |
| > sta_cyc(cycid); | | |
+-------------------------------------+--------------------------+-----+
| > 周期ハンドラの停止 | | ○○○ |
| > | | |
| > stp_cyc(cycid); | | |
+-------------------------------------+--------------------------+-----+
| > 周期ハンドラの状態参照 | | ○○○ |
| > | | |
| > ref_cyc(cycid, pk_rcyc); | | |
+-------------------------------------+--------------------------+-----+
凡例
★NORTi独自システムコール
①タスクから発行可能
②タイムイベントハンドラから発行可能
③割込みハンドラから発行可能

時間管理 アラームハンドラ

+-----------------------------------------+--------------------------+-----+
| > アラームハンドラの生成 | | ○○× |
| > | | |
| > cre_alm(almid, pk_calm); | | |
+=========================================+==========================+:====+
| > アラームハンドラの生成(ID 自動割付け) | | ○○× |
| > | | |
| > acre_alm(pk_calm); | | |
+-----------------------------------------+--------------------------+-----+
| > アラームハンドラの削除 | | ○○× |
| > | | |
| > del_alm(almid); | | |
+-----------------------------------------+--------------------------+-----+
| > アラームハンドラの開始 | | ○○○ |
| > | | |
| > sta_alm(almid, almtim); | | |
+-----------------------------------------+--------------------------+-----+
| > アラームハンドラの停止 | | ○○○ |
| > | | |
| > stp_alm(almid); | | |
+-----------------------------------------+--------------------------+-----+
| > アラームハンドラの状態参照 | | ○○○ |
| > | | |
| > ref_alm(almid, pk_ralm); | | |
+-----------------------------------------+--------------------------+-----+
凡例
★NORTi独自システムコール
①タスクから発行可能
②タイムイベントハンドラから発行可能
③割込みハンドラから発行可能

時間管理 オーバーランハンドラ

+-------------------------------------+--------------------------+-----+
| > オーバーランハンドラの定義 | | ○○× |
| > | | |
| > def_ovr(pk_dovr); | | |
+=====================================+==========================+:====+
| > オーバーランハンドラの開始 | | ○○○ |
| > | | |
| > sta_ovr(tskid, ovrtim); | | |
+-------------------------------------+--------------------------+-----+
| > オーバーランハンドラの停止 | | ○○○ |
| > | | |
| > stp_ovr(tskid); | | |
+-------------------------------------+--------------------------+-----+
| > オーバーランハンドラの状態参照 | | ○○○ |
| > | | |
| > ref_ovr(tskid, pk_rovr); | | |
+-------------------------------------+--------------------------+-----+
凡例
★NORTi独自システムコール
①タスクから発行可能
②タイムイベントハンドラから発行可能
③割込みハンドラから発行可能

システム状態管理

①②③

+-----------------------------------------+--------------------------+-----+
| > タスクの実行順位の回転 | | ○○○ |
| > | | |
| > rot_rdq(tskpri); | | |
+=========================================+==========================+:====+
| > タスクの実行順位の回転 | | ×○○ |
| > | | |
| > irot_rdq(tskpri); | | |
+-----------------------------------------+--------------------------+-----+
| > 実行状態のタスクID参照 | | ○○○ |
| > | | |
| > get_tid(p_tskid); | | |
+-----------------------------------------+--------------------------+-----+
| > 実行状態のタスクID参照 | | ×○○ |
| > | | |
| > iget_tid(p_tskid); | | |
+-----------------------------------------+--------------------------+-----+
| > 自タスクID参照★ | | ○○○ |
| > | | |
| > vget_tid(); | | |
+-----------------------------------------+--------------------------+-----+
| > CPU ロック状態への移行 | | ○○× |
| > | | |
| > loc_cpu(); | | |
+-----------------------------------------+--------------------------+-----+
| > CPU ロック状態への移行 | | ×○× |
| > | | |
| > iloc_cpu(); | | |
+-----------------------------------------+--------------------------+-----+
| > CPU ロック状態の解除 | | ○○× |
| > | | |
| > unl_cpu(); | | |
+-----------------------------------------+--------------------------+-----+
| > CPU ロック状態の解除 | | ×○× |
| > | | |
| > iunl_cpu(); | | |
+-----------------------------------------+--------------------------+-----+
| > ディスパッチ禁止 | | ○×× |
| > | | |
| > dis_dsp(); | | |
+-----------------------------------------+--------------------------+-----+
| > ディスパッチ許可 | | ○×× |
| > | | |
| > ena_dsp(); | | |
+-----------------------------------------+--------------------------+-----+
| > システムの状態参照 | | ○×× |
| > | | |
| > ref_sys(pk_rsys); | | |
+-----------------------------------------+--------------------------+-----+
| > コンテキストの参照 | | ○○○ |
| > | | |
| > sns_ctx(); | | |
+-----------------------------------------+--------------------------+-----+
| > CPU ロック状態の参照 | | ○○○ |
| > | | |
| > sns_loc(); | | |
+-----------------------------------------+--------------------------+-----+
| > ディスパッチ禁止状態の参照 sns_dsp(); | | ○○○ |
+-----------------------------------------+--------------------------+-----+
| > ディスパッチ保留状態の参照 sns_dpn(); | | ○○○ |
+-----------------------------------------+--------------------------+-----+
凡例
★NORTi独自システムコール
①タスクから発行可能
②タイムイベントハンドラから発行可能
③割込みハンドラから発行可能

割込み管理

+----------------------------------------------------------------+-----+
| > 割込みハンドラの定義 | ○○○ |
| > | |
| > def_inh(inhno, pk_dinh); | |
+================================================================+:====+
| > 割込みサービスルーチン生成 | ○○× |
| > | |
| > cre_isr(isrid, pk_cisr); | |
+----------------------------------------------------------------+-----+
| > 割込みサービスルーチン生成(ID自動割付け) | ○○× |
| > | |
| > acre_isr(pk_cisr); | |
+----------------------------------------------------------------+-----+
| > 割込みサービスルーチン削除 | ○○× |
| > | |
| > del_isr(isrid); | |
+----------------------------------------------------------------+-----+
| > 割込みサービスルーチン状態参照 | ○○○ |
| > | |
| > ref_isr(isrid, pk_risr); | |
+----------------------------------------------------------------+-----+
| > 割込みの禁止 | ○○× |
| > | |
| > dis_int(intno); | |
+----------------------------------------------------------------+-----+
| > 割込みの許可 | ○○× |
| > | |
| > ena_int(intno); | |
+----------------------------------------------------------------+-----+
| > 割込みマスクの変更 | ○○○ |
| > | |
| > chg_ims(imask); | |
+----------------------------------------------------------------+-----+
| > 割込みマスクの参照 | ○○○ |
| > | |
| > get_ims(p_imask); | |
+----------------------------------------------------------------+-----+
| > 割込みハンドラ開始★ | ××○ |
| > | |
| > ient_int(); | |
+----------------------------------------------------------------+-----+
| > 割込みハンドラ終了★ | ××○ |
| > | |
| > iret_int(); | |
+----------------------------------------------------------------+-----+
| > ステータスレジスタセット★ | ○○○ |
| > | |
| > vset_psw(); | |
+----------------------------------------------------------------+-----+
| > ステータスレジスタの割込みマスクセット★ vdis_psw(); | ○○○ |
+----------------------------------------------------------------+-----+
凡例
★NORTi独自システムコール
①タスクから発行可能
②タイムイベントハンドラから発行可能
③割込みハンドラから発行可能

サービスコール管理機能

+-------------------------------------+--------+----------------------------+
| > 拡張サービスコール定義 | | ○○× |
| > | | |
| > def_svc(fncd, pk_dsvc); | | |
+=====================================+========+:===========================+
| > サービスコール呼出し | | ○？？:サービスコールに依存 |
| > | | |
| > cal_svc(fncd, par1, par2, \...); | | |
+-------------------------------------+--------+----------------------------+
凡例
★NORTi独自システムコール
①タスクから発行可能
②タイムイベントハンドラから発行可能
③割込みハンドラから発行可能

システム構成管理

+-------------------------------------+--------------------------+-----+
| > コンフィグレーション情報参照 | | ○○○ |
| > | | |
| > ref_cfg(pk_rcfg); | | |
+=====================================+==========================+:====+
| > バージョン情報参照 | | ○○○ |
| > | | |
| > ref_ver(pk_rver); | | |
+-------------------------------------+--------------------------+-----+
凡例
★NORTi独自システムコール
①タスクから発行可能
②タイムイベントハンドラから発行可能
③割込みハンドラから発行可能

7.3 静的API 一覧

(本ページの内容は、NORTiコンフィグレータのマニュアルへ移動しました)

7.4 パケット構造体一覧

タスク生成情報パケット

```c
typedef struct t_ctsk {
    ATR tskatr;       /* > タスク属性                    */
    VP_INT exinf;     /* タスク拡張情報                  */
    FP task;          /* > タスクとする関数へのポインタ  */
    PRI itskpri;      /* > 起動時タスク優先度            */
    SIZE stksz;       /* > スタックサイズ(バイト数)      */
    VP stk;           /* > スタック領域先頭番地          */
    B *name;          /* > タスク名へのポインタ          */
                      /*                                 */
} T_CTSK;             /*                                 */
```

タスク状態パケット

```c
typedef struct t_rtsk {
    STAT tskstat;   /* タスク状態                       */
    PRI tskpri;     /* > タスク現在優先度               */
    PRI tskbpri;    /* > ベース優先度                   */
    STAT tskwait;   /* > 待ち要因                       */
    ID wid;         /* 待ち対象オブジェクトID           */
    TMO lefttmo;    /* > タイムアウトまでの時間         */
    UINT actcnt;    /* > 起動要求カウント               */
    UINT wupcnt;    /* > 起床要求カウント               */
    UINT suscnt;    /* > 強制待ち要求カウント           */
    VP exinf;       /* > 拡張情報                       */
    ATR tskatr;     /* > タスク属性                     */
    FP task;        /* > タスクとする関数へのポインタ   */
    PRI itskpri;    /* > 起動時タスク優先度             */
    SIZE stksz;     /* > スタックサイズ(バイト数)       */
                    /*                                  */
} T_RTSK;           /*                                  */
```

タスク状態簡易パケット

```c
typedef struct t_rtst {
    STAT tskstat; /* タスク状態 */
    STAT tskwait; /* 待ち要因 */
} T_RTST;
```

タスク例外処理生成情報パケット

```c
typedef struct t_dtex {
    ATR texatr; /* タスク例外処理属性 */
    FP texrtn;  /* タスク例外処理関数へのポインタ */
} T_DTEX;
```

タスク例外処理状態パケット

```c
typedef struct t_rtex {
    STAT texstat;  /* タスク例外処理状態 */
    TEXPTN pndptn; /* 例外処理保留起動要因 */
} T_RTEX;
```

セマフォ生成情報パケット

```c
typedef struct t_csem {
    ATR sematr;  /* セマフォ属性 */
    UINT isemcnt; /* セマフォ初期値 */
    UINT maxsem; /* セマフォ 最大値 */
    B *name;     // セマフォ名へのポインタ
} T_CSEM;
```

セマフォ状態パケット

```c
typedef struct t_rsem {
    ID wtskid;   /* 待ちタスクのID */
    UINT semcnt; /* セマフォ値 */
} T_RSEM;
```

イベントフラグ生成情報パケット

```c
typedef struct t_cflg {
    ATR flgatr;    /* イベントフラグ属性 */
    FLGPTN iflgptn; /* イベントフラグ初期値 */
    B *name;       /* イベントフラグ名へのポインタ */
} T_CFLG;
```

イベントフラグ状態パケット

```c
typedef struct t_rflg {
    ID wtskid;     /* 待ちタスクのID */
    FLGPTN flgptn; /* イベントフラグ値 */
} T_RFLG;
```

データキュー生成情報パケット

```c
typedef struct t_cdtq {
    ATR dtqatr;  /* データキュー属性                */
    UINT dtqcnt; /* > データキューサイズ(データ数)  */
    VP dtq;      /* リングバッファアドレス          */
    B *name;     /* > データキュー名へのポインタ    */
                 /*                                 */
} T_CDTQ;        /*                                 */
```

データキュー状態パケット

```c
typedef struct t_rdtq {
    ID stskid;    /* 送信待ちタスクのID */
    ID rtskid;    /* 受信待ちタスクのID */
    UINT sdtqcnt; // データキューに入っているデータ数
} T_RDTQ;
```

メールボックス生成情報パケット

```c
typedef struct t_cmbx {
    ATR mbxatr;   /* メールボックス属性 */
    PRI maxmpri;  /* メッセージ優先度の数 */
    VP mprihd;    /* メッセージ待ち行列ヘッダへのポインタ */
    B *name;      /* メールボックス名へのポインタ */
} T_CMBX;
```

メールボックス状態パケット

```c
typedef struct t_rmbx {
    ID wtskid;     /* 受信待ちタスクID */
    T_MSG *pk_msg; /* 次に送信されるメッセージへのポインタ */
} T_RMBX;
```

ミューテックス生成情報パケット

```c
typedef struct t_cmtx {
    ATR mtxatr;  /* ミューテックス属性 */
    PRI ceilpri; /* シーリングプロトコルにおける上限優先度 */
    B *name;     /* ミューテックス名へのポインタ */
} T_CMTX;
```

# ミューテックス状態パケット

```c
typedef struct t_rmtx {
    ID htskid; /* ロックしているタスクのID */
    ID wtskid; /* 解除待ちしているタスクのID */
} T_RMTX;
```

メッセージバッファ生成情報パケット

```c
typedef struct t_cmbf {
    ATR mbfatr; /* > メッセージバッファ属性            */
    UINT maxmsz; /* > メッセージ 大長                   */
    SIZE mbfsz; /* > メッセージバッファサイズ          */
    VP mbf;     /* メッセージバッファアドレス          */
    B *name;    /* > メッセージバッファ名へのポインタ  */
                /*                                     */
} T_CMBF;       /*                                     */
```

メッセージバッファ状態パケット

```c
typedef struct t_rmbf {
    ID stskid;    /* 送信待ちタスクのID */
    ID rtskid;    /* 受信待ちタスクのID */
    UINT smsgcnt; /* メッセージバッファに入っているメッセージ数 */
    SIZE fmbfsz;  /* バッファの空きサイズ(バイト数) */
} T_RMBF;
```

ランデブ用ポート生成情報パケット

```c
typedef struct t_cpor {
    ATR poratr;  /* ランデブ用ポート属性 */
    UINT maxcmsz; /* 呼出メッセージ 最大長 */
    UINT maxrmsz; /* 応答メッセージ 最大長 */
    B *name;     /* ランデブ用ポート名へのポインタ */
} T_CPOR;
```

ランデブ用ポート状態パケット

```c
typedef struct t_rpor {
    ID ctskid; /* 呼出待ちタスクのID */
    ID atskid; /* 応答待ちタスクのID */
} T_RPOR;
```

ランデブ状態パケット

```c
typedef struct t_rrdv {
    ID wtskid; /* ランデブ終了待ちタスクのID */
} T_RRDV;
```

割込みハンドラ定義情報パケット

```c
typedef struct t_dinh {
    ATR inhatr; /* 割込みハンドラ属性 */
    FP inthdr;  /* 割込みハンドラ関数のアドレス */
    UINT imask; /* 割込みマスク */
} T_DINH;
```

割込みサービスルーチン生成情報パケット

```c
typedef struct t_cisr {
    ATR istatr;   /* 割込みサービスルーチン属性        */
    VP_INT exinf; /* 拡張情報                          */
    INTNO intno;  /* 割込み番号                        */
    FP isr;       /* 割込みサービスルーチンのアドレス  */
    UINT imask;   /* 割込みマスク                      */
                  /*                                   */
} T_CISR;         /*                                   */
```

割込みサービスルーチン状態パケット

```c
typedef struct t_risr {
    INTNO intno; /* 割込み番号 */
    UINT imask;  /* 割込みマスク */
} T_RISR;
```

可変長メモリプール生成情報パケット

```c
typedef struct t_cmpl {
    ATR mplatr; /* > 可変長メモリプール属性            */
    SIZE mplsz; /* > 可変長メモリプールサイズ(バイト)  */
    VP mpl;     /* 可変長メモリプールアドレス          */
    B *name;    /* > 可変長メモリプール名へのポインタ  */
                /*                                     */
} T_CMPL;       /*                                     */
```

可変長メモリプール状態パケット

```c
typedef struct t_rmpl {
    ID wtskid;   /* 獲得待ちタスクのID */
    SIZE fmplsz; /* 空き領域の合計サイズ(バイト) */
    UINT fblksz; /* 最大連続空き領域サイズ(バイト) */
} T_RMPL;
```

固定長メモリプール生成情報パケット

```c
typedef struct t_cmpf {
    ATR mpfatr; /* 固定長メモリプール属性              */
    UINT blkcnt; /* > 総メモリブロック数                */
    UINT blfsz; /* メモリブロックのサイズ(バイト)      */
    VP mpf;     /* メモリプールアドレス                */
    B *name;    /* > 固定長メモリプール名へのポインタ  */
                /*                                     */
} T_CMPF;       /*                                     */
```

固定長メモリプール状態パケット

```c
typedef struct t_rmpf {
    ID wtskid;   /* 獲得待ちタスクのID */
    UINT frbcnt; /* 空きブロック数 */
} T_RMPF;
```

周期ハンドラ生成情報パケット

```c
typedef struct t_ccyc {
    ATR cycatr;    /* 周期ハンドラ属性 */
    VP_INT exinf;  /* 拡張情報 */
    FP cychdr;     /* 周期ハンドラ関数のアドレス */
    RELTIM cyctim; /* 起動周期 */
    RELTIM cycphs; /* 起動位相 */
} T_CCYC;
```

周期ハンドラ状態パケット

```c
typedef struct t_rcyc {
    STAT cycstat;   /* 周期ハンドラ動作状態 */
    RELTIM lefttim; /* 起動すべき時刻までの時間 */
} T_RCYC;
```

アラームハンドラ生成情報パケット

```c
typedef struct t_calm {
    ATR almatr;   /* アラームハンドラ属性 */
    VP_INT exinf; /* 拡張情報 */
    FP almhdr;    /* アラームハンドラ関数へのアドレス */
} T_CALM;
```

アラームハンドラ状態パケット

```c
typedef struct t_ralm {
    STAT almstat;   /* アラームハンドラ状態 */
    RELTIM lefttim; /* 起動すべき時刻までの時間 */
} T_RALM;
```

オーバーランハンドラ生成情報パケット

```c
typedef struct t_dovr {
    ATR ovratr; /* オーバーランハンドラ属性              */
    FP ovrhdr;  /* オーバーランハンドラ関数へのアドレス  */
    INTNO intno; /* > 使用する割込み番号                  */
    FP ovrclr;  /* 割込み要因クリア関数へのポインタ      */
    UINT imask; /* 割込みマスク                          */
                /*                                       */
} T_DOVR;       /*                                       */
```

オーバーランハンドラ状態パケット

```c
typedef struct t_rovr {
    STAT ovrstat;   /* オーバーランハンドラ状態 */
    OVRTIM leftotm; /* タスク残り実行時間 */
} T_ROVR;
```

バージョン情報パケット

```c
typedef struct t_rver {
    UH maker;  /* > メーカーコード          */
    UH prid;   /* > カーネル識別番号        */
    UH spver;  /* ITRON仕様書バージョン     */
    UH prver;  /* > カーネルバージョン番号  */
    UH prno[4]; /* > 管理情報                */
               /*                           */
} T_RVER;      /*                           */
```

システム状態パケット

```c
typedef struct t_rsys {
    INT sysstat; /* システム状態 */
} T_RSYS;
```

コンフィグレーション情報パケット

```c
typedef struct t_rcfg {
    ID tskid_max; /* > タスクID上限                                     */
    ID semid_max; /* > セマフォID上限                                   */
    ID flgid_max; /* > イベントフラグID上限                             */
    ID mbxid_max; /* > メールボックスID上限                             */
    ID mbfid_max; /* メッセージバッファID上限                           */
    ID porid_max; /* ランデブ用ポートID上限                             */
    ID mplid_max; /* 可変長メモリプールID上限                           */
    ID mpfid_max; /* 固定長メモリプールID上限                           */
    ID cycno_max; /* 周期ハンドラID上限                                 */
    ID almno_max; /* アラームハンドラID上限                             */
    PRI tpri_max; /* > タスク優先度上限                                 */
    int tmrqsz;   /* > タスクのタイマキューサイズ(バイト数)             */
    int cycqsz;   /* > 周期ハンドラのタイマキューサイズ(バイト数)       */
    int almqsz;   /* > アラームハンドラのタイマキューサイズ(バイト数)   */
    int istksz;   /* > 割込みハンドラのスタックサイズ(バイト数)         */
    int tstksz; /* > タイムイベントハンドラのスタックサイズ(バイト数) */
    SIZE sysmsz;  /* > システムメモリのサイズ(バイト数)                 */
    SIZE mplmsz;  /* > メモリプール用メモリのサイズ(バイト数)           */
    SIZE stkmsz;  /* > スタック用メモリのサイズ(バイト数)               */
    ID dtqid_max; /* > データキューID上限                               */
    ID mtxid_max; /* > ミューテックスID上限                             */
    ID isrid_max; /* > 割込みサービスルーチンID上限                     */
    ID svcfn_max; /* > 拡張サービスコール機能番号上限                   */
                  /*                                                    */
} T_RCFG;         /*                                                    */
```

拡張サービスコール定義情報

```c
typedef struct t_dsvc {
    ATR svcatr; /* 拡張サービスコール属性 */
    FP svcrtn;  /* 拡張サービスコールルーチンアドレス */
    INT parn;   /* 拡張サービスコールルーチンのパラメータ数 */
} T_DSVC;
```

7.5 定数一覧
タスク/ハンドラ属性

+--------------------+------------+------------------------------------------+
| TA_HLNG 0x0000 | | 高級言語で記述されている |
+====================+============+==========================================+
| TA_ACT 0x0002 | | > タスク実行可能状態でタスク生成 |
| | | |
| タスク待ち行列属性 | | |
+--------------------+------------+------------------------------------------+
| TA_TFIFO | 0x0000 | > 先着順 |
+--------------------+------------+------------------------------------------+
| TA_TPRI | 0x0001 | タスク優先度順 |
+--------------------+------------+------------------------------------------+
| TA_TPRIR | 0x0004 | > 受信タスク優先度順(メッセージバッファ) |
| | | |
| タイムアウト | | |
+--------------------+------------+------------------------------------------+
| TMO_POL | > 0 | > ポーリング(待ちなし) |
+--------------------+------------+------------------------------------------+
| TMO_FEVR | > -1 | > 無限待ち(タイムアウトなし) |
| | | |
| タスクID | | |
+--------------------+------------+------------------------------------------+
| TSK_SELF | > 0 | > 自タスク指定 |
+--------------------+------------+------------------------------------------+
| TSK_NONE | > 0 | > タスクなし |
| | | |
| タスク優先度 | | |
+--------------------+------------+------------------------------------------+
| TPRI_INI | > 0 | > 起動時優先度 |
+--------------------+------------+------------------------------------------+
| TPRI_SELF | > 0 | > 自タスクのベース優先度 |
+--------------------+------------+------------------------------------------+
| TMIN_TPRI | > 1 | > 優先度の 小値 |
+--------------------+------------+------------------------------------------+

TMAX_TPRI 優先度の 大値（値はコンフィグレーションに依存）
タスク状態

+--------------------------------------+-------------------------------+
| TTS_RUN 0x0001 | > 実行状態 |
+======================================+===============================+
| TTS_RDY 0x0002 | 実行可能状態 |
+--------------------------------------+-------------------------------+
| TTS_WAI 0x0004 | > WAITING状態 |
+--------------------------------------+-------------------------------+
| TTS_SUS 0x0008 | > SUSPENDED状態 |
+--------------------------------------+-------------------------------+
| TTS_WAS 0x000c | > WAITING-SUSPENDED状態 |
+--------------------------------------+-------------------------------+
| TTS_DMT 0x0010 | > DORMANT状態 |
| | |
| タスク例外処理状態 | |
+--------------------------------------+-------------------------------+
| TTEX_ENA 0x00 | タスク例外処理許可 |
+--------------------------------------+-------------------------------+
| TTEX_DIS 0x01 | タスク例外処理禁止 |
+--------------------------------------+-------------------------------+
タスク待ち要因

+--------------------+------------+------------------------------------------+
| TTW_SLP | > 0x0001 | > 起床待ち |
+====================+============+==========================================+
| TTW_DLY | > 0x0002 | > 時間待ち |
+--------------------+------------+------------------------------------------+
| TTW_SEM | 0x0004 | セマフォ獲得待ち |
+--------------------+------------+------------------------------------------+
| TTW_FLG | 0x0008 | イベントフラグ待ち |
+--------------------+------------+------------------------------------------+
| TTW_SDTQ | 0x0010 | > データキュー送信待ち |
+--------------------+------------+------------------------------------------+
| TTW_RDTQ | 0x0020 | > データキュー受信待ち |
+--------------------+------------+------------------------------------------+
| TTW_MBX | 0x0040 | メールボックスでメッセージ待ち |
+--------------------+------------+------------------------------------------+
| TTW_MTX | 0x0080 | ミューテックス獲得待ち |
+--------------------+------------+------------------------------------------+
| TTW_SMBF | > 0x0100 | > メッセージバッファでメッセージ送信待ち |
+--------------------+------------+------------------------------------------+
| TTW_MBF | 0x0200 | > メッセージバッファでメッセージ受信待ち |
+--------------------+------------+------------------------------------------+
| TTW_CAL | 0x0400 | ランデブ呼出待ち |
+--------------------+------------+------------------------------------------+
| TTW_ACP | 0x0800 | ランデブ受付け待ち |
+--------------------+------------+------------------------------------------+
| TTW_RDV | 0x1000 | ランデブ終了待ち |
+--------------------+------------+------------------------------------------+
| TTW_MPF | 0x2000 | 可変長メモリブロック獲得待ち |
+--------------------+------------+------------------------------------------+
| TTW_MPL | 0x4000 | 固定長メモリブロック獲得待ち |
+--------------------+------------+------------------------------------------+
| イベントフラグ属性 | | |
+--------------------+------------+------------------------------------------+
| TA_WSGL 0x0000 | | > 複数タスク待ち禁止 |
+--------------------+------------+------------------------------------------+
| TA_CLR 0x0004 | | > クリア指定 |
+--------------------+------------+------------------------------------------+
| TA_WMUL 0x0002 | | > 複数タスク待ち許可 |
+--------------------+------------+------------------------------------------+
イベントフラグ待ちモード

| TWF_ANDW 0x0000 | > AND待ち |
+=======================================+==============================+
| TWF_ORW 0x0001 | > OR待ち |

| TWF_CLR 0x0004 | クリア指定 |
| | |
| メッセージ待ち行列 | |

| TA_MFIFO 0x0000 | 先着順 |

| TA_MPRI 0x0002 | メッセージ優先度順 |
| | |
| メッセージ優先度 | |

| TMIN_MPRI 1 | > メッセージ 高優先度 |
| | |
| ミューテックス属性 | |

| TA_INHERIT 0x0002 | > 優先度継承プロトコル |

| TA_CEILING 0x0003 | > 優先度上限プロトコル |
| | |
| ランデブ用ポート属性 | |

| TA_NULL 0 | 属性特になし |

周期ハンドラ属性

| TA_STA 0x0002 | > 周期ハンドラ起動 |
+===========================================+==========================+
| TA_PHS 0x0004 | 位相保存 |
| | |
| 周期ハンドラ状態 | |

| TCYC_STP 0x0000 | 停止状態 |

| TCYC_STA 0x0001 | 動作状態 |
| | |
| アラームハンドラ状態 | |

| TALM_STP 0x0000 | 停止状態 |

| TALM_STA 0x0001 | 動作状態 |

オーバーランハンドラ状態

+--------------------------+----------------------------------------------+
| TOVR_STP 0x0000 | 停止状態 |
+==========================+==============================================+
| TOVR_STA 0x0001 | 動作状態 |
| | |
| システム状態 | |
+--------------------------+----------------------------------------------+
| TSS_TSK 0 | タスクコンテキスト部 |
+--------------------------+----------------------------------------------+
| TSS_DDSP 1 | > タスクコンテキスト部(ディスパッチ禁止状態) |
+--------------------------+----------------------------------------------+
| TSS_LOC 3 | タスクコンテキスト部(CPUロック状態) |
+--------------------------+----------------------------------------------+
| TSS_INDP 4 | > 非タスクコンテキスト部 |
+--------------------------+----------------------------------------------+
キューイング数等の 大値
TMAX_WUPCNT 255 wup_tskによる起床要求数の 大値
TMAX_SUSCNT 255 sus_tskによる強制待ち要求数の 大値
TMAX_ACTCNT 255 act_tskによる起動要求数の 大値 TMAX_MAXSEM 65535 セマフォカウントの 大値
その他の定数

---

TRUE 1 真

---

FALSE 0 偽

---

7.6 NORTi3互換モード

kernel.hの代わりにnorti3.hをインクルードすることで、NORTi Version 4の「NORTi3互換モード」を利用することができます。すなわち、μITRON3.0仕様のNORTi3 Extendedと同じ形式のシステムコールが、μITRON4.0仕様であるNORTi Version 4でも使用可能となります。両仕様のシステムコールの混在もソースファイル単位でなら可能であり、両仕様に共通のオブジェクトに対しては、例えば、μITRON3.0 仕様のシステムコールで送信したメッセージを、μITRON4.0 仕様のシステムコールで受信するということもできます。

ただし、μITRON4.0仕様との関係で以下の点が完全にはNORTi3互換ではありません。

・ 自タスクに対する強制終了(ter_tsk)エラーコードはE_OBJではなくE_ILUSEです。

・ 自タスクに対する起床要求(wup_tsk)はエラーとならず、キューイングされます。

・ 複数タスク待ちを許さないイベントフラグに対して、wai_flg で複数タスク待ちした場合のエラーコードはE_OBJではなくE_ILUSEです。

・ 自タスクに対する強制待ち要求(sus_tsk)は、ディスパッチ禁止状態でなければエラーになりません。

・ メールボックスで、FIFOではなく優先度つきメッセージキューを指定した場合の 大優先度はタスク優先度 大値と同一になります。

・ オブジェクト生成情報のμITRON4.0仕様で削除されたメンバー、例えば、拡張情報は指定しても無視されます。オブジェクト状態を参照するシステムコール(ref_xxx)ではこれらに対してNULLを返します。

・ tcal_porのタイムアウトの考え方が変更になったためpcal_porは使用できません。またfwd_porにおけるタイムアウトの意味もμITRON4.0仕様と同じに変更となっています。

・ アラームハンドラの実行によってアラームハンドラは自動定義解除されません。

また、NORTi Version 4の実装上の理由から、以下の点にご注意ください。

・ 自動ID割付は、使用可能ID番号の高い番号から順に割り当てられます。

・ ID番号0は、cre_yyyにおいて自動ID割付と解釈されて処理され、エラーにはなりません。

・ μITRON3.0 仕様のオブジェクト生成情報(T_CXXX 型)は、μITRON4.0 仕様の型に変換されてシステムメモリにコピーされるのでシステムメモリ消費量が多くなります。
